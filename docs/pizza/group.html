<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>group API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>group</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac, Han Chen&#34;
__copyright__ = &#34;Copyright 2023&#34;
__credits__ = [&#34;Olivier Vitrac&#34;,&#34;Han Chen&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.9999&#34;


&#34;&#34;&#34;
===============================================
          pizza.group Class Manual
===============================================

## Introduction

The `group` class provides a Pythonic interface to manage groups of atoms in LAMMPS simulations through the Pizza.py toolkit. In LAMMPS, groups are fundamental for applying operations to subsets of atoms, such as assigning force fields, computing properties, or setting up constraints. The `group` class allows users to create, manipulate, and combine groups of atoms programmatically, mirroring the functionality of LAMMPS group commands within a Python environment.

Unlike the `pizza.region` class, which allows for dynamic geometrical definitions, the `group` class operates statically. This choice is due to the nature of atom groups in LAMMPS, which are snapshots of atom collections at a specific time, rather than dynamic entities that change over time.

## Overview

Groups are stored and managed via a collection of operations. Each operation represents a LAMMPS group command or a combination of groups using algebraic operations. The `group` class facilitates both the creation of basic groups and the combination of existing groups using union, intersection, and subtraction.

The class supports both high-level methods, which correspond directly to LAMMPS commands, and low-level methods for internal management of group operations.

---

## High-Level Methods

These methods correspond directly to LAMMPS group commands and allow for the creation and manipulation of groups based on various criteria.

### `region(group_name, regionID)`

- **Description**: Defines a group of atoms based on a specified region ID.
- **Usage**: `G.region(&#39;group_name&#39;, &#39;regionID&#39;)`
- **Example**:
  - In LAMMPS:
    ```lammps
    region myRegion block 0 10 0 10 0 10 units box
    group myGroup region myRegion
    ```
  - In Python:
    ```python
    G = group()
    G.region(&#39;myGroup&#39;, &#39;myRegion&#39;)
    ```

### `type(group_name, type_values)`

- **Description**: Selects atoms by their type and assigns them to a group.
- **Usage**: `G.type(&#39;group_name&#39;, type_values)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group myGroup type 1 2
    ```
  - In Python:
    ```python
    G = group()
    G.type(&#39;myGroup&#39;, [1, 2])
    ```

### `id(group_name, id_values)`

- **Description**: Selects atoms by their IDs and assigns them to a group.
- **Usage**: `G.id(&#39;group_name&#39;, id_values)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group myGroup id 1 2 3
    ```
  - In Python:
    ```python
    G = group()
    G.id(&#39;myGroup&#39;, [1, 2, 3])
    ```

### `variable(group_name, variable_name, expression, style=&#34;atom&#34;)`

- **Description**: Defines a group based on an atom-style variable expression.
- **Usage**: `G.variable(&#39;group_name&#39;, &#39;variable_name&#39;, &#39;expression&#39;, style=&#39;atom&#39;)`
- **Example**:
  - In LAMMPS:
    ```lammps
    variable myVar atom &#34;x &gt; 5&#34;
    group myGroup variable myVar
    ```
  - In Python:
    ```python
    G = group()
    G.variable(&#39;myGroup&#39;, &#39;myVar&#39;, &#39;x &gt; 5&#39;)
    ```

### `create(group_name)`

- **Description**: Creates a new empty group or clears an existing group.
- **Usage**: `G.create(&#39;group_name&#39;)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group myGroup clear
    ```
  - In Python:
    ```python
    G = group()
    G.create(&#39;myGroup&#39;)
    ```

### Algebraic Operations

The `group` class supports algebraic operations between groups using the overloaded operators `+`, `-`, and `*` for union, subtraction, and intersection, respectively.

#### `union(group_name, *groups)`

- **Description**: Creates a new group by performing the union of specified groups.
- **Usage**: `G.union(&#39;new_group&#39;, *groups)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group newGroup union group1 group2
    ```
  - In Python:
    ```python
    G.union(&#39;newGroup&#39;, &#39;group1&#39;, &#39;group2&#39;)
    ```

#### `intersect(group_name, *groups)`

- **Description**: Creates a new group by performing the intersection of specified groups.
- **Usage**: `G.intersect(&#39;new_group&#39;, *groups)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group newGroup intersect group1 group2
    ```
  - In Python:
    ```python
    G.intersect(&#39;newGroup&#39;, &#39;group1&#39;, &#39;group2&#39;)
    ```

#### `subtract(group_name, *groups)`

- **Description**: Creates a new group by subtracting specified groups from the first group.
- **Usage**: `G.subtract(&#39;new_group&#39;, *groups)`
- **Example**:
  - In LAMMPS:
    ```lammps
    group newGroup subtract group1 group2
    ```
  - In Python:
    ```python
    G.subtract(&#39;newGroup&#39;, &#39;group1&#39;, &#39;group2&#39;)
    ```

### `evaluate(group_name, group_op)`

- **Description**: Evaluates complex group expressions involving algebraic operations and stores the result in a new group.
- **Usage**: `G.evaluate(&#39;new_group&#39;, group_op)`
- **Example**:
  ```python
  G = group()
  G.create(&#39;o1&#39;)
  G.create(&#39;o2&#39;)
  G.create(&#39;o3&#39;)
  complex_op = G[&#39;o1&#39;] + G[&#39;o2&#39;] + G[&#39;o3&#39;]
  G.evaluate(&#39;combinedGroup&#39;, complex_op)



Created on Wed Aug 16 16:25:19 2023

@author: olivi
&#34;&#34;&#34;

# Revision history
# 2023-08-17 RC with documentation, the script method is not implemented yet (to be done via G.code())
# 2023-08-18 consolidation of the GroupOperation mechanism (please still alpha version)
# 2023-09-01 the class GroupOperation has been removed and the collapse is carried within Operation to avoid unecessary complications [major release]
# 2024-10-04 code optimization
# 2024-10-07 implementation of dscript, script, pipescript
# 2024-10-08 code finalization (flexible initialization), updated documentation
# 2024-10-11 advanced indexing and scripting
# 2024-10-12 add copy and deepcopy features
# 2024-11-29 add groupobjects, groupcollection
# 2024-12-01 standarize scripting features, automatically call script/pscript methods

# %% Dependencies
# pizza.group is independent of region and can performs only static operations.
# It is designed to be compatible with region via G.script()
from typing import List, Union, Optional, Tuple
import hashlib, random, string, copy
from pizza.script import span, pipescript
from pizza.dscript import dscript

__all__ = [&#39;Operation&#39;, &#39;dscript&#39;, &#39;format_table&#39;, &#39;generate_random_name&#39;, &#39;group&#39;, &#39;groupcollection&#39;, &#39;groupobject&#39;, &#39;pipescript&#39;, &#39;span&#39;, &#39;truncate_text&#39;]

# %% Private functions

# Helper function that generates a random string of a specified length using uppercase and lowercase letters.
def generate_random_name(length=8):
    letters = string.ascii_letters  # &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    return &#39;&#39;.join(random.choice(letters) for _ in range(length))

# Helper function that truncates text
def truncate_text(txt, maxwidth):
    &#34;&#34;&#34;
    Truncates the input text to fit within the specified maximum width.
    If the text is longer than `maxwidth`, it is shortened by keeping
    the beginning and trailing parts, separated by &#34; [...] &#34;.

    ### Parameters:
        txt (str): The text to truncate.
        maxwidth (int): The maximum allowed width for the text.

    ### Returns:
        str: The truncated text with &#34; [...] &#34; in the middle if truncation occurs.

    ### Example:
        &gt;&gt;&gt; truncate_text(&#34;This is a long string that needs truncation.&#34;, 20)
        &#39;This is [...] truncation.&#39;
    &#34;&#34;&#34;
    # If the text fits within maxwidth, return it as is
    if len(txt) &lt;= maxwidth:
        return txt
    # Calculate the part lengths for beginning and end
    ellipsis = &#34; [...] &#34;
    split_length = (maxwidth - len(ellipsis)) // 2
    beginning = txt[:split_length]
    trailing = txt[-split_length:]
    return f&#34;{beginning}{ellipsis}{trailing}&#34;


# Helper function that generate a pretty table
def format_table(
    headers: List[str],
    rows: List[List[str]],
    col_max_widths: List[int],
    align: Union[str, List[str]] = &#34;C&#34;,
) -&gt; str:
    &#34;&#34;&#34;
    Formats a table with given headers and rows, truncating text based on maximum column widths
    and aligning content based on the specified alignment.

    ### Parameters:
        headers (List[str]): List of column headers.
        rows (List[List[str]]): List of rows, where each row is a list of column values.
        col_max_widths (List[int]): List of maximum widths for each column.
        align (str or List[str], optional): Alignment for each column. Can be a single string
                                            (applies to all columns) or a list of strings (one for each column).
                                            Options are:
                                            - &#34;C&#34; or &#34;center&#34; for centered alignment (default).
                                            - &#34;L&#34; or &#34;left&#34; for left alignment.
                                            - &#34;R&#34; or &#34;right&#34; for right alignment.
                                            Case insensitive.

    ### Returns:
        str: A formatted table as a string.

    ### Raises:
        ValueError: If `align` is a list but its length does not match the number of columns.

    ### Example:
        &gt;&gt;&gt; headers = [&#34;Idx&#34;, &#34;Name&#34;, &#34;Value&#34;]
        &gt;&gt;&gt; rows = [[1, &#34;Example&#34;, &#34;12345&#34;], [2, &#34;LongerName&#34;, &#34;67890&#34;]]
        &gt;&gt;&gt; col_max_widths = [5, 10, 8]
        &gt;&gt;&gt; align = [&#34;R&#34;, &#34;C&#34;, &#34;L&#34;]
        &gt;&gt;&gt; print(format_table(headers, rows, col_max_widths, align))
        Idx   |   Name    | Value
        ----- | ---------- | --------
          1   |  Example  | 12345
          2   | LongerName | 67890
    &#34;&#34;&#34;
    # Normalize alignment input
    if isinstance(align, str):
        align = [align.upper()] * len(headers)
    elif isinstance(align, list):
        align = [a.upper() for a in align]
        if len(align) != len(headers):
            raise ValueError(&#34;The length of `align` must match the number of columns.&#34;)
    else:
        raise TypeError(&#34;`align` must be a string or a list of strings.&#34;)

    # Determine actual column widths based on headers and max widths
    col_widths = [
        min(max(len(header), *(len(str(row[i])) for row in rows)), max_w)
        for i, header in enumerate(headers)
        for max_w in [col_max_widths[i]]
    ]
    # Prepare alignment formatting
    alignments = []
    for a in align:
        if a in (&#34;C&#34;, &#34;CENTER&#34;):
            alignments.append(&#34;^&#34;)
        elif a in (&#34;L&#34;, &#34;LEFT&#34;):
            alignments.append(&#34;&lt;&#34;)
        elif a in (&#34;R&#34;, &#34;RIGHT&#34;):
            alignments.append(&#34;&gt;&#34;)
        else:
            raise ValueError(f&#34;Invalid alignment value: {a}&#34;)
    # Prepare header line
    header_line = &#34; | &#34;.join(
        f&#34;{headers[i]:{alignments[i]}{col_widths[i]}}&#34; for i in range(len(headers))
    )
    # Prepare separator
    separator = &#34; | &#34;.join(&#34;-&#34; * col_widths[i] for i in range(len(col_widths)))
    # Prepare rows
    formatted_rows = []
    for row in rows:
        formatted_row = [
            f&#34;{str(row[i]):{alignments[i]}{col_widths[i]}}&#34; for i in range(len(row))
        ]
        formatted_rows.append(&#34; | &#34;.join(formatted_row))
    # Combine all parts
    table = [header_line, separator] + formatted_rows + [separator]
    return &#34;\n&#34;.join(table)


# %% Low-level classes groupobjects, groupcollection

# groupobject class for groups defined based on a collection of groupobjects
class groupobject:
    &#34;&#34;&#34;
    Represents an object with a bead type, associated groups, and an optional mass.

    ### Attributes:
        beadtype (int or float): The bead type identifier. Must be an integer or a real scalar.
        group (List[str]): List of group names the object belongs to.
        mass (Optional[float]): The mass of the bead. Must be a real scalar or None.
        name (Optional[str]): Name of the object

    ### Examples:
        &gt;&gt;&gt; o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        &gt;&gt;&gt; o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        &gt;&gt;&gt; o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)
    &#34;&#34;&#34;

    def __init__(self, beadtype: Union[int, float], group: Union[str, List[str], Tuple[str, ...]], \
                 mass: Optional[Union[int, float]] = None, name: Optional[str]=None, ):
        &#34;&#34;&#34;
        Initializes a new instance of the groupobject class.

        ### Parameters:
            beadtype (int or float): The bead type identifier.
            group (str, list of str, or tuple of str): Group names the object belongs to.
            mass (float or int, optional): The mass of the bead.

        ### Raises:
            TypeError: If `beadtype` is not an int or float.
            TypeError: If `group` is not a str, list of str, or tuple of str.
            TypeError: If `mass` is not a float, int, or None.
        &#34;&#34;&#34;
        # Validate beadtype
        if not isinstance(beadtype, (int, float)):
            raise TypeError(f&#34;&#39;beadtype&#39; must be an integer or float, got {type(beadtype).__name__} instead.&#34;)
        self.beadtype = beadtype
        # Validate group
        if isinstance(group, str):
            self.group = [group]
        elif isinstance(group, (list, tuple)):
            if not all(isinstance(g, str) for g in group):
                raise TypeError(&#34;All elements in &#39;group&#39; must be strings.&#34;)
            self.group = list(group)
        else:
            raise TypeError(f&#34;&#39;group&#39; must be a string, list of strings, or tuple of strings, got {type(group).__name__} instead.&#34;)
        # Validate mass
        if mass is not None and not isinstance(mass, (int, float)):
            raise TypeError(f&#34;&#39;mass&#39; must be a real scalar (int or float) or None, got {type(mass).__name__} instead.&#34;)
        self.mass = mass
        # Validate name
        self.name = f&#34;beadtype={beadtype}&#34; if name is None else name

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a readable string representation of the groupobject.
        &#34;&#34;&#34;
        return f&#34;groupobject | type={self.beadtype} | name={self.group} | mass={self.mass}&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns an unambiguous string representation of the groupobject.

        ### Returns:
            str: String representation including beadtype, group, and mass (if not None).
        &#34;&#34;&#34;
        return f&#34;groupobject(beadtype={self.beadtype}, group={span(self.group,&#39;,&#39;,&#39;[&#39;,&#39;]&#39;)}, name={self.name}, mass={self.mass})&#34;


    def __add__(self, other: Union[&#39;groupobject&#39;, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds this groupobject to another groupobject or a groupcollection.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new groupcollection instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection([self, other])
        elif isinstance(other, groupcollection):
            return groupcollection([self] + other.collection)
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)

    def __radd__(self, other: Union[&#39;groupobject&#39;, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds this groupobject to another groupobject or a groupcollection from the right.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new groupcollection instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection([other, self])
        elif isinstance(other, groupcollection):
            return groupcollection(other.collection + [self])
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)


class groupcollection:
    &#34;&#34;&#34;
    Represents a collection of `groupobject` instances, typically formed by combining them.

    ### Attributes:
        collection (List[groupobject]): The list of `groupobject` instances in the collection.
        name (str): The name of the collection, generated automatically if not provided.

    ### Examples:
        &gt;&gt;&gt; o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        &gt;&gt;&gt; o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        &gt;&gt;&gt; G = groupcollection([o1, o2])
        &gt;&gt;&gt; print(G.name)
        beadtype=1,2
    &#34;&#34;&#34;
    def __init__(self, collection: List[&#39;groupobject&#39;], name: Optional[str] = None):
        &#34;&#34;&#34;
        Initializes a new instance of the groupcollection class.

        ### Parameters:
            collection (List[groupobject]): A list of `groupobject` instances to include in the collection.
            name (str, optional): The name of the collection. If not provided, a default name is generated.

        ### Raises:
            ValueError: If the `collection` is empty or contains invalid elements.
        &#34;&#34;&#34;
        if not isinstance(collection, list) or not all(isinstance(obj, groupobject) for obj in collection):
            raise ValueError(&#34;`collection` must be a list of `groupobject` instances.&#34;)
        if not collection:
            raise ValueError(&#34;`collection` cannot be empty.&#34;)

        self.collection = collection

        # Automatically assign a name if not provided
        if name is None:
            # Extract names or &#34;beadtype=X&#34; patterns
            beadtype_names = [
                obj.name if obj.name.startswith(&#34;beadtype=&#34;) else None for obj in collection
            ]

            # If all objects have beadtype names, use &#34;beadtype=1,2,3&#34; pattern
            if all(beadtype_names):
                beadtypes = [obj.beadtype for obj in collection]
                self.name = &#34;beadtype={}&#34;.format(&#34;,&#34;.join(map(str, sorted(beadtypes))))
            else:
                # Fall back to concatenating names
                self.name = &#34;,&#34;.join(obj.name for obj in collection)
        else:
            self.name = name


    def __add__(self, other: Union[groupobject, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds a `groupobject` or another `groupcollection` to this collection.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new `groupcollection` instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection(self.collection + [other])
        elif isinstance(other, groupcollection):
            return groupcollection(self.collection + other.collection)
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)

    def __iadd__(self, other: Union[groupobject, List[groupobject], Tuple[groupobject, ...]]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        In-place addition of a `groupobject` or a list/tuple of `groupobject` instances.

        ### Parameters:
            other (groupobject or list/tuple of groupobject): The object(s) to add.

        ### Returns:
            groupcollection: The updated `groupcollection` instance.

        ### Raises:
            TypeError: If `other` is not a `groupobject` or a list/tuple of `groupobject` instances.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            self.collection.append(other)
        elif isinstance(other, (list, tuple)):
            for obj in other:
                if not isinstance(obj, groupobject):
                    raise TypeError(&#34;All items to add must be `groupobject` instances.&#34;)
            self.collection.extend(other)
        else:
            raise TypeError(&#34;In-place addition only supported with `groupobject` instances or lists/tuples of `groupobject` instances.&#34;)
        return self

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a neatly formatted string representation of the groupcollection.

        The representation includes a table of `beadtype`, `group` (max width 50 characters), and `mass`.
        It also provides a summary of the total number of `groupobject` instances.

        ### Returns:
            str: Formatted string representation of the collection.
        &#34;&#34;&#34;
        headers = [&#34;Beadtype&#34;, &#39;Name&#39;, &#34;Group&#34;, &#34;Mass&#34;]
        col_max_widths = [10, 20, 30, 10]
        # Prepare rows
        rows = []
        for obj in self.collection:
            beadtype_str = str(obj.beadtype)
            group_str = &#34;, &#34;.join(obj.group)
            mass_str = f&#34;{obj.mass}&#34; if obj.mass is not None else &#34;None&#34;
            rows.append([beadtype_str, obj.name, group_str, mass_str])
        # Generate the table
        table = format_table(headers, rows, col_max_widths)
        # Add summary
        summary = f&#34;Total groupobjects: {len(self)}&#34;
        return f&#34;{table}\n{summary}&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the same representation as `__repr__`.

        ### Returns:
            str: Formatted string representation of the collection.
        &#34;&#34;&#34;
        return f&#34;groupcollection including {len(self)} groupobjects&#34;

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of `groupobject` instances in the collection.

        ### Returns:
            int: Number of objects in the collection.
        &#34;&#34;&#34;
        return len(self.collection)

    def __getitem__(self, index: int) -&gt; groupobject:
        &#34;&#34;&#34;
        Retrieves a `groupobject` by its index.

        ### Parameters:
            index (int): The index of the `groupobject` to retrieve.

        ### Returns:
            groupobject: The `groupobject` at the specified index.

        ### Raises:
            IndexError: If the index is out of range.
        &#34;&#34;&#34;
        return self.collection[index]

    def __iter__(self):
        &#34;&#34;&#34;
        Returns an iterator over the `groupobject` instances in the collection.

        ### Returns:
            Iterator[groupobject]: An iterator over the collection.
        &#34;&#34;&#34;
        return iter(self.collection)

    def append(self, obj: groupobject):
        &#34;&#34;&#34;
        Appends a `groupobject` to the collection.

        ### Parameters:
            obj (groupobject): The object to append.

        ### Raises:
            TypeError: If `obj` is not a `groupobject` instance.
        &#34;&#34;&#34;
        if not isinstance(obj, groupobject):
            raise TypeError(&#34;Only `groupobject` instances can be appended.&#34;)
        self.collection.append(obj)

    def extend(self, objs: Union[List[groupobject], Tuple[groupobject, ...]]):
        &#34;&#34;&#34;
        Extends the collection with a list or tuple of `groupobject` instances.

        ### Parameters:
            objs (list or tuple of groupobject): The objects to extend the collection with.

        ### Raises:
            TypeError: If `objs` is not a list or tuple.
            TypeError: If any item in `objs` is not a `groupobject` instance.
        &#34;&#34;&#34;
        if not isinstance(objs, (list, tuple)):
            raise TypeError(&#34;`objs` must be a list or tuple of `groupobject` instances.&#34;)
        for obj in objs:
            if not isinstance(obj, groupobject):
                raise TypeError(&#34;All items to extend must be `groupobject` instances.&#34;)
        self.collection.extend(objs)

    def remove(self, obj: groupobject):
        &#34;&#34;&#34;
        Removes a `groupobject` from the collection.

        ### Parameters:
            obj (groupobject): The object to remove.

        ### Raises:
            ValueError: If `obj` is not found in the collection.
        &#34;&#34;&#34;
        self.collection.remove(obj)

    def clear(self):
        &#34;&#34;&#34;
        Clears all `groupobject` instances from the collection.
        &#34;&#34;&#34;
        self.collection.clear()


    def mass(self, name: Optional[str] = None, default_mass: Optional[Union[str, int, float]] = &#34;${mass}&#34;, verbose: Optional[bool] = True) -&gt; &#39;dscript&#39;:
        &#34;&#34;&#34;
        Generates LAMMPS mass commands for each unique beadtype in the collection.

        The method iterates through all `groupobject` instances in the collection,
        collects unique beadtypes, and ensures that each beadtype has a consistent mass.
        If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

        ### Parameters:
            name (str, optional): The name to assign to the resulting `dscript` object. Defaults to a generated name.
            default_mass (str, optional): The default mass value to assign when a beadtype&#39;s mass is `None`.
                                          Defaults to `&#34;${mass}&#34;`.
            verbose (bool, optional): If `True`, includes a comment header in the output. Defaults to `True`.

        ### Returns:
            dscript: A `dscript` object containing the mass commands for each beadtype, formatted as follows:
                     ```
                     mass 1 1.0
                     mass 2 1.0
                     mass 3 2.5
                     ```
                     The `collection` attribute of the `dscript` object holds the formatted mass commands as a single string.

        ### Raises:
            ValueError: If a beadtype has inconsistent mass values across different `groupobject` instances.

        ### Example:
            ```python
            # Create groupobject instances
            o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
            o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
            o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)

            # Initialize a groupcollection with the groupobjects
            G = groupcollection([o1, o2, o3])

            # Generate mass commands
            M = G.mass()
            print(M.do())
            ```
            **Output:**
            ```
            mass 1 1.0
            mass 2 ${mass}
            mass 3 2.5
            ```
        &#34;&#34;&#34;
        beadtype_mass = {}
        for obj in self.collection:
            bt = obj.beadtype
            mass = obj.mass if obj.mass is not None else &#34;${mass}&#34;
            if bt in beadtype_mass:
                if beadtype_mass[bt] != mass:
                    raise ValueError(
                        f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                    )
            else:
                beadtype_mass[bt] = mass
        # Sort beadtypes for consistent ordering
        sorted_beadtypes = sorted(beadtype_mass.keys())
        # Generate mass commands
        lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
        # return a dscript object
        idD = f&#34;&lt;dscript:group:{self.name}:mass&gt;&#34;
        description = f&#34;{idD} definitions for {len(self)} beads&#34;
        if verbose:
            lines.insert(0, &#34;# &#34;+description)
        D = dscript(name=idD if name is None else name, description=f&#34;{idD} with {len(self)} beads&#34;)
        D.collection = &#34;\n&#34;.join(lines)
        D.DEFINITIONS.mass = default_mass
        return D




# %% Main classes Operation, group

# Class for binary and unary operators
class Operation:
    &#34;&#34;&#34;
    Represents a LAMMPS group operation, allowing algebraic manipulation and code generation.

    ### Overview

    The `Operation` class models a group operation in LAMMPS (Large-scale Atomic/Molecular Massively
    Parallel Simulator), encapsulating an operator, its operands, a name, and the corresponding LAMMPS code.
    It supports algebraic operations between groups (union, intersection, subtraction) using the
    overloaded operators &#39;+&#39;, &#39;-&#39;, and &#39;*&#39;, enabling users to build complex group expressions
    programmatically.

    ### Attributes

    - **operator (str)**: The operator applied to the operands. It can be:
        - A finalized LAMMPS operator: `&#39;variable&#39;`, `&#39;byvariable&#39;`, `&#39;byregion&#39;`, `&#39;bytype&#39;`, `&#39;byid&#39;`, `&#39;create&#39;`, `&#39;clear&#39;`,
          `&#39;union&#39;`, `&#39;intersect&#39;`, `&#39;subtract&#39;`.
        - An algebraic operator: `&#39;+&#39;`, `&#39;-&#39;`, `&#39;*&#39;`.
        - An empty string or `None` for operations without an explicit operator.

    - **operands (list)**: A list of operands for the operation. Operands can be:
        - Instances of `Operation`, representing nested operations.
        - Strings representing group names or other identifiers.
        - Integers or lists (e.g., atom types or IDs).

    - **name (str)**: The name of the operation, which can be manually set or auto-generated.
        - If not provided, a unique hash-based name is generated using the `generate_hashname` method.

    - **code (str)**: The LAMMPS code that this operation represents.
        - This is generated when the operation is finalized and corresponds to the actual command(s)
          that would be included in a LAMMPS input script.

    - **criteria (dict, optional)**: Criteria used to define the operation.
        - Useful for operations like `bytype`, `byregion`, `byid`, etc., where the criteria specify
          the selection parameters.

    ### Methods

    - `__init__(self, operator, operands, name=&#34;&#34;, code=&#34;&#34;, criteria=None)`:
        Initializes a new `Operation` instance with the given parameters.
        - **operator** (str): The operator applied to the operands.
        - **operands** (list or single operand): The operands for the operation.
        - **name** (str, optional): The name of the operation.
        - **code** (str, optional): The LAMMPS code representing the operation.
        - **criteria** (dict, optional): Criteria used to define the operation.

    - `append(self, operand)`:
        Appends a single operand to the operands list.

    - `extend(self, operands)`:
        Extends the operands list with multiple operands.

    - `is_unary(self)`:
        Checks if the `Operation` instance has exactly one operand.

    - `is_empty(self)`:
        Checks if the `Operation` instance has no operands.

    - `generateID(self)`:
        Generates an ID for the instance based on its operands or name.
        Used internally for generating unique names.

    - `generate_hashname(self, prefix=&#34;grp&#34;, ID=None)`:
        Generates a hash-based name for the instance.
        - **prefix** (str): A string prefix for the generated name.
        - **ID** (str, optional): An optional ID to include in the hash. If `None`, it is generated from operands.

    - `get_proper_operand(self)`:
        Returns the appropriate operand representation depending on whether the operation is finalized.

    - `_operate(self, other, operator)`:
        Combines the operation with another `Operation` instance using the specified operator.
        - **other** (`Operation`): The other operation to combine with.
        - **operator** (str): The operator to apply (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;).

    - `isfinalized(self)`:
        Checks if the operation has been finalized.
        - An operation is considered finalized if its operator is not one of the algebraic operators &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.

    - `__add__(self, other)`:
        Overloads the &#39;+&#39; operator to support union of two `Operation` instances.

    - `__sub__(self, other)`:
        Overloads the &#39;-&#39; operator to support subtraction between two `Operation` instances.

    - `__mul__(self, other)`:
        Overloads the &#39;*&#39; operator to support intersection between two `Operation` instances.

    - `__repr__(self)`:
        Returns a detailed string representation of the operation, useful for debugging.

    - `__str__(self)`:
        Returns a concise string representation of the operation.

    - `script(self)`:
        Generates the LAMMPS code for this operation using `dscript` and `script` classes.
        - Returns a `script` object containing the LAMMPS code.

    ### Operator Overloading

    The `Operation` class overloads the following operators to enable algebraic manipulation:

    - **Addition (`+`)**:
        - Combines two operations using union.
        - Example: `op3 = op1 + op2`

    - **Subtraction (`-`)**:
        - Subtracts one operation from another.
        - Example: `op3 = op1 - op2`

    - **Multiplication (`*`)**:
        - Intersects two operations.
        - Example: `op3 = op1 * op2`

    ### Usage Example

    ```python
    # Create basic operations
    op1 = Operation(&#39;bytype&#39;, [1], name=&#39;group1&#39;)
    op2 = Operation(&#39;bytype&#39;, [2], name=&#39;group2&#39;)

    # Combine operations using algebraic operators
    combined_op = op1 + op2  # Union of group1 and group2

    # Initialize group manager
    G = group()
    G.add_operation(op1)
    G.add_operation(op2)

    # Evaluate the combined operation and store the result
    G.evaluate(&#39;combined_group&#39;, combined_op)

    # Access the generated LAMMPS code
    print(G.code())
    # Output:
    # group group1 type 1
    # group group2 type 2
    # group combined_group union group1 group2
    ```

    ### Notes

    - **Lazy Evaluation**:
        - Operations are combined and stored symbolically until they are evaluated.
        - The actual LAMMPS code is generated when the operation is finalized (e.g., via the `evaluate` method in the `group` class).

    - **Name Generation**:
        - If an operation&#39;s name is not provided, it is auto-generated using a hash of its operator and operands.
        - This ensures uniqueness and avoids naming conflicts.

    - **Criteria Attribute**:
        - The `criteria` attribute allows storing the parameters used to define operations.
        - Useful for debugging, documentation, or reconstructing operations.

    - **Finalization**:
        - An operation is finalized when it represents an actual LAMMPS command and has generated code.
        - Finalized operations are not further combined; instead, their names are used in subsequent operations.

    - **Integration with `dscript` and `script`**:
        - The `script` method generates the LAMMPS code for the operation using `dscript` and `script` classes.
        - Facilitates integration with script management tools and advanced scripting workflows.

    - **Error Handling**:
        - Methods include error checks to ensure operands are valid and operations are correctly formed.
        - Raises informative exceptions for invalid operations or unsupported types.

    ### Integration with Group Class

    The `Operation` class is designed to work closely with the `group` class, which manages a collection of operations and handles evaluation and code generation.

    - **Adding Operations**:
        - Use `group.add_operation(operation)` to add an `Operation` instance to a `group`.
    - **Evaluating Operations**:
        - Use `group.evaluate(group_name, operation)` to finalize an operation and generate LAMMPS code.
    - **Accessing Operations**:
        - Operations can be accessed via the `group` instance using indexing, attribute access, or methods.

    ### Additional Information

    - **String Representations**:
        - `__str__`: Provides a concise representation, useful for quick inspection.
        - `__repr__`: Provides a detailed representation, useful for debugging.

    - **Example of `__str__` Output**:
        - For an operation representing `group1 + group2`:
          ```python
          print(str(combined_op))
          # Output: &lt;combined_group=[group1+group2]&gt;
          ```

    - **Example of `__repr__` Output**:
        ```python
        print(repr(combined_op))
        # Output:
        # Operation Details:
        #   - Name: combined_group
        #   - Operator: +
        #   - Operands: group1, group2
        #   - LAMMPS Code:
        ```

    ### Examples

    **Defining Operations Based on Atom Types**

    ```python
    op1 = Operation(&#39;bytype&#39;, [1], name=&#39;type1&#39;)
    op2 = Operation(&#39;bytype&#39;, [2], name=&#39;type2&#39;)
    G.add_operation(op1)
    G.add_operation(op2)
    ```

    **Combining and Evaluating Operations**

    ```python
    combined_op = op1 + op2  # Union of &#39;type1&#39; and &#39;type2&#39;
    G.evaluate(&#39;all_types&#39;, combined_op)
    ```

    **Accessing Generated Code**

    ```python
    print(G.code())
    # Output:
    # group type1 type 1
    # group type2 type 2
    # group all_types union type1 type2
    ```

    **Using Criteria Attribute**

    ```python
    # Access criteria used to define an operation
    print(op1.criteria)
    # Output:
    # {&#39;type&#39;: [1]}
    ```

    ### Important Notes

    - **Algebraic Operators vs. Finalized Operators**:
        - Algebraic operators (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;) are used for symbolic manipulation.
        - Finalized operators represent actual LAMMPS commands.

    - **Operator Precedence**:
        - When combining operations, consider the order of operations.
        - Use parentheses to ensure the desired evaluation order.

    - **Integration with Scripting Tools**:
        - The `script` method allows operations to be integrated into larger scripting workflows.
        - Supports advanced features like variable substitution and conditional execution.

    ### Conclusion

    The `Operation` class provides a powerful and flexible way to model and manipulate group operations in LAMMPS simulations. By supporting algebraic operations and integrating with script management tools, it enables users to build complex group definitions programmatically, enhancing productivity and reducing errors in simulation setup.

    &#34;&#34;&#34;

    def __init__(self, operator, operands, name=&#34;&#34;, code=&#34;&#34;, criteria=None):
        &#34;&#34;&#34;Initializes a new Operation instance with given parameters.&#34;&#34;&#34;
        self.operator = operator
        self.operands = operands if isinstance(operands, list) else [operands]
        if not name:
            self.name = self.generate_hashname()
        else:
            self.name = name
        self.code = code
        self.criteria = criteria  # Store criteria for this operation

    def append(self, operand):
        &#34;&#34;&#34;Appends a single operand to the operands list of the Operation instance.&#34;&#34;&#34;
        self.operands.append(operand)

    def extend(self, operands):
        &#34;&#34;&#34;Extends the operands list of the Operation instance with multiple operands.&#34;&#34;&#34;
        self.operands.extend(operands)

    def is_unary(self):
        &#34;&#34;&#34;Checks if the Operation instance has exactly one operand.&#34;&#34;&#34;
        return len(self.operands) == 1

    def is_empty(self):
        &#34;&#34;&#34;Checks if the Operation instance has no operands.&#34;&#34;&#34;
        return len(self.operands) == 0

    def generateID(self):
        &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
        # if self.operands:
        #     return &#34;&#34;.join([str(op) for op in self.operands])
        # else:
        #     return self.name
        operand_ids = &#39;&#39;.join(op.name if isinstance(op, Operation) else str(op) for op in self.operands)
        return operand_ids

    def generate_hashname(self,prefix=&#34;grp&#34;,ID=None):
        &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
        # if ID is None: ID = self.generateID()
        # s = self.operator+ID
        # return prefix+hashlib.sha256(s.encode()).hexdigest()[:6]
        if ID is None:
            ID = self.generateID()
        s = self.operator + ID
        return prefix + hashlib.sha256(s.encode()).hexdigest()[:6]

    def __repr__(self):
        &#34;&#34;&#34; detailed representation &#34;&#34;&#34;
        operand_str = &#39;, &#39;.join(str(op) for op in self.operands)
        return (
            f&#34;Operation Details:\n&#34;
            f&#34;  - Name: {self.name}\n&#34;
            f&#34;  - Operator: {self.operator}\n&#34;
            f&#34;  - Operands: {operand_str}\n&#34;
            f&#34;  - LAMMPS Code: {self.code}&#34;
        )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        operands = [str(op) for op in self.operands]
        operand_str = &#39;, &#39;.join(operands)
        if self.is_empty():
            return f&#34;&lt;{self.operator} {self.name}&gt;&#34;

        elif self.is_unary():
            return f&#34;&lt;{self.name}={self.operator}({operand_str})&gt;&#34;
        else:  # Polynary
            operator_symbol_mapping = {
                &#39;union&#39;: &#39;+&#39;,
                &#39;intersect&#39;: &#39;*&#39;,
                &#39;subtract&#39;: &#39;-&#39;
            }
            operator_symbol = operator_symbol_mapping.get(self.operator, self.operator)
            formatted_operands = operator_symbol.join(operands)
            return f&#34;&lt;{self.name}=[{formatted_operands}]&gt;&#34;

    def isfinalized(self):
        &#34;&#34;&#34;
        Checks whether the Operation instance is finalized.
        Returns:
        - bool: True if the Operation is finalized, otherwise False.
        Functionality:
        - An Operation is considered finalized if its operator is not
         one of the algebraic operators &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.
        &#34;&#34;&#34;
        return self.operator not in (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;)

    def __add__(self, other):
        &#34;&#34;&#34; overload + as union &#34;&#34;&#34;
        return self._operate(other,&#39;+&#39;)

    def __sub__(self, other):
        &#34;&#34;&#34; overload - as subtract &#34;&#34;&#34;
        return self._operate(other,&#39;-&#39;)

    def __mul__(self, other):
        &#34;&#34;&#34; overload * as intersect &#34;&#34;&#34;
        return self._operate(other,&#39;*&#39;)

    def get_proper_operand(self):
        # &#34;&#34;&#34;
        # Returns the proper operand depending on whether the operation is finalized.
        # &#34;&#34;&#34;
        # return span(self.operands) if not self.isfinalized() else self.name
        &#34;&#34;&#34;
        Returns the proper operand depending on whether the operation is finalized.
        &#34;&#34;&#34;
        if self.isfinalized():
            return self.name
        else:
            # Collect operand names
            operand_names = [
                op.name if isinstance(op, Operation) else str(op)
                for op in self.operands
            ]
            return span(operand_names)

    def _operate(self, other, operator):
        &#34;&#34;&#34;
        Implements algebraic operations between self and other Operation instances.

        Parameters:
        - other (Operation): The other Operation instance to be operated with.
        - operator (str): The operation to be performed. Supported values are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.

        Returns:
        - Operation: A new Operation instance reflecting the result of the operation.
        &#34;&#34;&#34;
        # Ensure other is also an instance of Operation
        if not isinstance(other, Operation):
            raise TypeError(f&#34;Unsupported type: {type(other)}&#34;)

        # Map operator to prefix
        prefix_map = {&#39;+&#39;: &#39;add&#39;, &#39;-&#39;: &#39;sub&#39;, &#39;*&#39;: &#39;mul&#39;}
        prefix = prefix_map.get(operator, &#39;op&#39;)

        # Prepare operands list
        operands = []

        # Handle self
        if self.operator == operator and not self.isfinalized():
            operands.extend(self.operands)
        else:
            operands.append(self)

        # Handle other
        if other.operator == operator and not other.isfinalized():
            operands.extend(other.operands)
        else:
            operands.append(other)

        # Generate a new name
        name = self.generate_hashname(prefix=prefix, ID=self.generateID() + other.generateID())

        # Create a new Operation
        new_op = Operation(operator, operands, name=name)
        return new_op

    def script(self):
        &#34;&#34;&#34;
        Generate the LAMMPS code using the dscript and script classes.

        Returns:
        - script onject: The LAMMPS code generated by this operation.
        &#34;&#34;&#34;
        # Create a dscript object to store the operation code
        dscript_obj = dscript()
        # Use a dummy key for the dscript template
        dscript_obj[&#34;dummy&#34;] = self.code
        # Convert the dscript object to a script object
        script_obj = dscript_obj.script()
        return script_obj




class group:
    &#34;&#34;&#34;
    A class for managing LAMMPS group operations and generating LAMMPS scripts.

    ### Overview

    The `group` class provides an object-oriented interface to define and manage
    groups of atoms in LAMMPS simulations. Groups in LAMMPS are collections of
    atoms that can be manipulated together, allowing users to apply fixes,
    compute properties, or perform operations on specific subsets of atoms.

    This class allows you to create, combine, and manipulate groups using
    algebraic operations (union, intersection, subtraction), and to generate
    the corresponding LAMMPS commands. It also provides methods to output the
    group commands as scripts, which can be integrated into LAMMPS input files.

    ### Key Features

    - **Create and Manage Groups**: Define new groups based on atom types,
      regions, IDs, or variables.
    - **Flexible Group Creation**: Create multiple groups at once and define groups
      using concise criteria through the `add_group_criteria` method.
    - **Algebraic Operations**: Combine groups using union (`+`), intersection (`*`),
      and subtraction (`-`) operations.
    - **Subindexing with Callable Syntax**: Retrieve multiple group operations
      by calling the `group` instance with names or indices.
    - **Script Generation**: Generate LAMMPS script lines for group definitions,
      which can be output as scripts or pipelines.
    - **Dynamic Evaluation**: Evaluate complex group expressions and store the
      resulting operations.
    - **Integration with Scripting Tools**: Convert group operations into
      `dscript` or `pipescript` objects for advanced script management.

    ### LAMMPS Context

    In LAMMPS (Large-scale Atomic/Molecular Massively Parallel Simulator),
    groups are fundamental for specifying subsets of atoms for applying
    operations like forces, fixes, and computes. The `group` command in LAMMPS
    allows users to define groups based on various criteria such as atom IDs,
    types, regions, and variables.

    This `group` class abstracts the complexity of managing group definitions
    and operations, providing a high-level interface to define and manipulate
    groups programmatically.


    ### Usage Examples

    **Creating Multiple Groups at Once**

    ```python
    # Create groups &#39;o1&#39;, &#39;o2&#39;, &#39;o3&#39;, &#39;o4&#39; upon instantiation
    G = group(group_names=[&#39;o1&#39;, &#39;o2&#39;, &#39;o3&#39;, &#39;o4&#39;])
    ```

    **Defining Groups Based on Criteria**

    ```python
    G = group()
    G.add_group_criteria(&#39;lower&#39;, type=[1])
    G.add_group_criteria(&#39;central&#39;, region=&#39;central_cyl&#39;)
    G.add_group_criteria(&#39;new_group&#39;, create=True)
    G.add_group_criteria(&#39;upper&#39;, clear=True)
    G.add_group_criteria(&#39;subtract_group&#39;, subtract=[&#39;group1&#39;, &#39;group2&#39;])
    ```

    **Defining a Group Based on a Variable**

    ```python
    G = group()
    G.variable(&#39;myVar&#39;, &#39;x &gt; 5&#39;)          # Assign a variable
    G.byvariable(&#39;myGroup&#39;, &#39;myVar&#39;)      # Define group based on the variable
    ```

    **Using `add_group_criteria` with Variable**

    ```python
    G.add_group_criteria(&#39;myGroup&#39;, variable={&#39;name&#39;: &#39;myVar&#39;, &#39;expression&#39;: &#39;x &gt; 5&#39;})
    ```

    **Defining Groups Using a Dictionary**

    ```python
    group_definitions = {
        &#39;group1&#39;: {&#39;type&#39;: [1, 2]},
        &#39;group2&#39;: {&#39;region&#39;: &#39;my_region&#39;},
        &#39;group3&#39;: {&#39;variable&#39;: {&#39;name&#39;: &#39;var1&#39;, &#39;expression&#39;: &#39;x &gt; 5&#39;}},
        &#39;group4&#39;: {&#39;union&#39;: [&#39;group1&#39;, &#39;group2&#39;]},
    }
    G.add_group_criteria(group_definitions)
    ```

    **Creating a Group from a Collection of `groupobject` Instances**

    ```python
    # Import the classes
    # from groupobject import groupobject
    # from group import group

    # Create groupobject instances
    o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
    o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
    o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)

    # Create a group instance with the collection
    G = group(name=&#34;mycollection&#34;, collection=[o1, o2, o3])
    # or
    G = group(name=None, collection=[o1, o2, o3])  # Name will be generated as &#34;1+2+3&#34;

    # Generate the LAMMPS script
    script_content = G.code()
    print(script_content)
    ```

    **Expected Output:**
    ```
    group all type 1 2 3
    group A type 1
    group B type 2
    group C type 2 3
    ```

    **Accessing Groups and Performing Operations**

    ```python
    # Access groups via attribute-style or item-style access
    op1 = G.group1
    op2 = G[&#39;group2&#39;]

    # Combine groups using algebraic operations
    complex_op = op1 + op2 - G.group3

    # Evaluate the operation and store the result
    G.evaluate(&#39;combined_group&#39;, complex_op)
    ```


    **Subindexing with Callable Syntax**

    ```python
    # Retrieve multiple operations by names or indices
    subG = G(&#39;group1&#39;, 2, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, third operation, and &#39;group3&#39;

    # Display the names of operations in subG
    operation_names = [op.name for op in subG._operations]
    print(operation_names)  # Output: [&#39;group1&#39;, &#39;group3&#39;, &#39;group3&#39;]

    # Generate the LAMMPS script for the subgroup
    script_content = subG.code()
    print(script_content)
    ```

    **Generating LAMMPS Script**

    ```python
    script_content = G.code()
    print(script_content)
    ```

    ### Class Methods

    #### Initialization and Setup

    - `__init__(self, name=None, groups=None, group_names=None, printflag=False, verbose=True)`: Initializes a new `group` instance.
      - `name` (str): Optional name for the group instance.
      - `groups` (dict): Dictionary of group definitions to create upon initialization.
      - `group_names` (list): List of group names to create empty groups upon initialization.
      - `collection` (list or tuple of groupobject, optional): Collection of groupobject instances.

      - `printflag` (bool): If True, enables printing of script generation.
      - `verbose` (bool): If True, enables verbose output.

    - `create_groups(self, *group_names)`: Creates multiple new groups with the given names.

    - `add_group_criteria(self, *args, **kwargs)`: Adds group(s) based on criteria.
      - Supports two usages:
        - `add_group_criteria(group_name, **criteria)`: Adds a single group.
        - `add_group_criteria(group_definitions)`: Adds multiple groups from a dictionary.

    #### Group Creation Methods

    - `create(self, group_name)`: Creates a new empty group with the given name.
    - `bytype(self, group_name, type_values)`: Defines a group based on atom types.
    - `byid(self, group_name, id_values)`: Defines a group based on atom IDs.
    - `byregion(self, group_name, region_name)`: Defines a group based on a region.
    - `variable(self, variable_name, expression, style=&#34;atom&#34;)`: Assigns an expression to a LAMMPS variable.
    - `byvariable(self, group_name, variable_name)`: Defines a group based on a variable.
    - `clear(self, group_name)`: Clears an existing group.

    #### Algebraic Operations

    - `union(self, group_name, *groups)`: Performs a union of the specified groups.
    - `intersect(self, group_name, *groups)`: Performs an intersection of the specified groups.
    - `subtract(self, group_name, *groups)`: Subtracts groups from the first group.
    - `evaluate(self, group_name, group_op)`: Evaluates a group operation and stores the result.

    #### Access and Manipulation

    - `__getitem__(self, key)`: Allows accessing operations by name or index.
    - `__getattr__(self, operation_name)`: Enables attribute-style access to operations.
    - `__call__(self, *keys)`: Returns a new `group` instance containing specified operations.
      - **Parameters**:
        - `*keys` (str or int): One or more names or indices of operations to retrieve.
      - **Returns**:
        - `group`: A new `group` instance containing the specified operations.
      - **Example**:
        ```python
        subG = G(&#39;group1&#39;, 1, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, second operation, and &#39;group3&#39;
        ```
    - `list(self)`: Returns a list of all operation names.
    - `find(self, name)`: Finds the index of an operation based on its name.
    - `disp(self, name)`: Displays the content of an operation.
    - `delete(self, name)`: Deletes an operation by name.
    - `copy(self, source_name, new_name)`: Copies an existing operation to a new name.
    - `rename(self, old_name, new_name)`: Renames an existing operation.
    - `reindex(self, name, new_idx)`: Changes the index of an operation.

    #### Script Generation

    - `code(self)`: Returns the generated LAMMPS commands as a string.
    - `dscript(self, name=None)`: Generates a `dscript` object containing the group&#39;s commands.
    - `script(self, name=None)`: Generates a script object containing the group&#39;s commands.
    - `pipescript(self)`: Generates a `pipescript` object containing each group&#39;s command as a separate script in a pipeline.

    ### Operator Overloading

    - **Addition (`+`)**: Union of groups.
    - **Subtraction (`-`)**: Subtraction of groups.
    - **Multiplication (`*`)**: Intersection of groups.

    These operators are overloaded in the `Operation` class and can be used to combine group operations.

    ### Internal Functionality

    The class maintains a list `_operations`, which stores all the group operations
    defined. Each operation is an instance of the `Operation` class, which represents
    a LAMMPS group command along with its operands and operator.

    ### Subindexing with Callable Syntax

    The `group` class allows you to retrieve multiple operations by calling the
    instance with names or indices:

    - `__call__(self, *keys)`: Returns a new `group` instance containing the specified operations.
      - **Parameters**:
        - `*keys` (str or int): One or more names or indices of operations to retrieve.
      - **Returns**:
        - `group`: A new `group` instance containing the specified operations.
      - **Example**:
        ```python
        subG = G(&#39;group1&#39;, 1, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, second operation, and &#39;group3&#39;
        ```
      - **Notes**:
        - Indices are 0-based integers.
        - Duplicate operations are avoided in the new `group` instance.

    ### Integration with Scripts

    The `group` class integrates with `dscript` and `pipescript` classes to allow
    advanced script management:

    - **`dscript`**: A dynamic script management class that handles script lines
      with variable substitution and conditional execution.
    - **`pipescript`**: Manages a pipeline of scripts, allowing sequential execution
      and advanced variable space management.

    ### Important Notes

    - **Operator Overloading**: The class overloads the `+`, `-`, and `*` operators
      for the `Operation` class to perform union, subtraction, and intersection
      respectively.
    - **Flexible Group Creation**: Groups can be created upon instantiation or added later using concise methods.
    - **Variable Assignment and Group Definition**: When defining groups based on variables, variable assignment and group creation are handled separately.
    - **Subindexing with `__call__`**: The `__call__` method allows you to retrieve multiple operations and create subgroups.
    - **Error Handling**: The class includes robust error checking and provides informative error messages.
    - **Lazy Evaluation**: Group operations are stored and only evaluated when
      the `evaluate` method is called.
    - **Name Management**: The class ensures that group names are unique within
      the instance to prevent conflicts.

    ### Conclusion

    The `group` class simplifies the management of groups in LAMMPS simulations,
    allowing for clear and maintainable code when dealing with complex group
    operations. By providing high-level abstractions, operator overloading,
    subindexing capabilities, and integration with script management tools,
    it enhances productivity and reduces the potential for errors in simulation setup.
    &#34;&#34;&#34;


    def __init__(self, name=None, groups=None, group_names=None, collection=None, printflag=False, verbose=True, verbosity=None):
        &#34;&#34;&#34;
        Initializes a new instance of the group class.

        ### Parameters:
            name (str, optional): Name for the group instance. If `None` or empty and `collection` is provided,
                                  generates a name based on beadtypes (e.g., &#34;1+2+3&#34;).
            groups (dict, optional): Dictionary of group definitions to create upon initialization.
            group_names (list or tuple, optional): List of group names to create empty groups upon initialization.
            collection (list, tuple, or groupcollection, optional):
                - If a list or tuple, it should contain `groupobject` instances.
                - If a `groupcollection` object, it will extract the `groupobject` instances from it.
            printflag (bool, optional): If `True`, enables printing of script generation.
            verbose (bool, optional): If `True`, enables verbose output.

        ### Raises:
            TypeError:
                - If `groups` is not a dictionary.
                - If `group_names` is not a list or tuple.
                - If `collection` is not a list, tuple, or `groupcollection` object.
                - If any item in `collection` (when it&#39;s a list or tuple) is not a `groupobject` instance.
        &#34;&#34;&#34;
        self._in_construction = True  # Indicate that the object is under construction
        # Handle &#39;name&#39; parameter
        if not name:
            name = generate_random_name()
        self._name = name

        # Initialize other attributes
        self._operations = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = verbosity
        self._in_construction = False  # Set the flag to indicate construction is finished
        # Handle &#39;groups&#39; parameter
        if groups:
            if not isinstance(groups, dict):
                raise TypeError(&#34;Parameter &#39;groups&#39; must be a dictionary.&#34;)
            self.add_group_criteria(groups)
        # Handle &#39;group_names&#39; parameter
        if group_names:
            if not isinstance(group_names, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;group_names&#39; must be a list or tuple of group names.&#34;)
            self.create_groups(*group_names)
        # Handle &#39;collection&#39; parameter
        if collection:
            if isinstance(collection, groupcollection):
                # Extract the list of groupobject instances from the groupcollection
                collection = collection.collection
            elif not isinstance(collection, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;collection&#39; must be a list, tuple, or `groupcollection` object.&#34;)
            # If collection is a list or tuple, validate its items
            if isinstance(collection, (list, tuple)):
                for obj in collection:
                    if not isinstance(obj, groupobject):
                        raise TypeError(&#34;All items in &#39;collection&#39; must be `groupobject` instances.&#34;)
                self.generate_group_definitions_from_collection(collection)



    def create_groups(self, *group_names):
        for group_name in group_names:
            if not isinstance(group_name, str):
                raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
            self.create(group_name)


    def __str__(self):
        return f&#39;Group &#34;{self._name}&#34; with {len(self._operations)} operations\n&#39;


    def format_cell_content(self, content, max_width):
        content = str(content) if content is not None else &#39;&#39;
        if len(content) &gt; max_width:
            start = content[: (max_width - 5) // 2]
            end = content[-((max_width - 5) // 2):]
            content = f&#34;{start} ... {end}&#34;
        return content


    def __repr__(self):
        &#34;&#34;&#34;
        Returns a neatly formatted table representation of the group&#39;s operations.

        Each row represents an operation in the group, displaying its index, name,
        operator, and operands. The table adjusts column widths dynamically and
        truncates content based on maximum column widths.

        ### Returns:
            str: A formatted string representation of the group operations.
        &#34;&#34;&#34;
        # Define headers for the table
        headers = [&#34;Idx&#34;, &#34;Name&#34;, &#34;Operator&#34;, &#34;Operands&#34;]
        col_max_widths = [5, 20, 20, 40]
        align = [&#34;R&#34;, &#34;C&#34;, &#34;C&#34;, &#34;L&#34;]
        # Prepare rows by iterating over the operations
        rows = []
        for idx, op in enumerate(self._operations):
            rows.append([
                str(idx),                    # Index
                str(op.name),                # Name
                str(op.operator),            # Operator
                str(span(op.operands)),      # Operands
            ])
        # Use the helper to format the table
        table = format_table(headers, rows, col_max_widths, align)
        # Append the string representation of the group itself
        return f&#34;{table}\n\n{str(self)}&#34;


    def __len__(self):
        &#34;&#34;&#34; return the number of stored operations &#34;&#34;&#34;
        return len(self._operations)

    def list(self):
        &#34;&#34;&#34; return the list of all operations &#34;&#34;&#34;
        return [op.name for op in self._operations]


    def code(self):
        &#34;&#34;&#34;
            Joins the `code` attributes of all stored `operation` objects with &#39;\n&#39;.
        &#34;&#34;&#34;
        return &#39;\n&#39;.join([op.code for op in self._operations])

    def find(self, name):
        &#34;&#34;&#34;Returns the index of an operation based on its name.&#34;&#34;&#34;
        if &#39;_operations&#39; in self.__dict__:
            for i, op in enumerate(self._operations):
                if op.name == name:
                    return i
        return None

    def disp(self, name):
        &#34;&#34;&#34; display the content of an operation &#34;&#34;&#34;
        idx = self.find(name)
        if idx is not None:
            return self._operations[idx].__repr__()
        else:
            return &#34;Operation not found&#34;

    def clearall(self):
        &#34;&#34;&#34; clear all operations &#34;&#34;&#34;
        self._operations = []

    def delete(self, name):
        &#34;&#34;&#34;
        Deletes one or more stored operations based on their names.

        Parameters:
        -----------
        name : str, list, or tuple
            The name(s) of the operation(s) to delete. If a list or tuple is provided,
            all specified operations will be deleted.

        Usage:
        ------
        G.delete(&#39;operation_name&#39;)
        G.delete([&#39;operation1&#39;, &#39;operation2&#39;])
        G.delete((&#39;operation1&#39;, &#39;operation2&#39;))

        Raises:
        -------
        ValueError
            If any of the specified operations are not found.
        &#34;&#34;&#34;
        # Handle a single string, list, or tuple
        if isinstance(name, (list, tuple)):
            not_found = []
            for n in name:
                idx = self.find(n)
                if idx is not None:
                    del self._operations[idx]
                else:
                    not_found.append(n)
            # If any names were not found, raise an exception
            if not_found:
                raise ValueError(f&#34;Operation(s) {&#39;, &#39;.join(not_found)} not found.&#34;)
        elif isinstance(name, str):
            idx = self.find(name)
            if idx is not None:
                del self._operations[idx]
            else:
                raise ValueError(f&#34;Operation {name} not found.&#34;)
        else:
            raise TypeError(&#34;The &#39;name&#39; parameter must be a string, list, or tuple.&#34;)

    def copy(self, source_name, new_name):
        &#34;&#34;&#34;
        Copies a stored operation to a new operation with a different name.

        Parameters:
        source_name: str
            Name of the source operation to copy
        new_name: str
            Name of the new operation

        Usage:
        G.copy(&#39;source_operation&#39;, &#39;new_operation&#39;)
        &#34;&#34;&#34;
        idx = self.find(source_name)
        if idx is not None:
            copied_operation = self._operations[idx].clone()
            copied_operation.name = new_name
            self.add_operation(copied_operation)
        else:
            raise ValueError(f&#34;Operation {source_name} not found.&#34;)

    def rename(self, old_name, new_name):
        &#34;&#34;&#34;
        Rename a stored operation.

        Parameters:
        old_name: str
            Current name of the operation
        new_name: str
            New name to assign to the operation

        Usage:
        G.rename(&#39;old_operation&#39;, &#39;new_operation&#39;)
        &#34;&#34;&#34;
        idx = self.find(old_name)
        if idx is not None:
            if new_name == old_name:
                raise ValueError(&#34;The new name should be different from the previous one.&#34;)
            elif new_name in self.list():
                raise ValueError(&#34;Operation name must be unique.&#34;)
            self._operations[idx].name = new_name
        else:
            raise ValueError(f&#34;Operation &#39;{old_name}&#39; not found.&#34;)

    def reindex(self, name, new_idx):
        &#34;&#34;&#34;
        Change the index of a stored operation.

        Parameters:
        name: str
            Name of the operation to reindex
        new_idx: int
            New index for the operation

        Usage:
        G.reindex(&#39;operation_name&#39;, 2)
        &#34;&#34;&#34;
        idx = self.find(name)
        if idx is not None and 0 &lt;= new_idx &lt; len(self._operations):
            op = self._operations.pop(idx)
            self._operations.insert(new_idx, op)
        else:
            raise ValueError(f&#34;Operation &#39;{name}&#39; not found or new index {new_idx} out of range.&#34;)

    # ------------- indexing and attribute overloading

    def __getitem__(self, key):
        &#34;&#34;&#34;
            Enable shorthand for G.operations[G.find(operation_name)] using G[operation_name],
            or accessing operation by index using G[index].
        &#34;&#34;&#34;
        if isinstance(key, str):
            idx = self.find(key)
            if idx is not None:
                return self._operations[idx]
            else:
                raise KeyError(f&#34;Operation &#39;{key}&#39; not found.&#34;)
        elif isinstance(key, int):
            if -len(self._operations) &lt;= key &lt; len(self._operations):
                return self._operations[key]
            else:
                raise IndexError(&#34;Operation index out of range.&#34;)
        else:
            raise TypeError(&#34;Key must be an operation name (string) or index (integer).&#34;)


    def __getattr__(self, name):
        &#34;&#34;&#34;
        Allows accessing operations via attribute-style notation.
        If the attribute is one of the core attributes, returns it directly.
        For other attributes, searches for an operation with a matching name
        in the _operations list.

        Parameters:
        -----------
        name : str
            The name of the attribute or operation to access.

        Returns:
        --------
        The value of the attribute if it&#39;s a core attribute, or the operation
        associated with the specified name if found in _operations.

        Raises:
        -------
        AttributeError
            If the attribute or operation is not found.
        &#34;&#34;&#34;
        # Handle core attributes directly
        if name in {&#39;_name&#39;, &#39;_operations&#39;, &#39;printflag&#39;, &#39;verbose&#39;}:
            # Use object.__getattribute__ to avoid recursion
            return object.__getattribute__(self, name)
        # Search for the operation in _operations
        elif &#39;_operations&#39; in self.__dict__:
            for op in self._operations:
                if op.name == name:
                    return op
        # If not found, raise an AttributeError
        raise AttributeError(f&#34;Attribute or operation &#39;{name}&#39; not found.&#34;)


    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Allows deletion of an operation via &#39;G.operation_name = []&#39; after construction.
        During construction, attributes are set normally.
        &#34;&#34;&#34;
        if getattr(self, &#39;_in_construction&#39;, True):
            # During construction, set attributes normally
            super().__setattr__(name, value)
        else:
            # After construction
            if isinstance(value, list) and len(value) == 0:
                # Handle deletion syntax
                idx = self.find(name)
                if idx is not None:
                    del self._operations[idx]
                else:
                    raise AttributeError(f&#34;Operation &#39;{name}&#39; not found for deletion.&#34;)
            else:
                # Set attribute normally
                super().__setattr__(name, value)


    def _get_subobject(self, key):
        &#34;&#34;&#34;
        Retrieves a subobject based on the provided key.

        Parameters:
        -----------
        key : str or int
            The key used to retrieve the subobject.

        Returns:
        --------
        Operation
            The operation corresponding to the key.

        Raises:
        -------
        KeyError
            If the key is not found.
        IndexError
            If the index is out of range.
        TypeError
            If the key is not a string or integer.
        &#34;&#34;&#34;
        if isinstance(key, str):
            # If key is a string, treat it as a group name
            for operation in self._operations:
                if operation.name == key:
                    return operation
            raise KeyError(f&#34;No operation found with name &#39;{key}&#39;.&#34;)
        elif isinstance(key, int):
            # If key is an integer, treat it as an index (0-based)
            if 0 &lt;= key &lt; len(self._operations):
                return self._operations[key]
            else:
                raise IndexError(f&#34;Index {key} is out of range.&#34;)
        else:
            raise TypeError(&#34;Key must be a string or integer.&#34;)


    def __call__(self, *keys):
        &#34;&#34;&#34;
        Allows subindexing of the group object using callable syntax with multiple keys.

        Parameters:
        -----------
        *keys : str or int
            One or more keys used to retrieve subobjects or perform subindexing.

        Returns:
        --------
        group
            A new group instance containing the specified operations.

        Example:
        --------
        subG = G(&#39;a&#39;, 1, &#39;c&#39;)  # Retrieves operations &#39;a&#39;, second operation, and &#39;c&#39;
        &#34;&#34;&#34;
        selected_operations = []
        for key in keys:
            operation = self._get_subobject(key)
            selected_operations.append(operation)

        # Create a new group instance with the selected operations
        new_group = group(name=f&#34;{self._name}_subgroup&#34;, printflag=self.printflag, verbose=self.verbose)
        new_group._operations = selected_operations
        return new_group


    def operation_exists(self,operation_name):
        &#34;&#34;&#34;
            Returns true if &#34;operation_name&#34; exists
            To be used by Operation, not by end-user, which should prefer find()
        &#34;&#34;&#34;
        return any(op.name == operation_name for op in self._operations)

    def get_by_name(self,operation_name):
        &#34;&#34;&#34;
            Returns the operation matching &#34;operation_name&#34;
            Usage: group.get_by_name(&#34;operation_name&#34;)
            To be used by Operation, not by end-user, which should prefer getattr()
        &#34;&#34;&#34;
        for op in self._operations:
            if op.name == operation_name:
                return op
        raise AttributeError(f&#34;Operation with name &#39;{operation_name}&#39; not found.&#34;)

    def add_operation(self,operation):
        &#34;&#34;&#34; add an operation &#34;&#34;&#34;
        if operation.name in self.list():
            raise ValueError(f&#34;The operation &#39;{operation.name}&#39; already exists.&#34;)
        else:
            self._operations.append(operation)

    # --------- LAMMPS methods

    def variable(self, variable_name, expression, style=&#34;atom&#34;):
        &#34;&#34;&#34;
        Assigns an expression to a LAMMPS variable.

        Parameters:
        - variable_name (str): The name of the variable to be assigned.
        - expression (str): The expression to assign to the variable.
        - style (str): The type of variable (default is &#34;atom&#34;).
        &#34;&#34;&#34;
        if not isinstance(variable_name, str):
            raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)
        if not isinstance(expression, str):
            raise TypeError(f&#34;Expression must be a string, got {type(expression)}&#34;)
        if not isinstance(style, str):
            raise TypeError(f&#34;Style must be a string, got {type(style)}&#34;)

        lammps_code = f&#34;variable {variable_name} {style} \&#34;{expression}\&#34;&#34;
        op = Operation(&#34;variable&#34;, [variable_name, expression], code=lammps_code)
        self.add_operation(op)


    def byvariable(self, group_name, variable_name):
        &#34;&#34;&#34;
        Sets a group of atoms based on a variable.

        Parameters:
        - group_name: str, the name of the group.
        - variable_name: str, the name of the variable to define the group.
        &#34;&#34;&#34;
        if not isinstance(group_name, str):
            raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
        if not isinstance(variable_name, str):
            raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)

        lammps_code = f&#34;group {group_name} variable {variable_name}&#34;
        op = Operation(&#34;byvariable&#34;, [variable_name], name=group_name, code=lammps_code)
        self.add_operation(op)


    def byregion(self, group_name, region_name):
        &#34;&#34;&#34;
            set a group of atoms based on a regionID
            G.region(group_name,regionID)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} region {region_name}&#34;
        criteria = {&#34;region&#34;: region_name}
        op = Operation(&#34;byregion&#34;, [region_name], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def bytype(self,  group_name, type_values):
        &#34;&#34;&#34;
            select atoms by type and store them in group
            G.type(group_name,type_values)
        &#34;&#34;&#34;
        if not isinstance(type_values, (list, tuple)):
            type_values = [type_values]
        lammps_code = f&#34;group {group_name} type {span(type_values)}&#34;
        criteria = {&#34;type&#34;: type_values}
        op = Operation(&#34;bytype&#34;, type_values, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def byid(self, group_name, id_values):
        &#34;&#34;&#34;
            select atoms by id and store them in group
            G.id(group_name,id_values)
        &#34;&#34;&#34;
        if not isinstance(id_values, (list, tuple)):
            id_values = [id_values]
        lammps_code = f&#34;group {group_name} id {span(id_values)}&#34;
        criteria = {&#34;id&#34;: id_values}
        op = Operation(&#34;byid&#34;, id_values, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def create(self, group_name):
        &#34;&#34;&#34;
            create group
            G.create(group_name)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} clear&#34;
        criteria = {&#34;clear&#34;: True}
        op = Operation(&#34;create&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def clear(self, group_name):
        &#34;&#34;&#34;
            clear group
            G.clear(group_name)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group} clear&#34;
        criteria = {&#34;clear&#34;: True}
        op = Operation(&#34;clear&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def union(self,group_name, *groups):
        &#34;&#34;&#34;
        Union group1, group2, group3 and store the result in group_name.
        Example usage:
        group.union(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} union {span(groups)}&#34;
        criteria = {&#34;union&#34;: groups}
        op = Operation(&#34;union&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def intersect(self,group_name, *groups):
        &#34;&#34;&#34;
        Intersect group1, group2, group3 and store the result in group_name.
        Example usage:
        group.intersect(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} intersect {span(groups)}&#34;
        criteria = {&#34;intersect&#34;: groups}
        op = Operation(&#34;intersect&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def subtract(self,group_name, *groups):
        &#34;&#34;&#34;
        Subtract group2, group3 from group1 and store the result in group_name.
        Example usage:
        group.subtract(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} subtract {span(groups)}&#34;
        criteria = {&#34;subtract&#34;: groups}
        op = Operation(&#34;subtract&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def evaluate(self, group_name, group_op):
        &#34;&#34;&#34;
        Evaluates the operation and stores the result in a new group.
        Expressions could combine +, - and * like o1+o2+o3-o4+o5+o6

        Parameters:
        -----------
        groupname : str
            The name of the group that will store the result.
        group_op : Operation
            The operation to evaluate.
        &#34;&#34;&#34;
        if not isinstance(group_op, Operation):
            raise TypeError(&#34;Expected an instance of Operation.&#34;)

        if group_name in self.list():
            raise ValueError(f&#34;The operation &#39;{group_name}&#39; already exists.&#34;)

        # If the operation is already finalized, no need to evaluate
        if group_op.isfinalized():
            if group_op.name != group_name:
                # If names differ, create a copy with the new name
                self.copy(group_op.name, group_name)
            return

        # Recursively evaluate operands
        operand_names = []
        for op in group_op.operands:
            if isinstance(op, Operation):
                if op.isfinalized():
                    # Use existing finalized operation name
                    operand_names.append(op.name)
                else:
                    # Generate a unique name if the operation doesn&#39;t have one
                    if not op.name:
                        op.name = op.generate_hashname()
                    # Recursively evaluate the operand operation
                    self.evaluate(op.name, op)
                    operand_names.append(op.name)
            else:
                operand_names.append(str(op))

        # Call the appropriate method based on the operator
        if group_op.operator == &#39;+&#39;:
            self.union(group_name, *operand_names)
            group_op.operator = &#39;union&#39;
        elif group_op.operator == &#39;-&#39;:
            self.subtract(group_name, *operand_names)
            group_op.operator = &#39;subtract&#39;
        elif group_op.operator == &#39;*&#39;:
            self.intersect(group_name, *operand_names)
            group_op.operator = &#39;intersect&#39;
        else:
            raise ValueError(f&#34;Unknown operator: {group_op.operator}&#34;)

        # Update the operation
        group_op.name = group_name
        # Get the last added operation
        finalized_op = self._operations[-1]
        group_op.code = finalized_op.code
        group_op.operands = operand_names

        # Add the operation to the group&#39;s _operations if not already added
        if group_op.name not in self.list():
            self._operations.append(group_op)


    def add_group_criteria(self, *args, **kwargs):
        &#34;&#34;&#34;
        Adds group(s) using existing methods based on key-value pairs.

        Supports two usages:
        1. add_group_criteria(group_name, **criteria)
        2. add_group_criteria(group_definitions)

        Parameters:
        - group_name (str): The name of the group.
        - **criteria: Criteria for group creation.

        OR

        - group_definitions (dict): A dictionary where keys are group names and values are criteria dictionaries.

        Raises:
        - TypeError: If arguments are invalid.

        Usage:
        - G.add_group_criteria(&#39;group_name&#39;, type=[1,2])
        - G.add_group_criteria({&#39;group1&#39;: {&#39;type&#39;: [1]}, &#39;group2&#39;: {&#39;region&#39;: &#39;regionID&#39;}})
        &#34;&#34;&#34;
        if len(args) == 1 and isinstance(args[0], dict):
            # Called with group_definitions dict
            group_definitions = args[0]
            for group_name, criteria in group_definitions.items():
                self.add_group_criteria_single(group_name, **criteria)
        elif len(args) == 1 and isinstance(args[0], str):
            # Called with group_name and criteria
            group_name = args[0]
            if not kwargs:
                raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)
            self.add_group_criteria_single(group_name, **kwargs)
        else:
            raise TypeError(&#34;Invalid arguments. Use add_group_criteria(group_name, **criteria) or add_group_criteria(group_definitions).&#34;)


    def add_group_criteria_single(self, group_name, **criteria):
        &#34;&#34;&#34;
        Adds a single group based on criteria.

        Parameters:
        - group_name (str): The name of the group.
        - **criteria: Criteria for group creation.

        Raises:
        - TypeError: If group_name is not a string.
        - ValueError: If no valid criteria are provided or if criteria are invalid.


        Example (advanced):
            G = group()
            group_definitions = {
                &#39;myGroup&#39;: {
                    &#39;variable&#39;: {
                        &#39;name&#39;: &#39;myVar&#39;,
                        &#39;expression&#39;: &#39;x &gt; 5&#39;,
                        &#39;style&#39;: &#39;atom&#39;
                    }
                }
            }
            G.add_group_criteria(group_definitions)
            print(G.code())

        Expected output
            variable myVar atom &#34;x &gt; 5&#34;
            group myGroup variable myVar
        &#34;&#34;&#34;
        if not isinstance(group_name, str):
            raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)

        if not criteria:
            raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)

        if &#34;type&#34; in criteria:
            type_values = criteria[&#34;type&#34;]
            if not isinstance(type_values, (list, tuple, int)):
                raise TypeError(&#34;Type values must be an integer or a list/tuple of integers.&#34;)
            self.bytype(group_name, type_values)

        elif &#34;region&#34; in criteria:
            region_name = criteria[&#34;region&#34;]
            if not isinstance(region_name, str):
                raise TypeError(&#34;Region name must be a string.&#34;)
            self.byregion(group_name, region_name)

        elif &#34;id&#34; in criteria:
            id_values = criteria[&#34;id&#34;]
            if not isinstance(id_values, (list, tuple, int)):
                raise TypeError(&#34;ID values must be an integer or a list/tuple of integers.&#34;)
            self.byid(group_name, id_values)

        elif &#34;variable&#34; in criteria:
            var_info = criteria[&#34;variable&#34;]
            if not isinstance(var_info, dict):
                raise TypeError(&#34;Variable criteria must be a dictionary.&#34;)
            required_keys = {&#39;name&#39;, &#39;expression&#39;}
            if not required_keys.issubset(var_info.keys()):
                missing = required_keys - var_info.keys()
                raise ValueError(f&#34;Variable criteria missing keys: {missing}&#34;)
            var_name = var_info[&#39;name&#39;]
            expression = var_info[&#39;expression&#39;]
            style = var_info.get(&#39;style&#39;, &#39;atom&#39;)

            # First, assign the variable
            self.variable(var_name, expression, style)

            # Then, create the group based on the variable
            self.byvariable(group_name, var_name)

        elif &#34;union&#34; in criteria:
            groups = criteria[&#34;union&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Union groups must be a list or tuple of group names.&#34;)
            self.union(group_name, *groups)

        elif &#34;intersect&#34; in criteria:
            groups = criteria[&#34;intersect&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Intersect groups must be a list or tuple of group names.&#34;)
            self.intersect(group_name, *groups)

        elif &#34;subtract&#34; in criteria:
            groups = criteria[&#34;subtract&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Subtract groups must be a list or tuple of group names.&#34;)
            self.subtract(group_name, *groups)

        elif &#34;create&#34; in criteria and criteria[&#34;create&#34;]:
            self.create(group_name)

        elif &#34;clear&#34; in criteria and criteria[&#34;clear&#34;]:
            self.clear(group_name)

        else:
            raise ValueError(f&#34;No valid criterion provided for group &#39;{group_name}&#39;.&#34;)




    def get_group_criteria(self, group_name):
        &#34;&#34;&#34;
        Retrieve the criteria that define a group. Handles group_name as a string or number.

        Parameters:
        - group_name: str or int, the name or number of the group.

        Returns:
        - dict or str: The criteria used to define the group, or a message if defined by multiple criteria.

        Raises:
        - ValueError: If the group does not exist.
        &#34;&#34;&#34;
        # Check if group_name exists in _operations
        if group_name not in self._operations:
            raise ValueError(f&#34;Group &#39;{group_name}&#39; does not exist.&#34;)

        # Retrieve all operations related to the group directly from _operations
        operations = self._operations[group_name]

        if not operations:
            raise ValueError(f&#34;No operations found for group &#39;{group_name}&#39;.&#34;)

        criteria = {}
        for op in operations:
            if op.criteria:
                criteria.update(op.criteria)

        # If multiple criteria, return a message
        if len(criteria) &gt; 1:
            return f&#34;Group &#39;{group_name}&#39; is defined by multiple criteria: {criteria}&#34;

        return criteria


    def generate_group_definitions_from_collection(self,collection):
        &#34;&#34;&#34;
        Generates group definitions based on the collection of groupobject instances.

        This method populates the groups based on beadtypes and associated group names.
        &#34;&#34;&#34;
        group_defs = {}
        for obj in collection:
            for group_name in obj.group:
                if group_name not in group_defs:
                    group_defs[group_name] = {&#39;type&#39;: []}
                if obj.beadtype not in group_defs[group_name][&#39;type&#39;]:
                    group_defs[group_name][&#39;type&#39;].append(obj.beadtype)
        # Now, add these group definitions
        self.add_group_criteria(group_defs)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a dscript object containing the group&#39;s LAMMPS commands.

        Parameters:
        - name (str): Optional name for the script object.
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - dscript: A dscript object containing the group&#39;s code.
        &#34;&#34;&#34;
        if name is None:
            name = self._name
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        # Create a new dscript object
        dscript_obj = dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity)
        # Add each line of the group&#39;s code to the script object
        for idx, op in enumerate(self._operations):
            # Use the index as the key for the script line
           dscript_obj[idx] = op.code
        return dscript_obj


    def script(self, name=None, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a script object containing the group&#39;s LAMMPS commands.

        Parameters:
        - name (str): Optional name for the script object.
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - script: A script object containing the group&#39;s code.
        &#34;&#34;&#34;
        if name is None:
            name = self._name
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        script_obj = self.dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity).script(printflag=printflag, verbose=verbose, verbosity=verbosity)
        return script_obj


    def pipescript(self, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a pipescript object containing the group&#39;s LAMMPS commands.

        Parameters:
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - pipescript: A pipescript object containing the group&#39;s code lines as individual scripts in the pipeline.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        # Create a list to hold script objects
        script_list = []

        # For each operation, create a script object and add it to the list
        for op in self._operations:
            # Create a dscript object with the code line
            dscript_obj = dscript(printflag=printflag, verbose=verbose, verbosity=verbosity)
            dscript_obj[&#34;dummy&#34;] = op.code

            # Convert the dscript to a script object
            script_obj = dscript_obj.script(printflag=printflag, verbose=verbose, verbosity=verbosity)

            # Add the script object to the list
            script_list.append(script_obj)

        # Use the static method &#39;join&#39; to create a pipescript from the list
        if script_list:
            pipe_obj = pipescript.join(script_list)
        else:
            pipe_obj = pipescript()

        return pipe_obj

    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, copy.deepcopy(v, memo))
        return copie


    def count(self,name=None, selection: Optional[List[str]] = None) -&gt; &#39;dscript&#39;:
        &#34;&#34;&#34;
        Generates DSCRIPT counters for specified groups with LAMMPS variable definitions and print commands.

        The method retrieves the list of group names using `self.list()`. If `selection` is provided, it
        filters the groups to include only those specified. It then creates a variable for each selected
        group that counts the number of atoms in that group and generates corresponding print commands.
        The commands are encapsulated within a `dscript` object for execution.

        ### Parameters:
            selection (list of str, optional):
                - List of group names to be numbered.
                - If `None`, all groups in the collection are numbered.

        ### Returns:
            dscript: A `dscript` object containing the variable definitions and print commands, formatted as follows:
                     ```
                     variable n_lower equal &#34;count(lower)&#34;
                     variable n_middle equal &#34;count(middle)&#34;
                     variable n_upper equal &#34;count(upper)&#34;

                     print &#34;Number of atoms in lower: ${n_lower}&#34;
                     print &#34;Number of atoms in middle: ${n_middle}&#34;
                     print &#34;Number of atoms in upper: ${n_upper}&#34;
                     ```
                     The `variables` attribute holds the variable definitions, and the `printvariables` attribute
                     holds the print commands, each separated by a newline.

        ### Raises:
            ValueError:
                - If any group specified in `selection` does not exist in the collection.
                - If `selection` contains duplicate group names.
            TypeError:
                - If `selection` is not a list of strings.

        ### Example:
            ```python
            # Create groupobject instances
            g1 = groupobject(beadtype=1,group = &#39;lower&#39;)
            g2 = groupobject(beadtype=2,group = &#39;middle&#39;)
            g3 = groupobject(beadtype=3,group = &#39;upper&#39;)

            # Initialize a group with the groupobjects
            G = group(name=&#34;1+2+3&#34;,collection=(g1,g2,g3)) or collection=g1+g2+g3

            # add other groups
            G.evaluate(&#34;all&#34;, G.lower + G.middle + G.upper)
            G.evaluate(&#34;external&#34;, G.all - G.middle)

            # Generate number commands for all groups
            N = G.count(selection=[&#34;all&#34;,&#34;lower&#34;,&#34;middle&#34;,&#34;lower&#34;])
            print(N.do())
            ```

            **Output:**
            ```
            variable n_all equal &#34;count(all)&#34;
            variable n_lower equal &#34;count(lower)&#34;
            variable n_middle equal &#34;count(middle)&#34;
            variable n_upper equal &#34;count(upper)&#34;
            print &#34;Number of atoms in all: ${n_all}&#34;
            print &#34;Number of atoms in lower: ${n_lower}&#34;
            print &#34;Number of atoms in middle: ${n_middle}&#34;
            print &#34;Number of atoms in upper: ${n_upper}&#34;
            ```
        &#34;&#34;&#34;
        # Retrieve the list of all group names
        all_group_names = self.list()

        # If selection is provided, validate it
        if selection is not None:
            if not isinstance(selection, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;selection&#39; must be a list of group names.&#34;)
            if not all(isinstance(gitem, str) for gitem in selection):
                raise TypeError(&#34;All items in &#39;selection&#39; must be strings representing group names.&#34;)
            if len(selection) != len(set(selection)):
                raise ValueError(&#34;Duplicate group names found in &#39;selection&#39;. Each group should be unique.&#34;)
            # Check that all selected groups exist
            missing_groups = set(selection) - set(all_group_names)
            if missing_groups:
                raise ValueError(f&#34;The following groups are not present in the collection: {&#39;, &#39;.join(missing_groups)}&#34;)
            # Use the selected groups
            target_groups = selection
        else:
            # If no selection, target all groups
            target_groups = all_group_names

        # Initialize lists to hold variable definitions and print commands
        variable_definitions = []
        print_commands = []
        for gitem in target_groups:
            # Validate group name
            if not gitem:
                raise ValueError(&#34;Group names must be non-empty strings.&#34;)
            # Create a valid variable name by replacing any non-alphanumeric characters with underscores
            variable_name = f&#34;n_{gitem}&#34;.replace(&#34; &#34;, &#34;_&#34;).replace(&#34;-&#34;, &#34;_&#34;)
            # Define the variable to count the number of atoms in the group
            variable_definitions.append(f&#39;variable {variable_name} equal &#34;count({gitem})&#34;&#39;)
            # Define the corresponding print command
            print_commands.append(f&#39;print &#34;Number of atoms in {gitem}: ${{{variable_name}}}&#34;&#39;)
        # Create a dscript object with the generated commands
        idD = f&#34;&lt;dscript:group:{self._name}:count&gt;&#34;
        D = dscript(
            name=idD if name is None else name,
            description=f&#34;{idD} for group counts&#34;
        )
        D.variables = &#34;\n&#34;.join(variable_definitions)
        D.printvariables = &#34;\n&#34;.join(print_commands)
        D.set_all_variables()
        return D



# %% debug section - generic code to test methods (press F5)
if __name__ == &#39;__main__&#39;:

    # Example Usage
    G = group()
    G.variable(&#34;groupname&#34;,&#34;variablename&#34;,&#34;myexpression myexpression myexpression myexpression and again 1234&#34;)
    print(G.disp(&#34;groupname&#34;))

    G.byregion(&#34;regiongroup&#34;,&#34;myregionID&#34;)
    print(G.disp(&#34;regiongroup&#34;))

    G.union(&#34;uniongroup&#34;,&#34;group1&#34;,&#34;group2&#34;,&#34;group3&#34;)
    print(G.disp(&#34;uniongroup&#34;))

    # LAMMPS example
    #     group myGroup region myRegion
    #     group typeGroup type 1 2
    #     variable myVar atom &#34;x + y&#34;
    #     group varGroup variable myVar
    #     group unionGroup union myGroup typeGroup
    # Assuming Operation class is properly defined and includes necessary methods
    G0 = group()
    G0.byregion(&#39;myGroup&#39;, &#39;myRegion&#39;)
    G0.bytype(&#39;typeGroup&#39;, [1, 2])
    G0.variable(&#39;myVar&#39;, &#39;x + y&#39;)
    G0.byvariable(&#39;varGroup&#39;, &#39;myVar&#39;)
    # Perform group operations
    union_op = G0[&#39;myGroup&#39;] + G0[&#39;typeGroup&#39;]
    G0.evaluate(&#39;unionGroup&#39;, union_op)
    # Generate LAMMPS script
    print(G0.code())


    # Advanced Usage
    G = group()
    G.create_groups(&#39;o1&#39;, &#39;o2&#39;, &#39;o3&#39;, &#39;o4&#39;)
    G.create(&#39;o5&#39;)
    G.create(&#39;o6&#39;)
    G.create(&#39;o7&#39;)
    G.evaluate(&#34;debug0&#34;,G.o1+G.o2+G.o3 + G.o4 + (G.o5 +G.o6) + G.o7)
    G.evaluate(&#34;debug1&#34;,G.o1+G.o2)
    G.evaluate(&#34;debug2&#34;,G.o1+G.o2+G.o3-(G.o4+G.o5)+(G.o6*G.o7))
    print(repr(G))

    # Example to prepare workshop
    G = group()
    G.add_group_criteria(&#34;lower&#34;, type=[1])
    G.add_group_criteria(&#34;central&#34;, region=&#34;central_cyl&#34;)
    G.add_group_criteria(&#34;new_group&#34;, create=True)
    G.add_group_criteria(&#34;upper&#34;, clear=True)
    G.add_group_criteria(&#34;subtract_group&#34;, subtract=[&#34;group1&#34;, &#34;group2&#34;])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="group.format_table"><code class="name flex">
<span>def <span class="ident">format_table</span></span>(<span>headers:List[str], rows:List[List[str]], col_max_widths:List[int], align:Union[str,List[str]]='C') >str</span>
</code></dt>
<dd>
<div class="desc"><p>Formats a table with given headers and rows, truncating text based on maximum column widths
and aligning content based on the specified alignment.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>headers (List[str]): List of column headers.
rows (List[List[str]]): List of rows, where each row is a list of column values.
col_max_widths (List[int]): List of maximum widths for each column.
align (str or List[str], optional): Alignment for each column. Can be a single string
                                    (applies to all columns) or a list of strings (one for each column).
                                    Options are:
                                    - "C" or "center" for centered alignment (default).
                                    - "L" or "left" for left alignment.
                                    - "R" or "right" for right alignment.
                                    Case insensitive.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: A formatted table as a string.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If &lt;code&gt;align&lt;/code&gt; is a list but its length does not match the number of columns.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>&gt;&gt;&gt; headers = ["Idx", "Name", "Value"]
&gt;&gt;&gt; rows = [[1, "Example", "12345"], [2, "LongerName", "67890"]]
&gt;&gt;&gt; col_max_widths = [5, 10, 8]
&gt;&gt;&gt; align = ["R", "C", "L"]
&gt;&gt;&gt; print(format_table(headers, rows, col_max_widths, align))
Idx   |   Name    | Value
----- | ---------- | --------
  1   |  Example  | 12345
  2   | LongerName | 67890
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_table(
    headers: List[str],
    rows: List[List[str]],
    col_max_widths: List[int],
    align: Union[str, List[str]] = &#34;C&#34;,
) -&gt; str:
    &#34;&#34;&#34;
    Formats a table with given headers and rows, truncating text based on maximum column widths
    and aligning content based on the specified alignment.

    ### Parameters:
        headers (List[str]): List of column headers.
        rows (List[List[str]]): List of rows, where each row is a list of column values.
        col_max_widths (List[int]): List of maximum widths for each column.
        align (str or List[str], optional): Alignment for each column. Can be a single string
                                            (applies to all columns) or a list of strings (one for each column).
                                            Options are:
                                            - &#34;C&#34; or &#34;center&#34; for centered alignment (default).
                                            - &#34;L&#34; or &#34;left&#34; for left alignment.
                                            - &#34;R&#34; or &#34;right&#34; for right alignment.
                                            Case insensitive.

    ### Returns:
        str: A formatted table as a string.

    ### Raises:
        ValueError: If `align` is a list but its length does not match the number of columns.

    ### Example:
        &gt;&gt;&gt; headers = [&#34;Idx&#34;, &#34;Name&#34;, &#34;Value&#34;]
        &gt;&gt;&gt; rows = [[1, &#34;Example&#34;, &#34;12345&#34;], [2, &#34;LongerName&#34;, &#34;67890&#34;]]
        &gt;&gt;&gt; col_max_widths = [5, 10, 8]
        &gt;&gt;&gt; align = [&#34;R&#34;, &#34;C&#34;, &#34;L&#34;]
        &gt;&gt;&gt; print(format_table(headers, rows, col_max_widths, align))
        Idx   |   Name    | Value
        ----- | ---------- | --------
          1   |  Example  | 12345
          2   | LongerName | 67890
    &#34;&#34;&#34;
    # Normalize alignment input
    if isinstance(align, str):
        align = [align.upper()] * len(headers)
    elif isinstance(align, list):
        align = [a.upper() for a in align]
        if len(align) != len(headers):
            raise ValueError(&#34;The length of `align` must match the number of columns.&#34;)
    else:
        raise TypeError(&#34;`align` must be a string or a list of strings.&#34;)

    # Determine actual column widths based on headers and max widths
    col_widths = [
        min(max(len(header), *(len(str(row[i])) for row in rows)), max_w)
        for i, header in enumerate(headers)
        for max_w in [col_max_widths[i]]
    ]
    # Prepare alignment formatting
    alignments = []
    for a in align:
        if a in (&#34;C&#34;, &#34;CENTER&#34;):
            alignments.append(&#34;^&#34;)
        elif a in (&#34;L&#34;, &#34;LEFT&#34;):
            alignments.append(&#34;&lt;&#34;)
        elif a in (&#34;R&#34;, &#34;RIGHT&#34;):
            alignments.append(&#34;&gt;&#34;)
        else:
            raise ValueError(f&#34;Invalid alignment value: {a}&#34;)
    # Prepare header line
    header_line = &#34; | &#34;.join(
        f&#34;{headers[i]:{alignments[i]}{col_widths[i]}}&#34; for i in range(len(headers))
    )
    # Prepare separator
    separator = &#34; | &#34;.join(&#34;-&#34; * col_widths[i] for i in range(len(col_widths)))
    # Prepare rows
    formatted_rows = []
    for row in rows:
        formatted_row = [
            f&#34;{str(row[i]):{alignments[i]}{col_widths[i]}}&#34; for i in range(len(row))
        ]
        formatted_rows.append(&#34; | &#34;.join(formatted_row))
    # Combine all parts
    table = [header_line, separator] + formatted_rows + [separator]
    return &#34;\n&#34;.join(table)</code></pre>
</details>
</dd>
<dt id="group.generate_random_name"><code class="name flex">
<span>def <span class="ident">generate_random_name</span></span>(<span>length=8)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_random_name(length=8):
    letters = string.ascii_letters  # &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;
    return &#39;&#39;.join(random.choice(letters) for _ in range(length))</code></pre>
</details>
</dd>
<dt id="group.span"><code class="name flex">
<span>def <span class="ident">span</span></span>(<span>vector, sep=' ', left='', right='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def span(vector,sep=&#34; &#34;,left=&#34;&#34;,right=&#34;&#34;):
    return left + (vector if isinstance(vector, str) else sep.join(map(str, vector))) + right if vector is not None else &#34;&#34;</code></pre>
</details>
</dd>
<dt id="group.truncate_text"><code class="name flex">
<span>def <span class="ident">truncate_text</span></span>(<span>txt, maxwidth)</span>
</code></dt>
<dd>
<div class="desc"><p>Truncates the input text to fit within the specified maximum width.
If the text is longer than <code>maxwidth</code>, it is shortened by keeping
the beginning and trailing parts, separated by " [&hellip;] ".</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>txt (str): The text to truncate.
maxwidth (int): The maximum allowed width for the text.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: The truncated text with " [...] " in the middle if truncation occurs.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>&gt;&gt;&gt; truncate_text("This is a long string that needs truncation.", 20)
'This is [...] truncation.'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def truncate_text(txt, maxwidth):
    &#34;&#34;&#34;
    Truncates the input text to fit within the specified maximum width.
    If the text is longer than `maxwidth`, it is shortened by keeping
    the beginning and trailing parts, separated by &#34; [...] &#34;.

    ### Parameters:
        txt (str): The text to truncate.
        maxwidth (int): The maximum allowed width for the text.

    ### Returns:
        str: The truncated text with &#34; [...] &#34; in the middle if truncation occurs.

    ### Example:
        &gt;&gt;&gt; truncate_text(&#34;This is a long string that needs truncation.&#34;, 20)
        &#39;This is [...] truncation.&#39;
    &#34;&#34;&#34;
    # If the text fits within maxwidth, return it as is
    if len(txt) &lt;= maxwidth:
        return txt
    # Calculate the part lengths for beginning and end
    ellipsis = &#34; [...] &#34;
    split_length = (maxwidth - len(ellipsis)) // 2
    beginning = txt[:split_length]
    trailing = txt[-split_length:]
    return f&#34;{beginning}{ellipsis}{trailing}&#34;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="group.Operation"><code class="flex name class">
<span>class <span class="ident">Operation</span></span>
<span>(</span><span>operator, operands, name='', code='', criteria=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a LAMMPS group operation, allowing algebraic manipulation and code generation.</p>
<h3 id="overview">Overview</h3>
<p>The <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class models a group operation in LAMMPS (Large-scale Atomic/Molecular Massively
Parallel Simulator), encapsulating an operator, its operands, a name, and the corresponding LAMMPS code.
It supports algebraic operations between groups (union, intersection, subtraction) using the
overloaded operators '+', '-', and '*', enabling users to build complex group expressions
programmatically.</p>
<h3 id="attributes">Attributes</h3>
<ul>
<li>
<p><strong>operator (str)</strong>: The operator applied to the operands. It can be:</p>
<ul>
<li>A finalized LAMMPS operator: <code>'variable'</code>, <code>'byvariable'</code>, <code>'byregion'</code>, <code>'bytype'</code>, <code>'byid'</code>, <code>'create'</code>, <code>'clear'</code>,
<code>'union'</code>, <code>'intersect'</code>, <code>'subtract'</code>.</li>
<li>An algebraic operator: <code>'+'</code>, <code>'-'</code>, <code>'*'</code>.</li>
<li>An empty string or <code>None</code> for operations without an explicit operator.</li>
</ul>
</li>
<li>
<p><strong>operands (list)</strong>: A list of operands for the operation. Operands can be:</p>
<ul>
<li>Instances of <code><a title="group.Operation" href="#group.Operation">Operation</a></code>, representing nested operations.</li>
<li>Strings representing group names or other identifiers.</li>
<li>Integers or lists (e.g., atom types or IDs).</li>
</ul>
</li>
<li>
<p><strong>name (str)</strong>: The name of the operation, which can be manually set or auto-generated.</p>
<ul>
<li>If not provided, a unique hash-based name is generated using the <code>generate_hashname</code> method.</li>
</ul>
</li>
<li>
<p><strong>code (str)</strong>: The LAMMPS code that this operation represents.</p>
<ul>
<li>This is generated when the operation is finalized and corresponds to the actual command(s)
that would be included in a LAMMPS input script.</li>
</ul>
</li>
<li>
<p><strong>criteria (dict, optional)</strong>: Criteria used to define the operation.</p>
<ul>
<li>Useful for operations like <code>bytype</code>, <code>byregion</code>, <code>byid</code>, etc., where the criteria specify
the selection parameters.</li>
</ul>
</li>
</ul>
<h3 id="methods">Methods</h3>
<ul>
<li>
<p><code>__init__(self, operator, operands, name="", code="", criteria=None)</code>:
Initializes a new <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instance with the given parameters.</p>
<ul>
<li><strong>operator</strong> (str): The operator applied to the operands.</li>
<li><strong>operands</strong> (list or single operand): The operands for the operation.</li>
<li><strong>name</strong> (str, optional): The name of the operation.</li>
<li><strong>code</strong> (str, optional): The LAMMPS code representing the operation.</li>
<li><strong>criteria</strong> (dict, optional): Criteria used to define the operation.</li>
</ul>
</li>
<li>
<p><code>append(self, operand)</code>:
Appends a single operand to the operands list.</p>
</li>
<li>
<p><code>extend(self, operands)</code>:
Extends the operands list with multiple operands.</p>
</li>
<li>
<p><code>is_unary(self)</code>:
Checks if the <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instance has exactly one operand.</p>
</li>
<li>
<p><code>is_empty(self)</code>:
Checks if the <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instance has no operands.</p>
</li>
<li>
<p><code>generateID(self)</code>:
Generates an ID for the instance based on its operands or name.
Used internally for generating unique names.</p>
</li>
<li>
<p><code>generate_hashname(self, prefix="grp", ID=None)</code>:
Generates a hash-based name for the instance.</p>
<ul>
<li><strong>prefix</strong> (str): A string prefix for the generated name.</li>
<li><strong>ID</strong> (str, optional): An optional ID to include in the hash. If <code>None</code>, it is generated from operands.</li>
</ul>
</li>
<li>
<p><code>get_proper_operand(self)</code>:
Returns the appropriate operand representation depending on whether the operation is finalized.</p>
</li>
<li>
<p><code>_operate(self, other, operator)</code>:
Combines the operation with another <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instance using the specified operator.</p>
<ul>
<li><strong>other</strong> (<code><a title="group.Operation" href="#group.Operation">Operation</a></code>): The other operation to combine with.</li>
<li><strong>operator</strong> (str): The operator to apply ('+', '-', '*').</li>
</ul>
</li>
<li>
<p><code>isfinalized(self)</code>:
Checks if the operation has been finalized.</p>
<ul>
<li>An operation is considered finalized if its operator is not one of the algebraic operators '+', '-', '*'.</li>
</ul>
</li>
<li>
<p><code>__add__(self, other)</code>:
Overloads the '+' operator to support union of two <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instances.</p>
</li>
<li>
<p><code>__sub__(self, other)</code>:
Overloads the '-' operator to support subtraction between two <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instances.</p>
</li>
<li>
<p><code>__mul__(self, other)</code>:
Overloads the '*' operator to support intersection between two <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instances.</p>
</li>
<li>
<p><code>__repr__(self)</code>:
Returns a detailed string representation of the operation, useful for debugging.</p>
</li>
<li>
<p><code>__str__(self)</code>:
Returns a concise string representation of the operation.</p>
</li>
<li>
<p><code>script(self)</code>:
Generates the LAMMPS code for this operation using <code><a title="group.dscript" href="#group.dscript">dscript</a></code> and <code>script</code> classes.</p>
<ul>
<li>Returns a <code>script</code> object containing the LAMMPS code.</li>
</ul>
</li>
</ul>
<h3 id="operator-overloading">Operator Overloading</h3>
<p>The <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class overloads the following operators to enable algebraic manipulation:</p>
<ul>
<li>
<p><strong>Addition (<code>+</code>)</strong>:</p>
<ul>
<li>Combines two operations using union.</li>
<li>Example: <code>op3 = op1 + op2</code></li>
</ul>
</li>
<li>
<p><strong>Subtraction (<code>-</code>)</strong>:</p>
<ul>
<li>Subtracts one operation from another.</li>
<li>Example: <code>op3 = op1 - op2</code></li>
</ul>
</li>
<li>
<p><strong>Multiplication (<code>*</code>)</strong>:</p>
<ul>
<li>Intersects two operations.</li>
<li>Example: <code>op3 = op1 * op2</code></li>
</ul>
</li>
</ul>
<h3 id="usage-example">Usage Example</h3>
<pre><code class="language-python"># Create basic operations
op1 = Operation('bytype', [1], name='group1')
op2 = Operation('bytype', [2], name='group2')

# Combine operations using algebraic operators
combined_op = op1 + op2  # Union of group1 and group2

# Initialize group manager
G = group()
G.add_operation(op1)
G.add_operation(op2)

# Evaluate the combined operation and store the result
G.evaluate('combined_group', combined_op)

# Access the generated LAMMPS code
print(G.code())
# Output:
# group group1 type 1
# group group2 type 2
# group combined_group union group1 group2
</code></pre>
<h3 id="notes">Notes</h3>
<ul>
<li>
<p><strong>Lazy Evaluation</strong>:</p>
<ul>
<li>Operations are combined and stored symbolically until they are evaluated.</li>
<li>The actual LAMMPS code is generated when the operation is finalized (e.g., via the <code>evaluate</code> method in the <code><a title="group.group" href="#group.group">group</a></code> class).</li>
</ul>
</li>
<li>
<p><strong>Name Generation</strong>:</p>
<ul>
<li>If an operation's name is not provided, it is auto-generated using a hash of its operator and operands.</li>
<li>This ensures uniqueness and avoids naming conflicts.</li>
</ul>
</li>
<li>
<p><strong>Criteria Attribute</strong>:</p>
<ul>
<li>The <code>criteria</code> attribute allows storing the parameters used to define operations.</li>
<li>Useful for debugging, documentation, or reconstructing operations.</li>
</ul>
</li>
<li>
<p><strong>Finalization</strong>:</p>
<ul>
<li>An operation is finalized when it represents an actual LAMMPS command and has generated code.</li>
<li>Finalized operations are not further combined; instead, their names are used in subsequent operations.</li>
</ul>
</li>
<li>
<p><strong>Integration with <code><a title="group.dscript" href="#group.dscript">dscript</a></code> and <code>script</code></strong>:</p>
<ul>
<li>The <code>script</code> method generates the LAMMPS code for the operation using <code><a title="group.dscript" href="#group.dscript">dscript</a></code> and <code>script</code> classes.</li>
<li>Facilitates integration with script management tools and advanced scripting workflows.</li>
</ul>
</li>
<li>
<p><strong>Error Handling</strong>:</p>
<ul>
<li>Methods include error checks to ensure operands are valid and operations are correctly formed.</li>
<li>Raises informative exceptions for invalid operations or unsupported types.</li>
</ul>
</li>
</ul>
<h3 id="integration-with-group-class">Integration with Group Class</h3>
<p>The <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class is designed to work closely with the <code><a title="group.group" href="#group.group">group</a></code> class, which manages a collection of operations and handles evaluation and code generation.</p>
<ul>
<li><strong>Adding Operations</strong>:<ul>
<li>Use <code><a title="group.group.add_operation" href="#group.group.add_operation">group.add_operation()</a>(operation)</code> to add an <code><a title="group.Operation" href="#group.Operation">Operation</a></code> instance to a <code><a title="group.group" href="#group.group">group</a></code>.</li>
</ul>
</li>
<li><strong>Evaluating Operations</strong>:<ul>
<li>Use <code><a title="group.group.evaluate" href="#group.group.evaluate">group.evaluate()</a>(group_name, operation)</code> to finalize an operation and generate LAMMPS code.</li>
</ul>
</li>
<li><strong>Accessing Operations</strong>:<ul>
<li>Operations can be accessed via the <code><a title="group.group" href="#group.group">group</a></code> instance using indexing, attribute access, or methods.</li>
</ul>
</li>
</ul>
<h3 id="additional-information">Additional Information</h3>
<ul>
<li>
<p><strong>String Representations</strong>:</p>
<ul>
<li><code>__str__</code>: Provides a concise representation, useful for quick inspection.</li>
<li><code>__repr__</code>: Provides a detailed representation, useful for debugging.</li>
</ul>
</li>
<li>
<p><strong>Example of <code>__str__</code> Output</strong>:</p>
<ul>
<li>For an operation representing <code>group1 + group2</code>:
<code>python
print(str(combined_op))
# Output: &lt;combined_group=[group1+group2]&gt;</code></li>
</ul>
</li>
<li>
<p><strong>Example of <code>__repr__</code> Output</strong>:
<code>python
print(repr(combined_op))
# Output:
# Operation Details:
#
- Name: combined_group
#
- Operator: +
#
- Operands: group1, group2
#
- LAMMPS Code:</code></p>
</li>
</ul>
<h3 id="examples">Examples</h3>
<p><strong>Defining Operations Based on Atom Types</strong></p>
<pre><code class="language-python">op1 = Operation('bytype', [1], name='type1')
op2 = Operation('bytype', [2], name='type2')
G.add_operation(op1)
G.add_operation(op2)
</code></pre>
<p><strong>Combining and Evaluating Operations</strong></p>
<pre><code class="language-python">combined_op = op1 + op2  # Union of 'type1' and 'type2'
G.evaluate('all_types', combined_op)
</code></pre>
<p><strong>Accessing Generated Code</strong></p>
<pre><code class="language-python">print(G.code())
# Output:
# group type1 type 1
# group type2 type 2
# group all_types union type1 type2
</code></pre>
<p><strong>Using Criteria Attribute</strong></p>
<pre><code class="language-python"># Access criteria used to define an operation
print(op1.criteria)
# Output:
# {'type': [1]}
</code></pre>
<h3 id="important-notes">Important Notes</h3>
<ul>
<li>
<p><strong>Algebraic Operators vs. Finalized Operators</strong>:</p>
<ul>
<li>Algebraic operators ('+', '-', '*') are used for symbolic manipulation.</li>
<li>Finalized operators represent actual LAMMPS commands.</li>
</ul>
</li>
<li>
<p><strong>Operator Precedence</strong>:</p>
<ul>
<li>When combining operations, consider the order of operations.</li>
<li>Use parentheses to ensure the desired evaluation order.</li>
</ul>
</li>
<li>
<p><strong>Integration with Scripting Tools</strong>:</p>
<ul>
<li>The <code>script</code> method allows operations to be integrated into larger scripting workflows.</li>
<li>Supports advanced features like variable substitution and conditional execution.</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class provides a powerful and flexible way to model and manipulate group operations in LAMMPS simulations. By supporting algebraic operations and integrating with script management tools, it enables users to build complex group definitions programmatically, enhancing productivity and reducing errors in simulation setup.</p>
<p>Initializes a new Operation instance with given parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operation:
    &#34;&#34;&#34;
    Represents a LAMMPS group operation, allowing algebraic manipulation and code generation.

    ### Overview

    The `Operation` class models a group operation in LAMMPS (Large-scale Atomic/Molecular Massively
    Parallel Simulator), encapsulating an operator, its operands, a name, and the corresponding LAMMPS code.
    It supports algebraic operations between groups (union, intersection, subtraction) using the
    overloaded operators &#39;+&#39;, &#39;-&#39;, and &#39;*&#39;, enabling users to build complex group expressions
    programmatically.

    ### Attributes

    - **operator (str)**: The operator applied to the operands. It can be:
        - A finalized LAMMPS operator: `&#39;variable&#39;`, `&#39;byvariable&#39;`, `&#39;byregion&#39;`, `&#39;bytype&#39;`, `&#39;byid&#39;`, `&#39;create&#39;`, `&#39;clear&#39;`,
          `&#39;union&#39;`, `&#39;intersect&#39;`, `&#39;subtract&#39;`.
        - An algebraic operator: `&#39;+&#39;`, `&#39;-&#39;`, `&#39;*&#39;`.
        - An empty string or `None` for operations without an explicit operator.

    - **operands (list)**: A list of operands for the operation. Operands can be:
        - Instances of `Operation`, representing nested operations.
        - Strings representing group names or other identifiers.
        - Integers or lists (e.g., atom types or IDs).

    - **name (str)**: The name of the operation, which can be manually set or auto-generated.
        - If not provided, a unique hash-based name is generated using the `generate_hashname` method.

    - **code (str)**: The LAMMPS code that this operation represents.
        - This is generated when the operation is finalized and corresponds to the actual command(s)
          that would be included in a LAMMPS input script.

    - **criteria (dict, optional)**: Criteria used to define the operation.
        - Useful for operations like `bytype`, `byregion`, `byid`, etc., where the criteria specify
          the selection parameters.

    ### Methods

    - `__init__(self, operator, operands, name=&#34;&#34;, code=&#34;&#34;, criteria=None)`:
        Initializes a new `Operation` instance with the given parameters.
        - **operator** (str): The operator applied to the operands.
        - **operands** (list or single operand): The operands for the operation.
        - **name** (str, optional): The name of the operation.
        - **code** (str, optional): The LAMMPS code representing the operation.
        - **criteria** (dict, optional): Criteria used to define the operation.

    - `append(self, operand)`:
        Appends a single operand to the operands list.

    - `extend(self, operands)`:
        Extends the operands list with multiple operands.

    - `is_unary(self)`:
        Checks if the `Operation` instance has exactly one operand.

    - `is_empty(self)`:
        Checks if the `Operation` instance has no operands.

    - `generateID(self)`:
        Generates an ID for the instance based on its operands or name.
        Used internally for generating unique names.

    - `generate_hashname(self, prefix=&#34;grp&#34;, ID=None)`:
        Generates a hash-based name for the instance.
        - **prefix** (str): A string prefix for the generated name.
        - **ID** (str, optional): An optional ID to include in the hash. If `None`, it is generated from operands.

    - `get_proper_operand(self)`:
        Returns the appropriate operand representation depending on whether the operation is finalized.

    - `_operate(self, other, operator)`:
        Combines the operation with another `Operation` instance using the specified operator.
        - **other** (`Operation`): The other operation to combine with.
        - **operator** (str): The operator to apply (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;).

    - `isfinalized(self)`:
        Checks if the operation has been finalized.
        - An operation is considered finalized if its operator is not one of the algebraic operators &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.

    - `__add__(self, other)`:
        Overloads the &#39;+&#39; operator to support union of two `Operation` instances.

    - `__sub__(self, other)`:
        Overloads the &#39;-&#39; operator to support subtraction between two `Operation` instances.

    - `__mul__(self, other)`:
        Overloads the &#39;*&#39; operator to support intersection between two `Operation` instances.

    - `__repr__(self)`:
        Returns a detailed string representation of the operation, useful for debugging.

    - `__str__(self)`:
        Returns a concise string representation of the operation.

    - `script(self)`:
        Generates the LAMMPS code for this operation using `dscript` and `script` classes.
        - Returns a `script` object containing the LAMMPS code.

    ### Operator Overloading

    The `Operation` class overloads the following operators to enable algebraic manipulation:

    - **Addition (`+`)**:
        - Combines two operations using union.
        - Example: `op3 = op1 + op2`

    - **Subtraction (`-`)**:
        - Subtracts one operation from another.
        - Example: `op3 = op1 - op2`

    - **Multiplication (`*`)**:
        - Intersects two operations.
        - Example: `op3 = op1 * op2`

    ### Usage Example

    ```python
    # Create basic operations
    op1 = Operation(&#39;bytype&#39;, [1], name=&#39;group1&#39;)
    op2 = Operation(&#39;bytype&#39;, [2], name=&#39;group2&#39;)

    # Combine operations using algebraic operators
    combined_op = op1 + op2  # Union of group1 and group2

    # Initialize group manager
    G = group()
    G.add_operation(op1)
    G.add_operation(op2)

    # Evaluate the combined operation and store the result
    G.evaluate(&#39;combined_group&#39;, combined_op)

    # Access the generated LAMMPS code
    print(G.code())
    # Output:
    # group group1 type 1
    # group group2 type 2
    # group combined_group union group1 group2
    ```

    ### Notes

    - **Lazy Evaluation**:
        - Operations are combined and stored symbolically until they are evaluated.
        - The actual LAMMPS code is generated when the operation is finalized (e.g., via the `evaluate` method in the `group` class).

    - **Name Generation**:
        - If an operation&#39;s name is not provided, it is auto-generated using a hash of its operator and operands.
        - This ensures uniqueness and avoids naming conflicts.

    - **Criteria Attribute**:
        - The `criteria` attribute allows storing the parameters used to define operations.
        - Useful for debugging, documentation, or reconstructing operations.

    - **Finalization**:
        - An operation is finalized when it represents an actual LAMMPS command and has generated code.
        - Finalized operations are not further combined; instead, their names are used in subsequent operations.

    - **Integration with `dscript` and `script`**:
        - The `script` method generates the LAMMPS code for the operation using `dscript` and `script` classes.
        - Facilitates integration with script management tools and advanced scripting workflows.

    - **Error Handling**:
        - Methods include error checks to ensure operands are valid and operations are correctly formed.
        - Raises informative exceptions for invalid operations or unsupported types.

    ### Integration with Group Class

    The `Operation` class is designed to work closely with the `group` class, which manages a collection of operations and handles evaluation and code generation.

    - **Adding Operations**:
        - Use `group.add_operation(operation)` to add an `Operation` instance to a `group`.
    - **Evaluating Operations**:
        - Use `group.evaluate(group_name, operation)` to finalize an operation and generate LAMMPS code.
    - **Accessing Operations**:
        - Operations can be accessed via the `group` instance using indexing, attribute access, or methods.

    ### Additional Information

    - **String Representations**:
        - `__str__`: Provides a concise representation, useful for quick inspection.
        - `__repr__`: Provides a detailed representation, useful for debugging.

    - **Example of `__str__` Output**:
        - For an operation representing `group1 + group2`:
          ```python
          print(str(combined_op))
          # Output: &lt;combined_group=[group1+group2]&gt;
          ```

    - **Example of `__repr__` Output**:
        ```python
        print(repr(combined_op))
        # Output:
        # Operation Details:
        #   - Name: combined_group
        #   - Operator: +
        #   - Operands: group1, group2
        #   - LAMMPS Code:
        ```

    ### Examples

    **Defining Operations Based on Atom Types**

    ```python
    op1 = Operation(&#39;bytype&#39;, [1], name=&#39;type1&#39;)
    op2 = Operation(&#39;bytype&#39;, [2], name=&#39;type2&#39;)
    G.add_operation(op1)
    G.add_operation(op2)
    ```

    **Combining and Evaluating Operations**

    ```python
    combined_op = op1 + op2  # Union of &#39;type1&#39; and &#39;type2&#39;
    G.evaluate(&#39;all_types&#39;, combined_op)
    ```

    **Accessing Generated Code**

    ```python
    print(G.code())
    # Output:
    # group type1 type 1
    # group type2 type 2
    # group all_types union type1 type2
    ```

    **Using Criteria Attribute**

    ```python
    # Access criteria used to define an operation
    print(op1.criteria)
    # Output:
    # {&#39;type&#39;: [1]}
    ```

    ### Important Notes

    - **Algebraic Operators vs. Finalized Operators**:
        - Algebraic operators (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;) are used for symbolic manipulation.
        - Finalized operators represent actual LAMMPS commands.

    - **Operator Precedence**:
        - When combining operations, consider the order of operations.
        - Use parentheses to ensure the desired evaluation order.

    - **Integration with Scripting Tools**:
        - The `script` method allows operations to be integrated into larger scripting workflows.
        - Supports advanced features like variable substitution and conditional execution.

    ### Conclusion

    The `Operation` class provides a powerful and flexible way to model and manipulate group operations in LAMMPS simulations. By supporting algebraic operations and integrating with script management tools, it enables users to build complex group definitions programmatically, enhancing productivity and reducing errors in simulation setup.

    &#34;&#34;&#34;

    def __init__(self, operator, operands, name=&#34;&#34;, code=&#34;&#34;, criteria=None):
        &#34;&#34;&#34;Initializes a new Operation instance with given parameters.&#34;&#34;&#34;
        self.operator = operator
        self.operands = operands if isinstance(operands, list) else [operands]
        if not name:
            self.name = self.generate_hashname()
        else:
            self.name = name
        self.code = code
        self.criteria = criteria  # Store criteria for this operation

    def append(self, operand):
        &#34;&#34;&#34;Appends a single operand to the operands list of the Operation instance.&#34;&#34;&#34;
        self.operands.append(operand)

    def extend(self, operands):
        &#34;&#34;&#34;Extends the operands list of the Operation instance with multiple operands.&#34;&#34;&#34;
        self.operands.extend(operands)

    def is_unary(self):
        &#34;&#34;&#34;Checks if the Operation instance has exactly one operand.&#34;&#34;&#34;
        return len(self.operands) == 1

    def is_empty(self):
        &#34;&#34;&#34;Checks if the Operation instance has no operands.&#34;&#34;&#34;
        return len(self.operands) == 0

    def generateID(self):
        &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
        # if self.operands:
        #     return &#34;&#34;.join([str(op) for op in self.operands])
        # else:
        #     return self.name
        operand_ids = &#39;&#39;.join(op.name if isinstance(op, Operation) else str(op) for op in self.operands)
        return operand_ids

    def generate_hashname(self,prefix=&#34;grp&#34;,ID=None):
        &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
        # if ID is None: ID = self.generateID()
        # s = self.operator+ID
        # return prefix+hashlib.sha256(s.encode()).hexdigest()[:6]
        if ID is None:
            ID = self.generateID()
        s = self.operator + ID
        return prefix + hashlib.sha256(s.encode()).hexdigest()[:6]

    def __repr__(self):
        &#34;&#34;&#34; detailed representation &#34;&#34;&#34;
        operand_str = &#39;, &#39;.join(str(op) for op in self.operands)
        return (
            f&#34;Operation Details:\n&#34;
            f&#34;  - Name: {self.name}\n&#34;
            f&#34;  - Operator: {self.operator}\n&#34;
            f&#34;  - Operands: {operand_str}\n&#34;
            f&#34;  - LAMMPS Code: {self.code}&#34;
        )

    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        operands = [str(op) for op in self.operands]
        operand_str = &#39;, &#39;.join(operands)
        if self.is_empty():
            return f&#34;&lt;{self.operator} {self.name}&gt;&#34;

        elif self.is_unary():
            return f&#34;&lt;{self.name}={self.operator}({operand_str})&gt;&#34;
        else:  # Polynary
            operator_symbol_mapping = {
                &#39;union&#39;: &#39;+&#39;,
                &#39;intersect&#39;: &#39;*&#39;,
                &#39;subtract&#39;: &#39;-&#39;
            }
            operator_symbol = operator_symbol_mapping.get(self.operator, self.operator)
            formatted_operands = operator_symbol.join(operands)
            return f&#34;&lt;{self.name}=[{formatted_operands}]&gt;&#34;

    def isfinalized(self):
        &#34;&#34;&#34;
        Checks whether the Operation instance is finalized.
        Returns:
        - bool: True if the Operation is finalized, otherwise False.
        Functionality:
        - An Operation is considered finalized if its operator is not
         one of the algebraic operators &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.
        &#34;&#34;&#34;
        return self.operator not in (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;)

    def __add__(self, other):
        &#34;&#34;&#34; overload + as union &#34;&#34;&#34;
        return self._operate(other,&#39;+&#39;)

    def __sub__(self, other):
        &#34;&#34;&#34; overload - as subtract &#34;&#34;&#34;
        return self._operate(other,&#39;-&#39;)

    def __mul__(self, other):
        &#34;&#34;&#34; overload * as intersect &#34;&#34;&#34;
        return self._operate(other,&#39;*&#39;)

    def get_proper_operand(self):
        # &#34;&#34;&#34;
        # Returns the proper operand depending on whether the operation is finalized.
        # &#34;&#34;&#34;
        # return span(self.operands) if not self.isfinalized() else self.name
        &#34;&#34;&#34;
        Returns the proper operand depending on whether the operation is finalized.
        &#34;&#34;&#34;
        if self.isfinalized():
            return self.name
        else:
            # Collect operand names
            operand_names = [
                op.name if isinstance(op, Operation) else str(op)
                for op in self.operands
            ]
            return span(operand_names)

    def _operate(self, other, operator):
        &#34;&#34;&#34;
        Implements algebraic operations between self and other Operation instances.

        Parameters:
        - other (Operation): The other Operation instance to be operated with.
        - operator (str): The operation to be performed. Supported values are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.

        Returns:
        - Operation: A new Operation instance reflecting the result of the operation.
        &#34;&#34;&#34;
        # Ensure other is also an instance of Operation
        if not isinstance(other, Operation):
            raise TypeError(f&#34;Unsupported type: {type(other)}&#34;)

        # Map operator to prefix
        prefix_map = {&#39;+&#39;: &#39;add&#39;, &#39;-&#39;: &#39;sub&#39;, &#39;*&#39;: &#39;mul&#39;}
        prefix = prefix_map.get(operator, &#39;op&#39;)

        # Prepare operands list
        operands = []

        # Handle self
        if self.operator == operator and not self.isfinalized():
            operands.extend(self.operands)
        else:
            operands.append(self)

        # Handle other
        if other.operator == operator and not other.isfinalized():
            operands.extend(other.operands)
        else:
            operands.append(other)

        # Generate a new name
        name = self.generate_hashname(prefix=prefix, ID=self.generateID() + other.generateID())

        # Create a new Operation
        new_op = Operation(operator, operands, name=name)
        return new_op

    def script(self):
        &#34;&#34;&#34;
        Generate the LAMMPS code using the dscript and script classes.

        Returns:
        - script onject: The LAMMPS code generated by this operation.
        &#34;&#34;&#34;
        # Create a dscript object to store the operation code
        dscript_obj = dscript()
        # Use a dummy key for the dscript template
        dscript_obj[&#34;dummy&#34;] = self.code
        # Convert the dscript object to a script object
        script_obj = dscript_obj.script()
        return script_obj</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="group.Operation.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, operand)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a single operand to the operands list of the Operation instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, operand):
    &#34;&#34;&#34;Appends a single operand to the operands list of the Operation instance.&#34;&#34;&#34;
    self.operands.append(operand)</code></pre>
</details>
</dd>
<dt id="group.Operation.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, operands)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the operands list of the Operation instance with multiple operands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, operands):
    &#34;&#34;&#34;Extends the operands list of the Operation instance with multiple operands.&#34;&#34;&#34;
    self.operands.extend(operands)</code></pre>
</details>
</dd>
<dt id="group.Operation.generateID"><code class="name flex">
<span>def <span class="ident">generateID</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an ID for the Operation instance based on its operands or name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generateID(self):
    &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
    # if self.operands:
    #     return &#34;&#34;.join([str(op) for op in self.operands])
    # else:
    #     return self.name
    operand_ids = &#39;&#39;.join(op.name if isinstance(op, Operation) else str(op) for op in self.operands)
    return operand_ids</code></pre>
</details>
</dd>
<dt id="group.Operation.generate_hashname"><code class="name flex">
<span>def <span class="ident">generate_hashname</span></span>(<span>self, prefix='grp', ID=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an ID for the Operation instance based on its operands or name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_hashname(self,prefix=&#34;grp&#34;,ID=None):
    &#34;&#34;&#34;Generates an ID for the Operation instance based on its operands or name.&#34;&#34;&#34;
    # if ID is None: ID = self.generateID()
    # s = self.operator+ID
    # return prefix+hashlib.sha256(s.encode()).hexdigest()[:6]
    if ID is None:
        ID = self.generateID()
    s = self.operator + ID
    return prefix + hashlib.sha256(s.encode()).hexdigest()[:6]</code></pre>
</details>
</dd>
<dt id="group.Operation.get_proper_operand"><code class="name flex">
<span>def <span class="ident">get_proper_operand</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the proper operand depending on whether the operation is finalized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proper_operand(self):
    # &#34;&#34;&#34;
    # Returns the proper operand depending on whether the operation is finalized.
    # &#34;&#34;&#34;
    # return span(self.operands) if not self.isfinalized() else self.name
    &#34;&#34;&#34;
    Returns the proper operand depending on whether the operation is finalized.
    &#34;&#34;&#34;
    if self.isfinalized():
        return self.name
    else:
        # Collect operand names
        operand_names = [
            op.name if isinstance(op, Operation) else str(op)
            for op in self.operands
        ]
        return span(operand_names)</code></pre>
</details>
</dd>
<dt id="group.Operation.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Operation instance has no operands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;&#34;&#34;Checks if the Operation instance has no operands.&#34;&#34;&#34;
    return len(self.operands) == 0</code></pre>
</details>
</dd>
<dt id="group.Operation.is_unary"><code class="name flex">
<span>def <span class="ident">is_unary</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the Operation instance has exactly one operand.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_unary(self):
    &#34;&#34;&#34;Checks if the Operation instance has exactly one operand.&#34;&#34;&#34;
    return len(self.operands) == 1</code></pre>
</details>
</dd>
<dt id="group.Operation.isfinalized"><code class="name flex">
<span>def <span class="ident">isfinalized</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the Operation instance is finalized.
Returns:
- bool: True if the Operation is finalized, otherwise False.
Functionality:
- An Operation is considered finalized if its operator is not
one of the algebraic operators '+', '-', '*'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isfinalized(self):
    &#34;&#34;&#34;
    Checks whether the Operation instance is finalized.
    Returns:
    - bool: True if the Operation is finalized, otherwise False.
    Functionality:
    - An Operation is considered finalized if its operator is not
     one of the algebraic operators &#39;+&#39;, &#39;-&#39;, &#39;*&#39;.
    &#34;&#34;&#34;
    return self.operator not in (&#39;+&#39;, &#39;-&#39;, &#39;*&#39;)</code></pre>
</details>
</dd>
<dt id="group.Operation.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the LAMMPS code using the dscript and script classes.</p>
<p>Returns:
- script onject: The LAMMPS code generated by this operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self):
    &#34;&#34;&#34;
    Generate the LAMMPS code using the dscript and script classes.

    Returns:
    - script onject: The LAMMPS code generated by this operation.
    &#34;&#34;&#34;
    # Create a dscript object to store the operation code
    dscript_obj = dscript()
    # Use a dummy key for the dscript template
    dscript_obj[&#34;dummy&#34;] = self.code
    # Convert the dscript object to a script object
    script_obj = dscript_obj.script()
    return script_obj</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="group.dscript"><code class="flex name class">
<span>class <span class="ident">dscript</span></span>
<span>(</span><span>name=None, SECTIONS=['DYNAMIC'], section=0, position=None, role='dscript instance', description='dynamic script', userid='dscript', version=None, license=None, email=None, printflag=False, verbose=False, verbosity=None, **userdefinitions)</span>
</code></dt>
<dd>
<div class="desc"><p>dscript: A Dynamic Script Management Class</p>
<p>The <code><a title="group.dscript" href="#group.dscript">dscript</a></code> class is designed to manage and dynamically generate multiple
lines/items of a script, typically for use with LAMMPS or similar simulation tools.
Each line in the script is represented as a <code>ScriptTemplate</code> object, and the
class provides tools to easily manipulate, concatenate, and execute these
script lines/items.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Dynamic Script Generation</strong>: Define and manage script lines/items dynamically,
with variables that can be substituted at runtime.</li>
<li><strong>Conditional Execution</strong>: Add conditions to script lines/items so they are only
included if certain criteria are met.</li>
<li><strong>Script Concatenation</strong>: Combine multiple script objects while maintaining
control over variable precedence and script structure.</li>
<li><strong>User-Friendly Access</strong>: Easily access and manipulate script lines/items using
familiar Python constructs like indexing and iteration.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>Custom LAMMPS Scripts</strong>: Generate complex simulation scripts with varying
parameters based on dynamic conditions.</li>
<li><strong>Automation</strong>: Automate the creation of scripts for batch processing,
simulations, or other repetitive tasks.</li>
<li><strong>Script Management</strong>: Manage and version-control different script sections
and configurations easily.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, name=None):
Initializes a new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object with an optional name.</p>
<p><strong>getitem</strong>(self, key):
Retrieves a script line by its key. If a list of keys is provided,
returns a new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object with lines/items reordered accordingly.</p>
<p><strong>setitem</strong>(self, key, value):
Adds or updates a script line. If the value is an empty list, the
corresponding script line is removed.</p>
<p><strong>delitem</strong>(self, key):
Deletes a script line by its key.</p>
<p><strong>contains</strong>(self, key):
Checks if a key exists in the script. Allows usage of <code>in</code> keyword.</p>
<p><strong>iter</strong>(self):
Returns an iterator over the script lines/items, allowing for easy iteration
through all lines/items in the <code>TEMPLATE</code>.</p>
<p><strong>len</strong>(self):
Returns the number of script lines/items currently stored in the <code>TEMPLATE</code>.</p>
<p>keys(self):
Returns the keys of the <code>TEMPLATE</code> dictionary.</p>
<p>values(self):
Returns the <code>ScriptTemplate</code> objects stored as values in the <code>TEMPLATE</code>.</p>
<p>items(self):
Returns the keys and <code>ScriptTemplate</code> objects from the <code>TEMPLATE</code> as pairs.</p>
<p><strong>str</strong>(self):
Returns a human-readable summary of the script, including the number
of lines/items and total attributes. Shortcut: <code>str(S)</code>.</p>
<p><strong>repr</strong>(self):
Provides a detailed string representation of the entire <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object,
including all script lines/items and their attributes. Useful for debugging.</p>
<p>reorder(self, order):
Reorders the script lines/items based on a given list of indices, creating a
new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object with the reordered lines/items.</p>
<p>get_content_by_index(self, index, do=True, protected=True):
Returns the processed content of the script line at the specified index,
with variables substituted based on the definitions and conditions applied.</p>
<p>get_attributes_by_index(self, index):
Returns the attributes of the script line at the specified index.</p>
<p>add_dynamic_script(self, key, content="", definitions=None, verbose=None, **USER):
Add a dynamic script step to the <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object.</p>
<p>createEmptyVariables(self, vars):
Creates new variables in <code>DEFINITIONS</code> if they do not already exist.
Accepts a single variable name or a list of variable names.</p>
<p>do(self, printflag=None, verbose=None):
Executes all script lines/items in the <code>TEMPLATE</code>, concatenating the results,
and handling variable substitution. Returns the full script as a string.</p>
<p>script(self, **userdefinitions):
Generates a <code>lamdaScript</code> object from the current <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object,
applying any additional user definitions provided.</p>
<p>pipescript(self, printflag=None, verbose=None, **USER):
Returns a <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> object by combining script objects for all keys
in the <code>TEMPLATE</code>. Each key in <code>TEMPLATE</code> is handled separately, and
the resulting scripts are combined using the <code>|</code> operator.</p>
<p>save(self, filename=None, foldername=None, overwrite=False):
Saves the current script instance to a text file in a structured format.
Includes metadata, global parameters, definitions, templates, and attributes.</p>
<p>write(scriptcontent, filename=None, foldername=None, overwrite=False):
Writes the provided script content to a specified file in a given folder,
with a header added if necessary, ensuring the correct file format.</p>
<p>load(cls, filename, foldername=None, numerickeys=True):
Loads a script instance from a text file, restoring the content, definitions,
templates, and attributes. Handles parsing and variable substitution based on
the structure of the file.</p>
<p>parsesyntax(cls, content, numerickeys=True):
Parses a script instance from a string input, restoring the content, definitions,
templates, and attributes. Handles parsing and variable substitution based on the
structure of the provided string, ensuring the correct format and key conversions
when necessary.</p>
<p>search(self, primary_key, value, foreign_key, include_global=True, multiple='first', verbose=False):
Searches for foreign key values associated with given primary key value(s).</p>
<p>list_values(self, key, include_global=True):
Lists all unique values taken by a specified key across all steps and optionally
in global definitions.</p>
<p>var_info(self):
Analyzes and gathers comprehensive information about variables used in the script.</p>
<p>print_var_info(self, what='all', output_file=None, overwrite=False):
Prints or saves a neatly formatted table of variable information based on the analysis from <code>var_info()</code>.</p>
<h2 id="example">Example:</h2>
<h1 id="create-a-dscript-object">Create a dscript object</h1>
<p>R = dscript(name="MyScript")</p>
<h1 id="define-global-variables-definitions">Define global variables (DEFINITIONS)</h1>
<p>R.DEFINITIONS.dimension = 3
R.DEFINITIONS.units = "$si"</p>
<h1 id="add-script-lines">Add script lines</h1>
<p>R[0] = "dimension
${dimension}"
R[1] = "units
${units}"</p>
<h1 id="generate-and-print-the-script">Generate and print the script</h1>
<p>sR = R.script()
print(sR.do())</p>
<h2 id="attributes">Attributes:</h2>
<p>name : str
The name of the script, useful for identification.
TEMPLATE : dict
A dictionary storing script lines/items, with keys to identify each line.
DEFINITIONS : lambdaScriptdata
Stores the variables and parameters used within the script lines/items.</p>
<p>Initializes a new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object.</p>
<p>The constructor sets up a new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object, which allows you to
define and manage a script composed of multiple lines/items. Each line is
stored in the <code>TEMPLATE</code> dictionary, and variables used in the script
are stored in <code>DEFINITIONS</code>.</p>
<h2 id="parameters">Parameters:</h2>
<p>name : str, optional
The name of the script. If no name is provided, a random name will
be generated automatically. The name is useful for identifying the
script, especially when managing multiple scripts.</p>
<h2 id="example_1">Example:</h2>
<h1 id="create-a-dscript-object-with-a-specific-name">Create a dscript object with a specific name</h1>
<p>R = dscript(name="ExampleScript")</p>
<h1 id="or-create-a-dscript-object-with-a-random-name">Or create a dscript object with a random name</h1>
<p>R = dscript()</p>
<p>After initialization, you can start adding script lines/items and defining variables.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dscript:
    &#34;&#34;&#34;
    dscript: A Dynamic Script Management Class

    The `dscript` class is designed to manage and dynamically generate multiple
    lines/items of a script, typically for use with LAMMPS or similar simulation tools.
    Each line in the script is represented as a `ScriptTemplate` object, and the
    class provides tools to easily manipulate, concatenate, and execute these
    script lines/items.

    Key Features:
    -------------
    - **Dynamic Script Generation**: Define and manage script lines/items dynamically,
      with variables that can be substituted at runtime.
    - **Conditional Execution**: Add conditions to script lines/items so they are only
      included if certain criteria are met.
    - **Script Concatenation**: Combine multiple script objects while maintaining
      control over variable precedence and script structure.
    - **User-Friendly Access**: Easily access and manipulate script lines/items using
      familiar Python constructs like indexing and iteration.

    Practical Use Cases:
    --------------------
    - **Custom LAMMPS Scripts**: Generate complex simulation scripts with varying
      parameters based on dynamic conditions.
    - **Automation**: Automate the creation of scripts for batch processing,
      simulations, or other repetitive tasks.
    - **Script Management**: Manage and version-control different script sections
      and configurations easily.

    Methods:
    --------
    __init__(self, name=None):
        Initializes a new `dscript` object with an optional name.

    __getitem__(self, key):
        Retrieves a script line by its key. If a list of keys is provided,
        returns a new `dscript` object with lines/items reordered accordingly.

    __setitem__(self, key, value):
        Adds or updates a script line. If the value is an empty list, the
        corresponding script line is removed.

    __delitem__(self, key):
        Deletes a script line by its key.

    __contains__(self, key):
        Checks if a key exists in the script. Allows usage of `in` keyword.

    __iter__(self):
        Returns an iterator over the script lines/items, allowing for easy iteration
        through all lines/items in the `TEMPLATE`.

    __len__(self):
        Returns the number of script lines/items currently stored in the `TEMPLATE`.

    keys(self):
        Returns the keys of the `TEMPLATE` dictionary.

    values(self):
        Returns the `ScriptTemplate` objects stored as values in the `TEMPLATE`.

    items(self):
        Returns the keys and `ScriptTemplate` objects from the `TEMPLATE` as pairs.

    __str__(self):
        Returns a human-readable summary of the script, including the number
        of lines/items and total attributes. Shortcut: `str(S)`.

    __repr__(self):
        Provides a detailed string representation of the entire `dscript` object,
        including all script lines/items and their attributes. Useful for debugging.

    reorder(self, order):
        Reorders the script lines/items based on a given list of indices, creating a
        new `dscript` object with the reordered lines/items.

    get_content_by_index(self, index, do=True, protected=True):
        Returns the processed content of the script line at the specified index,
        with variables substituted based on the definitions and conditions applied.

    get_attributes_by_index(self, index):
        Returns the attributes of the script line at the specified index.

    add_dynamic_script(self, key, content=&#34;&#34;, definitions=None, verbose=None, **USER):
        Add a dynamic script step to the `dscript` object.

    createEmptyVariables(self, vars):
        Creates new variables in `DEFINITIONS` if they do not already exist.
        Accepts a single variable name or a list of variable names.

    do(self, printflag=None, verbose=None):
        Executes all script lines/items in the `TEMPLATE`, concatenating the results,
        and handling variable substitution. Returns the full script as a string.

    script(self, **userdefinitions):
        Generates a `lamdaScript` object from the current `dscript` object,
        applying any additional user definitions provided.

    pipescript(self, printflag=None, verbose=None, **USER):
        Returns a `pipescript` object by combining script objects for all keys
        in the `TEMPLATE`. Each key in `TEMPLATE` is handled separately, and
        the resulting scripts are combined using the `|` operator.

    save(self, filename=None, foldername=None, overwrite=False):
        Saves the current script instance to a text file in a structured format.
        Includes metadata, global parameters, definitions, templates, and attributes.

    write(scriptcontent, filename=None, foldername=None, overwrite=False):
        Writes the provided script content to a specified file in a given folder,
        with a header added if necessary, ensuring the correct file format.

    load(cls, filename, foldername=None, numerickeys=True):
        Loads a script instance from a text file, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on
        the structure of the file.

    parsesyntax(cls, content, numerickeys=True):
        Parses a script instance from a string input, restoring the content, definitions,
        templates, and attributes. Handles parsing and variable substitution based on the
        structure of the provided string, ensuring the correct format and key conversions
        when necessary.

    search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;first&#39;, verbose=False):
        Searches for foreign key values associated with given primary key value(s).

    list_values(self, key, include_global=True):
        Lists all unique values taken by a specified key across all steps and optionally
        in global definitions.

    var_info(self):
        Analyzes and gathers comprehensive information about variables used in the script.

    print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        Prints or saves a neatly formatted table of variable information based on the analysis from `var_info()`.


    Example:
    --------
    # Create a dscript object
    R = dscript(name=&#34;MyScript&#34;)

    # Define global variables (DEFINITIONS)
    R.DEFINITIONS.dimension = 3
    R.DEFINITIONS.units = &#34;$si&#34;

    # Add script lines
    R[0] = &#34;dimension    ${dimension}&#34;
    R[1] = &#34;units        ${units}&#34;

    # Generate and print the script
    sR = R.script()
    print(sR.do())

    Attributes:
    -----------
    name : str
        The name of the script, useful for identification.
    TEMPLATE : dict
        A dictionary storing script lines/items, with keys to identify each line.
    DEFINITIONS : lambdaScriptdata
        Stores the variables and parameters used within the script lines/items.
    &#34;&#34;&#34;

    # Class variable to list attributes that should not be treated as TEMPLATE entries
    construction_attributes = {&#39;name&#39;, &#39;SECTIONS&#39;, &#39;section&#39;, &#39;position&#39;, &#39;role&#39;, &#39;description&#39;,
                               &#39;userid&#39;, &#39;verbose&#39;, &#39;printflag&#39;, &#39;DEFINITIONS&#39;, &#39;TEMPLATE&#39;,
                               &#39;version&#39;,&#39;license&#39;,&#39;email&#39;
                               }

    def __init__(self,  name=None,
                        SECTIONS = [&#34;DYNAMIC&#34;],
                        section = 0,
                        position = None,
                        role = &#34;dscript instance&#34;,
                        description = &#34;dynamic script&#34;,
                        userid = &#34;dscript&#34;,
                        version = None,
                        license = None,
                        email = None,
                        printflag = False,
                        verbose = False,
                        verbosity = None,
                        **userdefinitions
                        ):
        &#34;&#34;&#34;
        Initializes a new `dscript` object.

        The constructor sets up a new `dscript` object, which allows you to
        define and manage a script composed of multiple lines/items. Each line is
        stored in the `TEMPLATE` dictionary, and variables used in the script
        are stored in `DEFINITIONS`.

        Parameters:
        -----------
        name : str, optional
            The name of the script. If no name is provided, a random name will
            be generated automatically. The name is useful for identifying the
            script, especially when managing multiple scripts.

        Example:
        --------
        # Create a dscript object with a specific name
        R = dscript(name=&#34;ExampleScript&#34;)

        # Or create a dscript object with a random name
        R = dscript()

        After initialization, you can start adding script lines/items and defining variables.
        &#34;&#34;&#34;

        if name is None:
            self.name = autoname()
        else:
            self.name = name

        if (version is None) or (license is None) or (email is None):
            metadata = get_metadata()               # retrieve all metadata
            version = metadata[&#34;version&#34;] if version is None else version
            license = metadata[&#34;license&#34;] if license is None else license
            email = metadata[&#34;email&#34;] if email is None else email
        self.SECTIONS = SECTIONS if isinstance(SECTIONS,(list,tuple)) else [SECTIONS]
        self.section = section
        self.position = position if position is not None else 0
        self.role = role
        self.description = description
        self.userid = userid
        self.version = version
        self.license = license
        self.email = email
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.DEFINITIONS = lambdaScriptdata(**userdefinitions)
        self.TEMPLATE = {}

    def __getattr__(self, attr):
        # During construction phase, we only access the predefined attributes
        if &#39;TEMPLATE&#39; not in self.__dict__:
            if attr in self.__dict__:
                return self.__dict__[attr]
            raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)

        # If TEMPLATE is initialized and attr is in TEMPLATE, return the corresponding ScriptTemplate entry
        if attr in self.TEMPLATE:
            return self.TEMPLATE[attr]

        # Fall back to internal __dict__ attributes if not in TEMPLATE
        if attr in self.__dict__:
            return self.__dict__[attr]

        raise AttributeError(f&#34;&#39;dscript&#39; object has no attribute &#39;{attr}&#39;&#34;)


    def __setattr__(self, attr, value):
        # Handle internal attributes during the construction phase
        if &#39;TEMPLATE&#39; not in self.__dict__:
            self.__dict__[attr] = value
            return

        # Handle construction attributes separately (name, TEMPLATE, USER)
        if attr in self.construction_attributes:
            self.__dict__[attr] = value
        # If TEMPLATE exists, and the attribute is intended for it, update TEMPLATE
        elif &#39;TEMPLATE&#39; in self.__dict__:
            # Convert the value to a ScriptTemplate if needed, and update the template
            if attr in self.TEMPLATE:
                # Modify the existing ScriptTemplate object for this attribute
                if isinstance(value, str):
                    self.TEMPLATE[attr].content = value
                elif isinstance(value, dict):
                    self.TEMPLATE[attr].attributes.update(value)
            else:
                # Create a new entry if it does not exist
                self.TEMPLATE[attr] = ScriptTemplate(content=value,definitions=self.DEFINITIONS,verbose=self.verbose,userid=attr)
        else:
            # Default to internal attributes
            self.__dict__[attr] = value


    def __getitem__(self, key):
        &#34;&#34;&#34;
        Implements index-based retrieval, slicing, or reordering for dscript objects.

        Parameters:
        -----------
        key : int, slice, list, or str
            - If `key` is an int, returns the corresponding template at that index.
              Supports negative indices to retrieve templates from the end.
            - If `key` is a slice, returns a new `dscript` object containing the templates in the specified range.
            - If `key` is a list, reorders the TEMPLATE based on the list of indices or keys.
            - If `key` is a string, treats it as a key and returns the corresponding template.

        Returns:
        --------
        dscript or ScriptTemplate : Depending on the type of key, returns either a new dscript object (for slicing or reordering)
                                    or a ScriptTemplate object (for direct key access).
        &#34;&#34;&#34;
        # Handle list-based reordering
        if isinstance(key, list):
            return self.reorder(key)

        # Handle slicing
        elif isinstance(key, slice):
            new_dscript = deepduplicate(self)
            new_dscript.name = f&#34;{self.name}_slice_{key.start}_{key.stop}&#34;
            keys = list(self.TEMPLATE.keys())
            sliced_keys = keys[key]
            new_dscript.TEMPLATE = {k: self.TEMPLATE[k] for k in sliced_keys}
            return new_dscript

        # Handle integer indexing with support for negative indices
        elif isinstance(key, int):
            keys = list(self.TEMPLATE.keys())
            if key in self.TEMPLATE:  # Check if the integer exists as a key
                return self.TEMPLATE[key]
            if key &lt; 0:  # Support negative indices
                key += len(keys)
            if key &lt; 0 or key &gt;= len(keys):  # Check for index out of range
                raise IndexError(f&#34;Index {key - len(keys)} is out of range&#34;)
            # Return the template corresponding to the integer index
            return self.TEMPLATE[keys[key]]

        # Handle key-based access (string keys)
        elif isinstance(key, str):
            if key in self.TEMPLATE:
                return self.TEMPLATE[key]
            raise KeyError(f&#34;Key &#39;{key}&#39; does not exist in TEMPLATE.&#34;)


    def __setitem__(self, key, value):
        if (value == []) or (value is None):
            # If the value is an empty list, delete the corresponding key
            del self.TEMPLATE[key]
        else:
            # Otherwise, set the key to the new ScriptTemplate
            self.TEMPLATE[key] = ScriptTemplate(value, definitions=self.DEFINITIONS, verbose=self.verbose, userid=key)

    def __delitem__(self, key):
        del self.TEMPLATE[key]

    def __iter__(self):
        return iter(self.TEMPLATE.items())

    # def keys(self):
    #     return self.TEMPLATE.keys()

    # def values(self):
    #     return (s.content for s in self.TEMPLATE.values())

    def __contains__(self, key):
        return key in self.TEMPLATE

    def __len__(self):
        return len(self.TEMPLATE)

    def items(self):
        return ((key, s.content) for key, s in self.TEMPLATE.items())

    def __str__(self):
        num_TEMPLATE = len(self.TEMPLATE)
        total_attributes = sum(len(s.attributes) for s in self.TEMPLATE.values())
        return f&#34;{num_TEMPLATE} TEMPLATE, {total_attributes} attributes&#34;

    def __repr__(self):
        &#34;&#34;&#34;Representation of dscript object with additional properties.&#34;&#34;&#34;
        repr_str = f&#34;dscript object ({self.name})\n&#34;
        # Add description, role, and version at the beginning
        repr_str += f&#34;id: {self.userid}\n&#34; if self.userid else &#34;&#34;
        repr_str += f&#34;Descr: {self.description}\n&#34; if self.description else &#34;&#34;
        repr_str += f&#34;Role: {self.role} (v. {self.version})\n&#34;
        repr_str += f&#39;SECTIONS {span(self.SECTIONS,&#34;,&#34;,&#34;[&#34;,&#34;]&#34;)} | index: {self.section} | position: {self.position}\n&#39;
        repr_str += &#39;\n&#39;

        # Add GLOBAL DEFINITIONS information
        gvars = self.DEFINITIONS.keys()
        ngvars = len(gvars)
        repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
        if ngvars&gt;0:
            flag = &#39;[G]&#39; # with G for GLOBAL
            head = f&#34;with {ngvars} GLOBAL DEFINITION{&#39;S&#39; if ngvars&gt;1 else &#39;&#39;}  &#34;
            dashes = (50 - len(head)) // 2
            repr_str += f&#34;{&#39; &#39; * dashes}{head}{&#39; &#39; * dashes}\n&#34;
            repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
            for i in range(0, len(gvars), 3):
                var_set = gvars[i:i+3]
                line = &#34;&#34;
                for var in var_set:
                    var_name = (var[:10] + &#39; &#39;) if len(var) &gt; 10 else var.ljust(11)
                    line += f&#34;{flag} {var_name}  &#34;
                repr_str += f&#34;{line}\n&#34;
        else:
            head = &#34;  NO GLOBAL DEFINITION  &#34;
            dashes = (50 - len(head)) // 2
            repr_str += f&#34;{&#39;!&#39; * dashes}{head}{&#39;!&#39; * dashes}\n&#34;
            repr_str += &#34;-&#34; * 50 + &#34;\n&#34;

        # Add TEMPLATE header
        ntemplates = len(self.TEMPLATE)
        head = f&#34;and with {ntemplates} TEMPLATE{&#39;S&#39; if ntemplates&gt;1 else &#39;&#39;} &#34;
        dashes = (50 - len(head)) // 2
        repr_str += f&#34;\n\n{&#39; &#39; * dashes}{head}{&#39; &#39; * dashes}\n\n&#34;

        # Add TEMPLATE information
        c = 0
        for k, s in self.TEMPLATE.items():
            head = f&#34;|  idx: {c} |  key: {k}  |&#34;
            dashes = (50 - len(head)) // 2
            repr_str += &#34;-&#34; * 50 + &#34;\n&#34;
            repr_str += f&#34;{&#39;&lt;&#39; * dashes}{head}{&#39;&gt;&#39; * dashes}\n{repr(s)}\n&#34;
            c += 1
        return repr_str

    def keys(self):
        &#34;&#34;&#34;Return the keys of the TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.keys()

    def values(self):
        &#34;&#34;&#34;Return the ScriptTemplate objects in TEMPLATE.&#34;&#34;&#34;
        return self.TEMPLATE.values()

    def reorder(self, order):
        &#34;&#34;&#34;Reorder the TEMPLATE lines according to a list of indices.&#34;&#34;&#34;
        # Get the original items as a list of (key, value) pairs
        original_items = list(self.TEMPLATE.items())
        # Create a new dictionary with reordered scripts, preserving original keys
        new_scripts = {original_items[i][0]: original_items[i][1] for i in order}
        # Create a new dscript object with reordered scripts
        reordered_script = dscript()
        reordered_script.TEMPLATE = new_scripts
        return reordered_script


    def get_content_by_index(self, index, do=True, protected=True):
        &#34;&#34;&#34;
        Returns the content of the ScriptTemplate at the specified index.

        Parameters:
        -----------
        index : int
            The index of the template in the TEMPLATE dictionary.
        do : bool, optional (default=True)
            If True, the content will be processed based on conditions and evaluation flags.
        protected : bool, optional (default=True)
            Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).

        Returns:
        --------
        str or list of str
            The content of the template after processing, or an empty string if conditions or evaluation flags block it.
        &#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        s = self.TEMPLATE[key].content
        att = self.TEMPLATE[key].attributes
        # Return an empty string if the facultative attribute is True and do is True
        if att[&#34;facultative&#34;] and do:
            return &#34;&#34;
        # Evaluate the condition (if any)
        if att[&#34;condition&#34;] is not None:
            cond = eval(self.DEFINITIONS.formateval(att[&#34;condition&#34;], protected))
        else:
            cond = True
        # If the condition is met, process the content
        if cond:
            # Apply formateval only if the eval attribute is True and do is True
            if att[&#34;eval&#34;] and do:
                if isinstance(s, list):
                    # Apply formateval to each item in the list if s is a list
                    return [self.DEFINITIONS.formateval(line, protected) for line in s]
                else:
                    # Apply formateval to the single string content
                    return self.DEFINITIONS.formateval(s, protected)
            else:
                return s  # Return the raw content if no evaluation is needed
        elif do:
            return &#34;&#34;  # Return an empty string if the condition is not met and do is True
        else:
            return s  # Return the raw content if do is False


    def get_attributes_by_index(self, index):
        &#34;&#34;&#34; Returns the attributes of the ScriptTemplate at the specified index.&#34;&#34;&#34;
        key = list(self.TEMPLATE.keys())[index]
        return self.TEMPLATE[key].attributes


    def __add__(self, other):
        &#34;&#34;&#34;
        Concatenates two dscript objects, creating a new dscript object that combines
        the TEMPLATE and DEFINITIONS of both. This operation avoids deep copying
        of definitions by creating a new lambdaScriptdata instance from the definitions.

        when other is not a dscript, self is converted into a script before being combined with +

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : dscript (or a script)
            A new dscript object with the concatenated TEMPLATE and merged DEFINITIONS.
            A script object is returned when other is not a dscript object.

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            # Step 1: Merge global DEFINITIONS from both self and other
            result = dscript(name=self.name+&#34;+&#34;+other.name,**(self.DEFINITIONS + other.DEFINITIONS))
            # Step 2: Start by copying the TEMPLATE from self (no deepcopy for performance reasons)
            result.TEMPLATE = self.TEMPLATE.copy()
            # Step 3: Ensure that the local definitions for `self.TEMPLATE` are properly copied
            for key, value in self.TEMPLATE.items():
                result.TEMPLATE[key].definitions = lambdaScriptdata(**self.TEMPLATE[key].definitions)
            # Step 4: Track the next available index if keys need to be created
            next_index = len(result.TEMPLATE)
            # Step 5: Add items from the other dscript object, updating or generating new keys as needed
            for key, value in other.TEMPLATE.items():
                if key in result.TEMPLATE:
                    # If key already exists in result, assign a new unique index
                    while next_index in result.TEMPLATE:
                        next_index += 1
                    new_key = next_index
                else:
                    # Use the original key if it doesn&#39;t already exist
                    new_key = key
                # Copy the TEMPLATE&#39;s content and definitions from `other`
                result.TEMPLATE[new_key] = value
                # Merge the local TEMPLATE definitions from `other`
                result.TEMPLATE[new_key].definitions = lambdaScriptdata(**other.TEMPLATE[key].definitions)
            return result
        elif isinstance(other,(script,scriptobjectgroup)):
            return self.script() + other
        elif isinstance(other,pipescript):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        else:
            raise TypeError(f&#34;Cannot concatenate &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)


    def __or__(self, other):
        &#34;&#34;&#34;
        Pipes a dscript object with other objects.
        When other is a dscript object, both objects are concatenated (+) before being converted into a pipescript object
        When other is a script, pipescript or scriptobjectgroup, self is converted into a pipescript

        Parameters:
        -----------
        other : dscript, script, scriptobjectgroup, pipescript
            The other dscript object to concatenate with the current one.

        Returns:
        --------
        result : a pipescript

        Raises:
        -------
        TypeError:
            If the other object is not an instance of dscript, script, pipescript
        &#34;&#34;&#34;
        if isinstance(other, dscript):
            tmp = self + other
            return tmp.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(other,(script,pipescript)):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other
        elif isinstance(other,scriptobjectgroup):
            return self.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity) | other.script()
        else:
            raise TypeError(f&#34;Cannot pipe &#39;dscript&#39; with &#39;{type(other).__name__}&#39;&#34;)



    def __call__(self, *keys):
        &#34;&#34;&#34;
        Extracts subobjects from the dscript based on the provided keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.

        Returns:
        --------
        A new `dscript` object that contains only the selected script lines/items, along with
        the relevant definitions and attributes from the original object.
        &#34;&#34;&#34;
        # Create a new dscript object to store the extracted sub-objects
        result = dscript(name=f&#34;{self.name}_subobject&#34;)
        # Copy the TEMPLATE entries corresponding to the provided keys
        for key in keys:
            if key in self.TEMPLATE:
                result.TEMPLATE[key] = self.TEMPLATE[key]
            else:
                raise KeyError(f&#34;Key &#39;{key}&#39; not found in TEMPLATE.&#34;)
        # Copy the DEFINITIONS from the current object
        result.DEFINITIONS = copy.deepcopy(self.DEFINITIONS)
        # Copy other relevant attributes
        result.SECTIONS = self.SECTIONS[:]
        result.section = self.section
        result.position = self.position
        result.role = self.role
        result.description = self.description
        result.userid = self.userid
        result.version = self.version
        result.verbose = self.verbose
        result.printflag = self.printflag

        return result

    def createEmptyVariables(self, vars):
        &#34;&#34;&#34;
        Creates empty variables in DEFINITIONS if they don&#39;t already exist.

        Parameters:
        -----------
        vars : str or list of str
            The variable name or list of variable names to be created in DEFINITIONS.
        &#34;&#34;&#34;
        if isinstance(vars, str):
            vars = [vars]  # Convert single variable name to list for uniform processing
        for varname in vars:
            if varname not in self.DEFINITIONS:
                self.DEFINITIONS.setattr(varname,&#34;${&#34; + varname + &#34;}&#34;)


    def do(self, printflag=None, verbose=None, softrun=False, return_definitions=False,comment_chars=&#34;#%&#34;, **USER):
        &#34;&#34;&#34;
        Executes or previews all `ScriptTemplate` instances in `TEMPLATE`, concatenating their processed content.
        Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with `softrun`.
        Accumulates definitions across all templates if `return_definitions=True`.

        Parameters
        ----------
        printflag : bool, optional
            If `True`, enables print output during execution. Defaults to the instance&#39;s print flag if `None`.
        verbose : bool, optional
            If `True`, includes headers and footers in the output, providing additional detail.
            Defaults to the instance&#39;s verbosity setting if `None`.
        softrun : bool, optional
            If `True`, executes the script in a preliminary mode:
            - Bypasses full variable substitution for a preview of the content, useful for validating structure.
            - If `False` (default), performs full processing, including variable substitutions and evaluations.
        return_definitions : bool, optional
            If `True`, returns a tuple where the second element contains accumulated definitions from all templates.
            If `False` (default), returns only the concatenated output.
        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.
        **USER : keyword arguments
            Allows for the provision of additional user-defined definitions, where each keyword represents a
            definition key and the associated value represents the definition&#39;s content. These definitions
            can override or supplement template-level definitions during execution.

        Returns
        -------
        str or tuple
            - If `return_definitions=False`, returns the concatenated output of all `ScriptTemplate` instances,
              with optional headers, footers, and execution summary based on verbosity.
            - If `return_definitions=True`, returns a tuple of (`output`, `accumulated_definitions`), where
              `accumulated_definitions` contains all definitions used across templates.

        Notes
        -----
        - Each `ScriptTemplate` in `TEMPLATE` is processed individually using its own `do()` method.
        - The `softrun` mode provides a preliminary content preview without full variable substitution,
          helpful for inspecting the script structure or gathering local definitions.
        - When `verbose` is enabled, the method includes detailed headers, footers, and a summary of processed and
          ignored items, providing insight into the script&#39;s construction and variable usage.
        - Accumulated definitions from each `ScriptTemplate` are combined if `return_definitions=True`, which can be
          useful for tracking all variables and definitions applied across the templates.

        Example
        -------
        &gt;&gt;&gt; dscript_instance = dscript(name=&#34;ExampleScript&#34;)
        &gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
        ...     content=[&#34;units ${units}&#34;, &#34;boundary ${boundary}&#34;],
        ...     definitions=lambdaScriptdata(units=&#34;lj&#34;, boundary=&#34;p p p&#34;),
        ...     attributes={&#39;eval&#39;: True}
        ... )
        &gt;&gt;&gt; dscript_instance.do(verbose=True, units=&#34;real&#34;)
        # Output:
        # --------------
        # TEMPLATE &#34;ExampleScript&#34;
        # --------------
        units real
        boundary p p p
        # ---&gt; Total items: 2 - Ignored items: 0
        &#34;&#34;&#34;

        printflag = self.printflag if printflag is None else printflag
        verbose = self.verbose if verbose is None else verbose
        header = f&#34;# --------------[ TEMPLATE \&#34;{self.name}\&#34; ]--------------&#34; if verbose else &#34;&#34;
        footer = &#34;# --------------------------------------------&#34; if verbose else &#34;&#34;

        # Initialize output, counters, and optional definitions accumulator
        output = [header]
        non_empty_lines = 0
        ignored_lines = 0
        accumulated_definitions = self.DEFINITIONS if return_definitions else None

        for key, template in self.TEMPLATE.items():
            # Process each template with softrun if enabled, otherwise use full processing
            result = template.do(softrun=softrun,globaldefinitions=self.DEFINITIONS,USER=lambdaScriptdata(**USER))
            if result:
                # Apply comment removal based on verbosity
                final_result = result if verbose else remove_comments(result,comment_chars=comment_chars)
                if final_result or verbose:
                    output.append(final_result)
                    non_empty_lines += 1
                else:
                    ignored_lines += 1
                # Accumulate definitions if return_definitions is enabled
                if return_definitions:
                    accumulated_definitions += template.definitions
            else:
                ignored_lines += 1

        # Add footer summary if verbose
        nel_word = &#39;items&#39; if non_empty_lines &gt; 1 else &#39;item&#39;
        il_word = &#39;items&#39; if ignored_lines &gt; 1 else &#39;item&#39;
        footer += f&#34;\n# ---&gt; Total {nel_word}: {non_empty_lines} - Ignored {il_word}: {ignored_lines}&#34; if verbose else &#34;&#34;
        output.append(footer)

        # Concatenate output and determine return type based on return_definitions
        output_content = &#34;\n&#34;.join(output)
        return (output_content, accumulated_definitions) if return_definitions else output_content



    def script(self,printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        returns the corresponding script
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        return lamdaScript(self,persistentfile=True, persistentfolder=None,
                           printflag=printflag, verbose=verbose,
                           **USER)

    def pipescript(self, *keys, printflag=None, verbose=None, verbosity=None, **USER):
        &#34;&#34;&#34;
        Returns a pipescript object by combining script objects corresponding to the given keys.

        Parameters:
        -----------
        *keys : one or more keys that correspond to the `TEMPLATE` entries.
        printflag : bool, optional
            Whether to enable printing of additional information.
        verbose : bool, optional
            Whether to run in verbose mode for debugging or detailed output.
        **USER : dict, optional
            Additional user-defined variables to pass into the script.

        Returns:
        --------
        A `pipescript` object that combines the script objects generated from the selected
        dscript subobjects.
        &#34;&#34;&#34;
        # Start with an empty pipescript
        # combined_pipescript = None
        # # Iterate over the provided keys to extract corresponding subobjects
        # for key in keys:
        #     # Extract the dscript subobject for the given key
        #     sub_dscript = self(key)
        #     # Convert the dscript subobject to a script object, passing USER, printflag, and verbose
        #     script_obj = sub_dscript.script(printflag=printflag, verbose=verbose, **USER)
        #     # Combine script objects into a pipescript object
        #     if combined_pipescript is None:
        #         combined_pipescript = pipescript(script_obj)  # Initialize pipescript
        #     else:
        #         combined_pipescript = combined_pipescript | script_obj  # Use pipe operator
        # if combined_pipescript is None:
        #     ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        # return combined_pipescript
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Loop over all keys in TEMPLATE and combine them
        combined_pipescript = None
        localvariables = scriptdata()
        for key in self.keys():
            # Create a new dscript object with only the current key in TEMPLATE
            focused_dscript = dscript(name=f&#34;{self.name}:{key}&#34;)
            focused_dscript.TEMPLATE[key] = self.TEMPLATE[key]
            localvariables = localvariables+scriptdata(**self.TEMPLATE[key].definitions)
            focused_dscript.TEMPLATE[key].definitions = localvariables
            focused_dscript.DEFINITIONS = scriptdata(**self.DEFINITIONS)
            focused_dscript.SECTIONS = self.SECTIONS[:]
            focused_dscript.section = self.section
            focused_dscript.position = self.position
            focused_dscript.role = self.role
            focused_dscript.description = self.description
            focused_dscript.userid = self.userid
            focused_dscript.version = self.version
            focused_dscript.verbose = verbose
            focused_dscript.printflag = printflag

            # Convert the focused dscript object to a script object
            script_obj = focused_dscript.script(printflag=printflag, verbose=verbose, **USER)

            # Combine the script objects into a pipescript object using the pipe operator
            if combined_pipescript is None:
                combined_pipescript = pipescript(script_obj)  # Initialize pipescript
            else:
                combined_pipescript = combined_pipescript | pipescript(script_obj)  # Use pipe operator

        if combined_pipescript is None:
            ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
        return combined_pipescript


    @staticmethod
    def header(name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None):
        &#34;&#34;&#34;
        Generate a formatted header for the DSCRIPT file.

        ### Parameters:
            name (str, optional): The name of the script. If None, &#34;Unnamed&#34; is used.
            verbose (bool, optional): Whether to include the header. Default is True.
            verbosity (int, optional): Verbosity level. Overrides `verbose` if specified.
            style (int, optional): ASCII style for the header (default=2).
            filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
            version (str, optional): DSCRIPT version. If None, it is omitted from the header.
            license (str, optional): License type. If None, it is omitted from the header.
            email (str, optional): Contact email. If None, it is omitted from the header.

        ### Returns:
            str: A formatted string representing the script&#39;s metadata and initialization details.
                 Returns an empty string if `verbose` is False.

        ### The header includes:
            - DSCRIPT version, license, and contact email, if provided.
            - The name of the script.
            - Filepath, if provided.
            - Information on where and when the script was generated.

        ### Notes:
            - If `verbosity` is specified, it overrides `verbose`.
            - Omits metadata lines if `version`, `license`, or `email` are not provided.
        &#34;&#34;&#34;
        # Resolve verbosity
        verbose = verbosity &gt; 0 if verbosity is not None else verbose
        if not verbose:
            return &#34;&#34;
        # Validate inputs
        if name is None:
            name = &#34;Unnamed&#34;
        # Prepare metadata line
        metadata = []
        if version:
            metadata.append(f&#34;v{version}&#34;)
        if license:
            metadata.append(f&#34;License: {license}&#34;)
        if email:
            metadata.append(f&#34;Email: {email}&#34;)
        metadata_line = &#34; | &#34;.join(metadata)
        # Prepare the framed header content
        lines = []
        if metadata_line:
            lines.append(f&#34;PIZZA.DSCRIPT FILE {metadata_line}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Name: {name}&#34;,
        ]
        # Add the filepath line if filepath is not None
        if filepath:
            lines.append(f&#34;Path: {filepath}&#34;)
        lines += [
            &#34;&#34;,
            f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
            f&#34;{datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
        ]
        # Use the shared frame_header function to format the framed content
        return frame_header(lines, style=style)



    # Generator
    # -----------
    def generator(self):
        &#34;&#34;&#34;
        Returns
        -------
        STR
            generated code corresponding to dscript (using dscript syntax/language).

        &#34;&#34;&#34;
        return self.save(generatoronly=True)


    # Information on variables
    # ------------------------
    def var_info(self):
        &#34;&#34;&#34;
        Analyze and gather comprehensive information about variables used in the script.

        This method performs a sophisticated analysis of both global and local variables within
        the script. It identifies variable usage, overrides, defaults, and counts the number of
        different values each variable holds across various templates.

        The analysis considers two scopes:
        - **Global:** Variables defined in the global definitions (`self.DEFINITIONS`).
        - **Local:** Variables defined within each template&#39;s definitions.

        Returns:
            dict: A dictionary named `varnfo` where each key is a variable name and the value is
                  another dictionary containing detailed information about that variable. The structure
                  of `varnfo` is as follows:

                  {
                      &#34;variable_name&#34;: {
                          &#34;value&#34;: &lt;initial_value_from_global&gt;,
                          &#34;updatedvalue&#34;: &lt;current_value_after_overrides&gt;,
                          &#34;is_default&#34;: &lt;bool&gt;,
                          &#34;first_def&#34;: &lt;template_index_or_None&gt;,
                          &#34;first_use&#34;: &lt;template_index&gt;,
                          &#34;first_val&#34;: &lt;value_at_first_use&gt;,
                          &#34;override_index&#34;: &lt;template_index_or_None&gt;,
                          &#34;is_global&#34;: &lt;bool&gt;,
                          &#34;value_counter&#34;: &lt;int&gt;
                          etc.
                      },
                      ...
                  }

                  **Field Descriptions:**
                  - `value`: Initial value of the variable from global definitions (if applicable).
                  - `updatedvalue`: Current value after any overrides in local templates.
                  - `is_default`: Indicates if the variable is set to a default value.
                  - `first_def`: The index of the first template where the variable is defined locally.
                  - `first_use`: The index of the first template where the variable is used.
                  - `first_val`: The value of the variable at its first use.
                  - `override_index`: The index of the template where the variable was overridden (if any).
                  - `is_autodef`: Flag, True if ${variable} is defined automatically as ${variable}
                  - `is_empty`: Flag,  True if the variable is empty (None,&#34;&#34;,[], etc.)
                  - `is_global`: Indicates if the variable originates from global definitions.
                  - `value_counter`: Counts the number of different values the variable has across templates.
                  - `first_use_isglobal` : Flag, True if the global value is used at first use
                  - `set_in`: Lists all template indices values where the variable is assigned/changed,
                  - `set_as`: Lists assigned values as reported in `set_in`,
                  - `values`: Lists variable changes (template index, refvalue),
                  - `used_in`: Lists template indices where the variable is used

        Raises:
            AttributeError: If `self.DEFINITIONS` does not have the specified key.
        &#34;&#34;&#34;

        start_time = time.time()  # Start the timer

        # Initialize definitions with self.DEFINITIONS
        allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        varnfo = {}

        # Loop over each template item to detect and record variable usage and overrides
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Detect variables used in this template
            used_variables = script_template.detect_variables()

            # Check each variable used in this template
            for var in used_variables:
                # Get global and local values for the variable
                global_value = getattr(allvars, var, None)
                local_value = getattr(script_template.definitions, var, None)
                is_autodef = global_value == f&#34;${{{var}}}&#34;
                is_global = var in allvars  # Check if the variable originates in global space
                is_empty = global_value in (None,&#34;&#34;,[],[&#34;&#34;])
                is_default = is_global and (is_empty or is_autodef)

                # If the variable is not yet tracked, initialize its info
                if var not in varnfo:
                    initialcounter = 1 if local_value is None or local_value==global_value else 2
                    first_use_isglobal = initialcounter==1
                    refvalue = global_value if first_use_isglobal else local_value
                    override_index = template_index if ((local_value is not None) and not first_use_isglobal and not is_default) else None
                    varnfo[var] = {
                        &#34;value&#34;: refvalue,        # Initial value from allvars if exists
                        &#34;updatedvalue&#34;: refvalue, # Initial value from allvars if exists
                        &#34;is_default&#34;: is_default,     # Check if its set to a default value
                        &#34;first_def&#34;: None,            # First definition (to be updated later)
                        &#34;first_use&#34;: template_index,  # First time the variable is used
                        &#34;first_val&#34;: refvalue,        # First value
                        &#34;override_index&#34;: override_index,  # Set override if defined locally
                        &#34;is_autodef&#34;: is_autodef,     # automatic definition ${variable}
                        &#34;is_empty&#34;: is_empty,         # Track if the variable is empty (None,&#34;&#34;,[], etc.)
                        &#34;is_global&#34;: is_global,       # Track if the variable originates as global
                        &#34;value_counter&#34;: initialcounter, # Count the number of different values
                        &#34;first_use_isglobal&#34;: first_use_isglobal, # True if the global value is used at first use
                        &#34;set_in&#34;: [template_index],
                        &#34;set_as&#34;: [refvalue],
                        &#34;values&#34;:[(template_index, refvalue)],
                        &#34;used_in&#34;: [template_index]
                    }
                else:
                    # Update `override_index` if the variable is defined locally and its value changes
                    varnfo[var][&#34;used_in&#34;].append(template_index)
                    if local_value is not None:
                        # Check if the local value differs from the tracked value in varnfo
                        current_value = varnfo[var][&#34;updatedvalue&#34;] # varnfo[var][&#34;value&#34;]
                        if current_value != local_value:
                            varnfo[var][&#34;override_index&#34;] = template_index
                            varnfo[var][&#34;updatedvalue&#34;] = local_value  # Update the tracked value
                            varnfo[var][&#34;value_counter&#34;] += 1
                            varnfo[var][&#34;set_in&#34;].append(template_index)
                            varnfo[var][&#34;set_as&#34;].append(local_value)
                            varnfo[var][&#34;values&#34;].append((template_index, local_value))

        # Second loop: Update `first_def` for all variables
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            local_definitions = script_template.definitions.keys()
            for var in local_definitions:
                if var in varnfo and varnfo[var][&#34;first_def&#34;] is None:
                    varnfo[var][&#34;first_def&#34;] = template_index
                    varnfo[var][&#34;first_val&#34;] = getattr(script_template.definitions, var)

        execution_time = time.time() - start_time  # Calculate the execution time in seconds

        if self.verbose:
            print(f&#34;Variable analysis completed in {execution_time:.4f} seconds.&#34;)

        return varnfo


    def print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
        &#34;&#34;&#34;
        Print or save a neatly formatted table of variable information based on the analysis from `var_info()`.

        This method retrieves variable information using the `var_info()` method and presents it in a
        Markdown-compatible table or an HTML table. Users can choose to display information for all variables
        or a specific subset by providing a list of variable names. Additionally, users can opt to save the
        table to a file with options to control file extension, path validity, and overwrite behavior.

        Parameters
        ----------
        what : str or list of str, optional
            Specifies which variables&#39; information to print.
            - If set to &#39;all&#39; (default), information for all variables is displayed.
            - If set to a list of variable names, only those variables are displayed.

        output_file : str, optional
            The path to the file where the table will be saved.
            - If set to `None` (default), the table is printed to the console.
            - If a file path is provided, the table is saved to the specified file.

        overwrite : bool, default=False
            Determines whether to overwrite the file if it already exists.
            - If `False` and the file exists, a `FileExistsError` is raised.
            - If `True`, the existing file is overwritten.

        Raises
        ------
        ValueError
            - If `what` is neither `&#39;all&#39;` nor a list of strings.
            - If the file extension is neither `.md`, `.txt`, nor `.html`.
        FileNotFoundError
            If the specified directory in `output_file` does not exist.
        PermissionError
            If the specified path is not writable.
        FileExistsError
            If the file exists and `overwrite` is set to `False`.
        IOError
            If an error occurs during file writing.
        &#34;&#34;&#34;
        # Retrieve the variable information dictionary
        varnfo = self.var_info()

        # Determine which variables to display
        if what == &#39;all&#39;:
            variables_to_print = list(varnfo.keys())
        elif isinstance(what, list):
            # Ensure all items in the list are strings
            if not all(isinstance(var, str) for var in what):
                raise ValueError(&#34;All items in the &#39;what&#39; list must be strings representing variable names.&#34;)
            variables_to_print = what
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be either &#39;all&#39; or a list of variable names.&#34;)

        # Filter out variables that are not present in varnfo
        missing_vars = [var for var in variables_to_print if var not in varnfo]
        if missing_vars:
            print(f&#34;Warning: The following variables were not found and will be skipped: {missing_vars}&#34;)
            # Remove missing variables from the list
            variables_to_print = [var for var in variables_to_print if var in varnfo]

        if not variables_to_print:
            print(&#34;No variables to display.&#34;)
            return

        # Define the headers based on varnfo fields
        headers = [
            &#34;Variable Name&#34;,
            &#34;Value&#34;,
            &#34;Updated Value&#34;,
            &#34;Is Default&#34;,
            &#34;First Def&#34;,
            &#34;First Use&#34;,
            &#34;First Val&#34;,
            &#34;Override Index&#34;,
            &#34;Is Autodef&#34;,
            &#34;Is Empty&#34;,
            &#34;Is Global&#34;,
            &#34;Value Counter&#34;,
            &#34;First Use IsGlobal&#34;,
            &#34;Set In&#34;,
            &#34;Set As&#34;,
            &#34;Values&#34;,
            &#34;Used In&#34;
        ]

        # Initialize a list to hold all rows
        table_rows = []

        # Populate the table rows with variable information
        for var in variables_to_print:
            info = varnfo[var]
            row = [
                var,
                self._format_field(info.get(&#34;value&#34;)),
                self._format_field(info.get(&#34;updatedvalue&#34;)),
                self._format_field(info.get(&#34;is_default&#34;)),
                self._format_field(info.get(&#34;first_def&#34;)),
                self._format_field(info.get(&#34;first_use&#34;)),
                self._format_field(info.get(&#34;first_val&#34;)),
                self._format_field(info.get(&#34;override_index&#34;)),
                self._format_field(info.get(&#34;is_autodef&#34;)),
                self._format_field(info.get(&#34;is_empty&#34;)),
                self._format_field(info.get(&#34;is_global&#34;)),
                self._format_field(info.get(&#34;value_counter&#34;)),
                self._format_field(info.get(&#34;first_use_isglobal&#34;)),
                self._format_list(info.get(&#34;set_in&#34;)),
                self._format_list(info.get(&#34;set_as&#34;)),
                self._format_values(info.get(&#34;values&#34;)),
                self._format_list(info.get(&#34;used_in&#34;))
            ]
            table_rows.append(row)

        # Calculate the maximum width for each column
        column_widths = [len(header) for header in headers]
        for row in table_rows:
            for idx, cell in enumerate(row):
                cell_length = len(str(cell))
                if cell_length &gt; column_widths[idx]:
                    column_widths[idx] = cell_length

        # Build the Markdown table
        # Header row
        header_row = &#34;| &#34; + &#34; | &#34;.join(f&#34;{header.ljust(column_widths[idx])}&#34; for idx, header in enumerate(headers)) + &#34; |&#34;
        # Separator row
        separator_row = &#34;|-&#34; + &#34;-|-&#34;.join(&#39;-&#39; * column_widths[idx] for idx in range(len(headers))) + &#34;-|&#34;
        # Data rows
        data_rows = [
            &#34;| &#34; + &#34; | &#34;.join(f&#34;{str(cell).ljust(column_widths[idx])}&#34; for idx, cell in enumerate(row)) + &#34; |&#34;
            for row in table_rows
        ]

        # Combine all parts for Markdown
        markdown_table = &#34;\n&#34;.join([header_row, separator_row] + data_rows)

        # Generate HTML table if needed
        html_table = None
        if output_file:
            _, file_extension = os.path.splitext(output_file)
            file_extension = file_extension.lower()

            if file_extension not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;, &#39;&#39;]:
                raise ValueError(&#34;File extension must be either &#39;.md&#39;, &#39;.txt&#39;, or &#39;.html&#39;.&#34;)

            if file_extension == &#39;&#39;:
                # Default to .md
                output_file += &#39;.md&#39;
                file_extension = &#39;.md&#39;

            # Extract directory from the output_file path
            directory = os.path.dirname(os.path.abspath(output_file))
            if directory and not os.path.exists(directory):
                raise FileNotFoundError(f&#34;The directory &#39;{directory}&#39; does not exist.&#34;)

            if directory and not os.access(directory, os.W_OK):
                raise PermissionError(f&#34;The directory &#39;{directory}&#39; is not writable.&#34;)

            # Check if the file exists
            if os.path.exists(output_file) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{output_file}&#39; already exists and overwrite is set to False.&#34;)

            # Prepare title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;

            if file_extension == &#39;.html&#39;:
                # Build HTML table with embedded CSS
                html_table = self._build_html_table(headers, table_rows, column_widths, title, subtitle)
            else:
                # For Markdown and TXT, prepare content with title and timestamp
                content = f&#34;# {title}\n\n&#34;
                content += f&#34;**{subtitle}**\n\n&#34;
                content += markdown_table + &#34;\n&#34;

        # If output_file is not specified, print to console
        if output_file is None:
            # Print title and timestamp
            timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
            title = f&#34;{self.name} - Variable Information&#34;
            subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;
            print(f&#34;### {title}\n&#34;)
            print(f&#34;**{subtitle}**\n&#34;)
            # Print the Markdown table
            print(markdown_table)
        else:
            # Save to file based on extension
            try:
                if file_extension in [&#39;.md&#39;, &#39;.txt&#39;]:
                    # Prepare content with title and timestamp
                    content = f&#34;# {title}\n\n&#34;
                    content += f&#34;**{subtitle}**\n\n&#34;
                    content += markdown_table + &#34;\n&#34;

                    # Write to file
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(content)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
                elif file_extension == &#39;.html&#39;:
                    # Write HTML content
                    with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                        f.write(html_table)
                    print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
            except IOError as e:
                raise IOError(f&#34;An error occurred while writing to the file: {e}&#34;)

    def _build_html_table(self, headers, table_rows, column_widths, title, subtitle):
        &#34;&#34;&#34;
        Helper method to build an HTML table with embedded CSS.

        Parameters
        ----------
        headers : list of str
            The table headers.
        table_rows : list of list
            The table data rows.
        column_widths : list of int
            The maximum width for each column.
        title : str
            The title of the table.
        subtitle : str
            The subtitle containing timestamp and user information.

        Returns
        -------
        str
            The complete HTML content as a string.
        &#34;&#34;&#34;
        # Define CSS styles for the HTML table
        css_styles = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1 {
                text-align: center;
            }
            h2 {
                text-align: center;
                color: gray;
            }
            .table-container {
                overflow-x: auto;
                max-height: 2400px;
                overflow-y: auto;
                border: 1px solid #ddd;
                padding: 10px;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                table-layout: fixed;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                word-wrap: break-word;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
            th {
                padding-top: 12px;
                padding-bottom: 12px;
                text-align: left;
                background-color: #4CAF50;
                color: white;
            }
        &lt;/style&gt;
        &#34;&#34;&#34;

        # Start building HTML content
        html_content = f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;{title}&lt;/title&gt;\n{css_styles}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;

        # Add title and subtitle
        html_content += f&#34;&lt;h1&gt;{title}&lt;/h1&gt;\n&#34;
        html_content += f&#34;&lt;h2&gt;{subtitle}&lt;/h2&gt;\n&#34;

        # Add table container
        html_content += &#34;&lt;div class=&#39;table-container&#39;&gt;\n&#34;

        # Start table
        html_content += &#34;&lt;table&gt;\n&#34;

        # Header row
        html_content += &#34;  &lt;tr&gt;\n&#34;
        for header in headers:
            html_content += f&#34;    &lt;th&gt;{header}&lt;/th&gt;\n&#34;
        html_content += &#34;  &lt;/tr&gt;\n&#34;

        # Data rows
        for row in table_rows:
            html_content += &#34;  &lt;tr&gt;\n&#34;
            for cell in row:
                html_content += f&#34;    &lt;td&gt;{self._escape_html(str(cell))}&lt;/td&gt;\n&#34;
            html_content += &#34;  &lt;/tr&gt;\n&#34;

        # End table and container
        html_content += &#34;&lt;/table&gt;\n&lt;/div&gt;\n&#34;

        # End body and html
        html_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        return html_content

    def _escape_html(self, text):
        &#34;&#34;&#34;
        Helper method to escape HTML special characters in text.

        Parameters
        ----------
        text : str
            The text to escape.

        Returns
        -------
        str
            The escaped text.
        &#34;&#34;&#34;
        import html
        return html.escape(text)

    def _format_field(self, field):
        &#34;&#34;&#34;
        Helper method to format individual fields for the table.

        Parameters
        ----------
        field : Any
            The field value to format.

        Returns
        -------
        str
            The formatted string representation of the field.
        &#34;&#34;&#34;
        if field is None:
            return &#34;None&#34;
        elif isinstance(field, bool):
            return &#34;True&#34; if field else &#34;False&#34;
        else:
            return str(field)

    def _format_list(self, lst):
        &#34;&#34;&#34;
        Helper method to format list-type fields for the table.

        Parameters
        ----------
        lst : list or None
            The list to format.

        Returns
        -------
        str
            Comma-separated string of list items or an empty string if the list is None or empty.
        &#34;&#34;&#34;
        if not lst:
            return &#34;&#34;
        return &#34;, &#34;.join(str(item) for item in lst)

    def _format_values(self, values):
        &#34;&#34;&#34;
        Helper method to format the &#39;values&#39; field, which is a list of tuples.

        Parameters
        ----------
        values : list of tuples or None
            The list of (template_index, value) tuples.

        Returns
        -------
        str
            Comma-separated string of &#34;template_index: value&#34; pairs or an empty string if None or empty.
        &#34;&#34;&#34;
        if not values:
            return &#34;&#34;
        return &#34;, &#34;.join(f&#34;{idx}: {val}&#34; for idx, val in values)

    # ... [Other existing methods] ...



    # Save Method
    # -----------
    def save(self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True):
        &#34;&#34;&#34;
        Save the current script instance to a text file.

        Parameters
        ----------
        filename : str, optional
            The name of the file to save the script to. If not provided, `self.name` is used.
            The extension &#34;.txt&#34; is automatically appended if not included.

        foldername : str, optional
            The directory where the file will be saved. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        overwrite : bool, default=True
            Whether to overwrite the file if it already exists. If set to False, an exception is raised
            if the file exists.

        generatoronly : bool, default=False
            If True, the method returns the generated content string without saving to a file.

        onlyusedvariables : bool, default=True
            If True, local definitions are only saved if they are used within the template content.
            If False, all local definitions are saved, regardless of whether they are referenced in
            the template.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - The script is saved in a plain text format, and each section (global parameters, definitions,
          template, and attributes) is written in a structured format with appropriate comments.
        - If `self.name` is used as the filename, it must be a valid string that can serve as a file name.
        - The file structure follows the format:
            # DSCRIPT SAVE FILE
            # generated on YYYY-MM-DD on user@hostname

            # GLOBAL PARAMETERS
            { ... }

            # DEFINITIONS (number of definitions=...)
            key=value

            # TEMPLATES (number of items=...)
            key: template_content

            # ATTRIBUTES (number of items with explicit attributes=...)
            key:{attr1=value1, attr2=value2, ...}
        &#34;&#34;&#34;
        # At the beginning of the save method
        start_time = time.time()  # Start the timer

        if not generatoronly:
            # Use self.name if filename is not provided
            if filename is None:
                filename = span(self.name, sep=&#34;\n&#34;)

            # Ensure the filename ends with &#39;.txt&#39;
            if not filename.endswith(&#39;.txt&#39;):
                filename += &#39;.txt&#39;

            # Construct the full path
            if foldername in [None, &#34;&#34;]:  # Handle cases where foldername is None or an empty string
                filepath = os.path.abspath(filename)
            else:
                filepath = os.path.join(foldername, filename)

            # Check if the file already exists, and raise an exception if it does and overwrite is False
            if os.path.exists(filepath) and not overwrite:
                raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Header with current date, username, and host
        header = &#34;# DSCRIPT SAVE FILE\n&#34;
        header += &#34;\n&#34;*2
        if generatoronly:
            header += dscript.header(verbose=True,filepath=&#39;dynamic code generation (no file)&#39;,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        else:
            header += dscript.header(verbose=True,filepath=filepath,
                                     name = self.name, version=self.version, license=self.license, email=self.email)
        header += &#34;\n&#34;*2

        # Global parameters in strict Python syntax
        global_params = &#34;# GLOBAL PARAMETERS (8 parameters)\n&#34;
        global_params += &#34;{\n&#34;
        global_params += f&#34;    SECTIONS = {self.SECTIONS},\n&#34;
        global_params += f&#34;    section = {self.section},\n&#34;
        global_params += f&#34;    position = {self.position},\n&#34;
        global_params += f&#34;    role = {self.role!r},\n&#34;
        global_params += f&#34;    description = {self.description!r},\n&#34;
        global_params += f&#34;    userid = {self.userid!r},\n&#34;
        global_params += f&#34;    version = {self.version},\n&#34;
        global_params += f&#34;    verbose = {self.verbose}\n&#34;
        global_params += &#34;}\n&#34;

        # Initialize definitions with self.DEFINITIONS
        #allvars = self.DEFINITIONS

        # Temporary dictionary to track global variable information
        vinfo = self.var_info()

        # Filter global definitions based on usage, overrides, and first_def
        #  and info[&#34;is_default&#34;]
        filtered_globals = {
            var: info for var, info in vinfo.items()
            if ((info[&#34;is_global&#34;]and not info[&#34;is_empty&#34;]) and (info[&#34;first_use_isglobal&#34;]) and (info[&#34;override_index&#34;] is None))
            }

        # Generate the definitions output based on filtered globals
        definitions = f&#34;\n# GLOBAL DEFINITIONS (number of definitions={len(filtered_globals)})\n&#34;
        for var, info in filtered_globals.items():
            if info[&#34;is_default&#34;] and (info[&#34;first_def&#34;]&gt;info[&#34;first_use&#34;] if info[&#34;first_def&#34;] else True):
                definitions += f&#34;{var} = ${{{var}}}  # value assumed to be defined outside this DSCRIPT file\n&#34;
            else:
                value = info[&#34;first_val&#34;]   #info[&#34;value&#34;]
                if info[&#34;is_empty&#34;]:        #value in [&#34;&#34;, None]
                    definitions += f&#39;{var} = &#34;&#34;\n&#39;
                elif isinstance(value, str):
                    safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                    definitions += f&#34;{var} = {safe_value}\n&#34;
                else:
                    definitions += f&#34;{var} = {value}\n&#34;

        # Template (number of lines/items)
        printsinglecontent = False
        template = f&#34;\n# TEMPLATES (number of items={len(self.TEMPLATE)})\n&#34;
        #for key, script_template in self.TEMPLATE.items():
        for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
            # Get local template definitions and detected variables
            template_vars = script_template.definitions
            used_variables = script_template.detect_variables()
            islocal = False
            # Temporary dictionary to accumulate variables to add to allvars
            valid_local_vars = lambdaScriptdata()
            # Write template-specific definitions only if they meet the updated conditions
            for var in template_vars.keys():
                # Conditions for adding a variable to the local template and to `allvars`
                if (var in used_variables or not onlyusedvariables) \
                   and (template_index in vinfo[var][&#34;set_in&#34;]) \
                   and (var not in filtered_globals):
                # if (var in used_variables or not onlyusedvariables) and (
                #    script_template.is_variable_set_value_only(var) and
                #    (var not in allvars or getattr(template_vars, var) != getattr(allvars, var))
                #):
                    # Start local definitions section if this is the first local variable for the template
                    if not islocal:
                        template += f&#34;\n# LOCAL DEFINITIONS for key &#39;{key}&#39;\n&#34;
                        islocal = True
                    # Retrieve and process the variable value
                    # value = getattr(template_vars, var)
                    value = next((ref for idx, ref in vinfo[var][&#34;values&#34;] if idx == template_index), None)
                    if value in [&#34;&#34;, None]:
                        template += f&#39;{var} = &#34;&#34;\n&#39;  # Set empty or None values as &#34;&#34;
                    elif isinstance(value, str):
                        safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                        template += f&#34;{var} = {safe_value}\n&#34;
                    else:
                        template += f&#34;{var} = {value}\n&#34;
                    # Add the variable to valid_local_vars for selective update of allvars
                    valid_local_vars.setattr(var, value)
            # Update allvars only with filtered, valid local variables
            # allvars += valid_local_vars

            # Write the template content
            if isinstance(script_template.content, list):
                if len(script_template.content) == 1:
                    # Single-line template saved as a single line
                    content_str = script_template.content[0].strip()
                    template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                    template += f&#34;{key}: {content_str}\n&#34;
                    printsinglecontent = True
                else:
                    content_str = &#39;\n    &#39;.join(script_template.content)
                    template += f&#34;\n{key}: [\n    {content_str}\n ]\n&#34;
                    printsinglecontent = False
            else:
                template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                template += f&#34;{key}: {script_template.content}\n&#34;
                printsinglecontent = True

        # Attributes (number of lines/items with explicit attributes)
        attributes = f&#34;# ATTRIBUTES (number of items with explicit attributes={len(self.TEMPLATE)})\n&#34;
        for key, script_template in self.TEMPLATE.items():
            attr_str = &#34;, &#34;.join(f&#34;{attr_name}={repr(attr_value)}&#34;
                                 for attr_name, attr_value in script_template.attributes.items())
            attributes += f&#34;{key}:{{{attr_str}}}\n&#34;

        # Combine all sections into one content
        content = header + &#34;\n&#34; + global_params + &#34;\n&#34; + definitions + &#34;\n&#34; + template + &#34;\n&#34; + attributes + &#34;\n&#34;


        # Append footer information to the content
        non_empty_lines = sum(1 for line in content.splitlines() if line.strip())  # Count non-empty lines
        execution_time = time.time() - start_time  # Calculate the execution time in seconds
        # Prepare the footer content
        footer_lines = [
            [&#34;Non-empty lines&#34;, str(non_empty_lines)],
            [&#34;Execution time (seconds)&#34;, f&#34;{execution_time:.4f}&#34;],
        ]
        # Format footer into tabular style
        footer_content = [
            f&#34;{row[0]:&lt;25} {row[1]:&lt;15}&#34; for row in footer_lines
        ]
        # Use frame_header to format footer
        footer = frame_header(
            lines=[&#34;DSCRIPT SAVE FILE generator&#34;] + footer_content,
            style=1
        )
        # Append footer to the content
        content += f&#34;\n{footer}&#34;

        if generatoronly:
            return content
        else:
            # Write the content to the file
            with open(filepath, &#39;w&#39;) as f:
                f.write(content)
            print(f&#34;\nScript saved to {filepath}&#34;)
            return filepath



    # Write Method -- added on 2024-09-05
    # ------------
    @staticmethod
    def write(scriptcontent, filename=None, foldername=None, overwrite=False):
        &#34;&#34;&#34;
        Writes the provided script content to a specified file in a given folder, with a header if necessary.

        Parameters
        ----------
        scriptcontent : str
            The content to be written to the file.

        filename : str, optional
            The name of the file. If not provided, a random name will be generated.
            The extension `.txt` will be appended if not already present.

        foldername : str, optional
            The folder where the file will be saved. If not provided, the current working directory is used.

        overwrite : bool, optional
            If False (default), raises a `FileExistsError` if the file already exists. If True, the file will be overwritten if it exists.

        Returns
        -------
        str
            The full path to the written file.

        Raises
        ------
        FileExistsError
            If the file already exists and `overwrite` is set to False.

        Notes
        -----
        - A header is prepended to the content if it does not already exist, using the `header` method.
        - The header includes metadata such as the current date, username, hostname, and file details.
        &#34;&#34;&#34;
        # Generate a random name if filename is not provided
        if filename is None:
            filename = autoname(8)  # Generates a random name of 8 letters

        # Ensure the filename ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        # Check if file already exists, raise exception if it does and overwrite is False
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

        # Count total and non-empty lines in the content
        total_lines = len(scriptcontent.splitlines())
        non_empty_lines = sum(1 for line in scriptcontent.splitlines() if line.strip())

        # Prepare header if not already present
        if not scriptcontent.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
            name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript&#34;
            metadata = get_metadata()           # retrieve all metadata (statically)
            header = dscript.header(name=name, verbosity=True,style=1,filepath=filepath,
                    version = metadata[&#34;version&#34;], license = metadata[&#34;license&#34;], email = metadata[&#34;email&#34;])
            # Add line count information to the header
            footer = frame_header(
                lines=[
                    f&#34;Total lines written: {total_lines}&#34;,
                    f&#34;Non-empty lines: {non_empty_lines}&#34;
                ],
                style=1
            )
            scriptcontent = header + &#34;\n&#34; + scriptcontent + &#34;\n&#34; + footer

        # Write the content to the file
        with open(filepath, &#39;w&#39;) as file:
            file.write(scriptcontent)
        return filepath



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def load(cls, filename, foldername=None, numerickeys=True, verbose=True, debug=False):
        &#34;&#34;&#34;
        Load a script instance from a text file.

        Parameters
        ----------
        filename : str
            The name of the file to load the script from. If the filename does not end with &#34;.txt&#34;,
            the extension is automatically appended.

        foldername : str, optional
            The directory where the file is located. If not provided, it defaults to the system&#39;s
            temporary directory. If the filename does not include a full path, this folder will be used.

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.
            For example, the key &#34;0&#34; would be converted into the integer 0.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        debug : bool, default=False
            If True, print parsed lines for refining/tracking the parsing of block and single lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If the file does not start with the correct DSCRIPT header or the file format is invalid.

        FileNotFoundError
            If the specified file does not exist.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.
        &#34;&#34;&#34;

        # Step 0 validate filepath
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Handle foldername and relative paths
        if foldername is None or foldername == &#34;&#34;:
            # If the foldername is empty or None, use current working directory for relative paths
            if not os.path.isabs(filename):
                filepath = os.path.join(os.getcwd(), filename)
            else:
                filepath = filename  # If filename is absolute, use it directly
        else:
            # If foldername is provided and filename is not absolute, use foldername
            if not os.path.isabs(filename):
                filepath = os.path.join(foldername, filename)
            else:
                filepath = filename

        if not os.path.exists(filepath):
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

        # Read the file contents
        with open(filepath, &#39;r&#39;) as f:
            content = f.read()

        # Call parsesyntax to parse the file content
        fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
        name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript
        return cls.parsesyntax(content, name=name, numerickeys=numerickeys, verbose=verbose, debug=debug)



    # Load Method and its Parsing Rules -- added on 2024-09-04
    # ---------------------------------
    @classmethod
    def parsesyntax(cls, content, name=None, numerickeys=True, verbose=False, authentification=True,
                    debug=False, comment_chars=&#34;#%&#34;,continuation_marker=&#34;...&#34;):
        &#34;&#34;&#34;
        Parse a DSCRIPT script from a string content.

        Parameters
        ----------
        content : str
            The string content of the DSCRIPT script to be parsed.

        name : str, optional
            The name of the dscript project. If `None`, a random name is generated.

        numerickeys : bool, default=True
            If `True`, numeric string keys in the template section are automatically converted into integers.

        verbose : bool, default=True
            If `True`, the parser keep comments inside templates and template blocks.

        authentification : bool, default=True
            If `True`, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

        comment_chars : str, optional (default: &#34;#%&#34;)
            A string containing characters to identify the start of a comment.
            Any of these characters will mark the beginning of a comment unless within quotes.

        continuation_marker : str, optional (default: &#34;...&#34;)
            A string containing characters to indicate line continuation
            Any characters after the continuation marker are considered comment and are theorefore ignored

        debug : bool, default=False
            Print parsed lines for refining the parsing of block lines

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        **DSCRIPT SAVE FILE FORMAT**

        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        **Mandatory First Line:**

        Every DSCRIPT file must begin with the following line:

        ```plaintext
        # DSCRIPT SAVE FILE
        ```

        **Structure Overview:**

        1. **Global Parameters Section (Optional):**

            - This section defines global script settings, enclosed within curly braces `{}`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            **Example:**

            ```plaintext
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**

            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            **Example:**

            ```plaintext
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]          # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**

            - This section provides a mapping between keys and their corresponding commands or instructions.
            - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
            - **Syntax Variations**:

                Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (`...`) as a line continuation marker.

                - **Single-line Template Without Block**:
                    ```plaintext
                    KEY: INSTRUCTION
                    ```
                    - `KEY` is the identifier for the template (numeric or alphanumeric).
                    - `INSTRUCTION` is the command or template text, which may reference variables.

                - **Single-line Template With Block**:
                    ```plaintext
                    KEY: [INSTRUCTION]
                    ```
                    - Uses square brackets (`[ ]`) around the `INSTRUCTION`, indicating that all instructions are part of the block.

                - **Multi-line Template With Block**:
                    ```plaintext
                    KEY: [
                        INSTRUCTION1
                        INSTRUCTION2
                        ...
                        ]
                    ```
                    - Begins with `KEY: [` and ends with a standalone `]` on a new line.
                    - Instructions within the block can span multiple lines, and ellipses (`...`) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
                    - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

                - **Multi-line Template With Continuation Marker (Ellipsis)**:
                    - For templates with complex code containing square brackets (`[ ]`), the ellipsis (`...`) can be used to prevent `]` from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

                    **Example:**
                    ```plaintext
                    example1: command ${value}       # Single-line template without block
                    example2: [command ${value}]     # Single-line template with block

                    # Multi-line template with block
                    example3: [
                        command1 ${var1}
                        command2 ${var2} ...   # Line continues after ellipsis
                        command3 ${var3} ...   # Additional instruction continues
                        ]

                    # Multi-line template with ellipsis (handling square brackets)
                    example4: [
                        A[0][1] ...            # Ellipsis allows [ ] within instructions
                        B[2][3] ...            # Another instruction in the block
                        ]
                    ```

            - **Key Points**:
                - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
                - **Ellipsis (`...`)** at the end of a line keeps the line open, preventing premature closing by `]`, especially useful if the template code includes square brackets (`[ ]`).
                - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

            This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


        4. **Attributes Section:**

            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            **Example:**

            ```plaintext
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        **Note on Multiple Definitions**

        This example demonstrates how variables defined in the **Definitions** section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        **Example:**

        ```plaintext
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template key1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an undefined variable ${var31}
            this is another undefined variable ${var32}
            this variable is defined  ${var}
        ]
        ```

        **Parsing and Usage:**

        ```python
        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Accessing templates and their variables
        print(ds.TEMPLATE[&#39;key1&#39;].text)  # Output: Template content with 10
        print(ds.TEMPLATE[&#39;key2&#39;].text)  # Output: Template content with 20
        ```

        **Handling Undefined Variables:**

        Variables like `${var31}` and `${var32}` in `key3` are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

        **Important Notes:**

        - The parser processes the script sequentially. Definitions must appear before the templates that use them.
        - Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
        - Comments outside of blocks are allowed and ignored by the parser.
        - Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).


    **Advanced Example**

        Here&#39;s a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

        ```python
        content = &#39;&#39;&#39;
            # GLOBAL DEFINITIONS
            dumpfile = $dump.LAMMPS
            dumpdt = 50
            thermodt = 100
            runtime = 5000

            # LOCAL DEFINITIONS for step &#39;0&#39;
            dimension = 3
            units = $si
            boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
            atom_style = $smd
            atom_modify = [&#39;map&#39;, &#39;array&#39;]
            comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
            neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
            newton = $off
            name = $SimulationBox

            # This is a comment line outside of blocks
            # ------------------------------------------

            0: [    % --------------[ Initialization Header (helper) for &#34;${name}&#34; ]--------------
                # set a parameter to None or &#34;&#34; to remove the definition
                dimension    ${dimension}
                units        ${units}
                boundary     ${boundary}
                atom_style   ${atom_style}
                atom_modify  ${atom_modify}
                comm_modify  ${comm_modify}
                neigh_modify ${neigh_modify}
                newton       ${newton}
                # ------------------------------------------
             ]
        &#39;&#39;&#39;
        # Parse the content
        ds = dscript.parsesyntax(content, verbose=True, authentification=False)

        # Access and print the rendered template
        print(&#34;Template 0 content:&#34;)
        print(ds.TEMPLATE[0].do())
        ```

        **Explanation:**

        - **Global Definitions:** Define variables that are accessible throughout the script.
        - **Local Definitions for Step &#39;0&#39;:** Define variables specific to a particular step or template.
        - **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
        - **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

        **Expected Output:**

        ```
        Template 0 content:
        # --------------[ Initialization Header (helper) for &#34;SimulationBox&#34; ]--------------
        # set a parameter to None or &#34;&#34; to remove the definition
        dimension    3
        units        si
        boundary     [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
        atom_style   smd
        atom_modify  [&#39;map&#39;, &#39;array&#39;]
        comm_modify  [&#39;vel&#39;, &#39;yes&#39;]
        neigh_modify [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
        newton       off
        # ------------------------------------------
        ```

        **Notes:**

        - The `do()` method renders the template, substituting variables with their defined values.
        - Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
        - The parser handles comments and blank lines appropriately, ensuring they don&#39;t interfere with the parsing logic.


        &#34;&#34;&#34;
        # Split the content into lines
        lines = content.splitlines()
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers
        global_params = {}
        GLOBALdefinitions = lambdaScriptdata()
        LOCALdefinitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables
        inside_global_params = False
        global_params_content = &#34;&#34;
        inside_template_block = False
        current_template_key = None
        current_template_content = []
        current_var_value = lambdaScriptdata()

        # Initialize line number
        line_number = 0
        last_successful_line = 0

        # Step 1: Authenticate the file
        if authentification:
            auth_line_found = False
            max_header_lines = 10
            header_end_idx = -1
            for idx, line in enumerate(lines[:max_header_lines]):
                stripped_line = line.strip()
                if not stripped_line:
                    continue
                if stripped_line.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
                    auth_line_found = True
                    header_end_idx = idx
                    break
                elif stripped_line.startswith(&#34;#&#34;) or stripped_line.startswith(&#34;%&#34;):
                    continue
                else:
                    raise ValueError(f&#34;Unexpected content before authentication line (# DSCRIPT SAVE FILE) at line {idx + 1}:\n{line}&#34;)
            if not auth_line_found:
                raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

            # Remove header lines
            lines = lines[header_end_idx + 1:]
            line_number = header_end_idx + 1
            last_successful_line = line_number - 1
        else:
            line_number = 0
            last_successful_line = 0

        # Process each line
        for idx, line in enumerate(lines):
            line_number += 1
            line_content = line.rstrip(&#39;\n&#39;)
            if debug: print(f&#34;RAW L{line_number}    :{line_content}\n&#34;)

            # Determine if we&#39;re inside a template block
            if inside_template_block:
                # Extract the code with its eventual continuation_marker
                code_line = remove_comments(
                        line_content,
                        comment_chars=comment_chars,
                        continuation_marker=continuation_marker,
                        remove_continuation_marker=False,
                        ).rstrip()

                # Check if line should continue
                if code_line.endswith(continuation_marker):
                    # Append line up to the continuation marker
                    endofline_index = line_content.rindex(continuation_marker)
                    trimmed_content = line_content[:endofline_index].rstrip()
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;A|DEBUG L{line_number}:{trimmed_content}\n&#34;)
                    continue
                elif code_line.endswith(&#34;]&#34;):  # End of multi-line block
                    closing_index = code_line.rindex(&#39;]&#39;)
                    trimmed_content = code_line[:closing_index].rstrip()

                    # Append any valid content before `]`, if non-empty
                    if trimmed_content:
                        current_template_content.append(trimmed_content)
                        if debug:print(f&#34;B|DEBUG L{line_number}:{trimmed_content}\n&#34;)

                    # End of template block
                    content = &#39;\n&#39;.join(current_template_content)
                    template[current_template_key] = ScriptTemplate(
                        content=content,
                        autorefresh=False,
                        definitions=LOCALdefinitions,
                        verbose=verbose,
                        userid=current_template_key)
                    # Refresh variables definitions
                    template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                    LOCALdefinitions = lambdaScriptdata()
                    # Reset state for next block
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                    last_successful_line = line_number
                    continue
                else:
                    # Append the entire original line content if not ending with `...` or `]`
                    current_template_content.append(line_content)
                    if debug:print(f&#34;C|DEBUG L{line_number}:{line_content}\n&#34;)

                continue

            # Not inside a template block
            stripped_no_comments = remove_comments(line_content)

            # Ignore empty lines after removing comments
            if not stripped_no_comments.strip():
                continue

            # If the original line is a comment line, skip it
            if line_content.strip().startswith(&#34;#&#34;) or line_content.strip().startswith(&#34;%&#34;):
                continue

            stripped = stripped_no_comments.strip()

            # Handle start of a new template block
            template_block_match = re.match(r&#39;^(\w+)\s*:\s*\[&#39;, stripped)
            if template_block_match:
                current_template_key = template_block_match.group(1)
                if inside_template_block:
                    # Collect error context
                    context_start = max(0, last_successful_line - 3)
                    context_end = min(len(lines), line_number + 2)
                    error_context_lines = lines[context_start:context_end]
                    error_context = &#34;&#34;
                    for i, error_line in enumerate(error_context_lines):
                        line_num = context_start + i + 1
                        indicator = &#34;&gt;&#34; if line_num == line_number else &#34;*&#34; if line_num == last_successful_line else &#34; &#34;
                        error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

                    raise ValueError(
                        f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} (*) was not properly closed before starting a new one at line {line_number} (&gt;).\n\n&#34;
                        f&#34;Error context:\n{error_context}&#34;
                    )
                else:
                    inside_template_block = True
                    idx_open_bracket = line_content.index(&#39;[&#39;)
                    remainder = line_content[idx_open_bracket + 1:].strip()
                    if remainder:
                        remainder_code = remove_comments(remainder, comment_chars=comment_chars).rstrip()
                        if remainder_code.endswith(&#34;]&#34;):
                            closing_index = remainder_code.rindex(&#39;]&#39;)
                            content_line = remainder_code[:closing_index].strip()
                            if content_line:
                                current_template_content.append(content_line)
                                if debug:print(f&#34;D|DEBUG L{line_number}:{content_line}\n&#34;)
                            content = &#39;\n&#39;.join(current_template_content)
                            template[current_template_key] = ScriptTemplate(
                                content=content,
                                autorefresh=False,
                                definitions=LOCALdefinitions,
                                verbose=verbose,
                                userid=current_template_key)
                            template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                            LOCALdefinitions = lambdaScriptdata()
                            inside_template_block = False
                            current_template_key = None
                            current_template_content = []
                            last_successful_line = line_number
                            continue
                        else:
                            current_template_content.append(remainder)
                            if debug:print(f&#34;E|DEBUG L{line_number}:{remainder}\n&#34;)
                    last_successful_line = line_number
                continue

            # Handle start of global parameters
            if stripped.startswith(&#39;{&#39;) and not inside_global_params:
                if &#39;}&#39; in stripped:
                    global_params_content = stripped
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                else:
                    inside_global_params = True
                    global_params_content = stripped
                continue

            # Handle global parameters inside {...}
            if inside_global_params:
                global_params_content += &#39; &#39; + stripped
                if &#39;}&#39; in stripped:
                    inside_global_params = False
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;
                    last_successful_line = line_number
                continue

            # Handle attributes
            attribute_match = re.match(r&#39;^(\w+)\s*:\s*\{(.+)\}&#39;, stripped)
            if attribute_match:
                key, attr_content = attribute_match.groups()
                attributes[key] = {}
                cls._parse_attributes(attributes[key], attr_content.strip())
                last_successful_line = line_number
                continue

            # Handle definitions
            definition_match = re.match(r&#39;^(\w+)\s*=\s*(.+)&#39;, stripped)
            if definition_match:
                key, value = definition_match.groups()
                convertedvalue = cls._convert_value(value)
                if key in GLOBALdefinitions:
                    if (GLOBALdefinitions.getattr(key) != convertedvalue) or \
                        (getattr(current_var_value, key) != convertedvalue):
                        LOCALdefinitions.setattr(key, convertedvalue)
                else:
                    GLOBALdefinitions.setattr(key, convertedvalue)
                last_successful_line = line_number
                setattr(current_var_value, key, convertedvalue)
                continue

            # Handle single-line templates (updated on 20250104 to handle empty content)
            template_match = re.match(r&#39;^(\w+)\s*:\s*(.*)&#39;, stripped)
            if template_match:
                key, content = template_match.groups()
                content = content.strip()  # Strip whitespace for consistency
                if not content:
                    content = f&#34;# empty &lt;step {key}&gt;&#34;
                    if debug: print(f&#34;F|DEBUG L{line_number}:Empty content detected for key: {key}, default value assigned\n&#34;)
                if debug: print(f&#34;F|DEBUG L{line_number}:{content}\n&#34;)
                template[key] = ScriptTemplate(
                    content = content,
                    autorefresh = False,
                    definitions=LOCALdefinitions,
                    verbose=verbose,
                    userid=key)
                template[key].refreshvar(globaldefinitions=GLOBALdefinitions)
                if debug:print(f&#34;G|DEBUG L{line_number}:{template[key].content}\n&#34;)
                LOCALdefinitions = lambdaScriptdata()
                last_successful_line = line_number
                continue

            # Unrecognized line
            if verbose:
                print(f&#34;Warning: Unrecognized line at {line_number}: {line_content}&#34;)
                if debug:
                    raise ValueError(f&#39;ERROR: stripped content &#34;{stripped}&#34;&#39;)
            last_successful_line = line_number
            continue

        # At the end, check if any template block was left unclosed
        if inside_template_block:
            # Collect error context
            context_start = max(0, last_successful_line - 3)
            context_end = min(len(lines), last_successful_line + 3)
            error_context_lines = lines[context_start:context_end]
            error_context = &#34;&#34;
            for i, error_line in enumerate(error_context_lines):
                line_num = context_start + i
                indicator = &#34;&gt;&#34; if line_num == last_successful_line else &#34; &#34;
                error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

            raise ValueError(
                f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} was not properly closed.\n\n&#34;
                f&#34;Error context:\n{error_context}&#34;
            )

        # Apply attributes to templates
        for key in attributes:
            if key in template:
                for attr_name, attr_value in attributes[key].items():
                    setattr(template[key], attr_name, attr_value)
                template[key]._autorefresh = True # restore the default behavior for the end-user
            else:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)

        # Create and return new instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name=name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )

        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = GLOBALdefinitions
        instance.TEMPLATE = template

        # Refresh variables
        instance.set_all_variables()

        # Check variables
        instance.check_all_variables(verbose=False)

        return instance




    @classmethod
    def parsesyntax_legacy(cls, content, name=None, numerickeys=True):
        &#34;&#34;&#34;
        Parse a script from a string content.
        [ ------------------------------------------------------]
        [ Legacy parsesyntax method for backward compatibility. ]
        [ ------------------------------------------------------]

        Parameters
        ----------
        content : str
            The string content of the script to be parsed.

        name : str
            The name of the dscript project (if None, it is set randomly)

        numerickeys : bool, default=True
            If True, numeric string keys in the template section are automatically converted into integers.

        Returns
        -------
        dscript
            A new `dscript` instance populated with the content of the loaded file.

        Raises
        ------
        ValueError
            If content does not start with the correct DSCRIPT header or the file format is invalid.

        Notes
        -----
        - The file is expected to follow the same structured format as the one produced by the `save()` method.
        - The method processes global parameters, definitions, template lines/items, and attributes. If the file
          includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
          if `numerickeys=True`.
        - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
          template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
          instance.


        PIZZA.DSCRIPT SAVE FILE FORMAT
        -------------------------------
        This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
        and control attributes can be defined in a flexible manner.

        ### Mandatory First Line:
        Every DSCRIPT file must begin with the following line:
            # DSCRIPT SAVE FILE

        ### Structure Overview:

        1. **Global Parameters Section (Optional):**
            - This section defines global script settings, enclosed within curly braces `{ }`.
            - Properties include:
                - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
                - `section`: Current section index (e.g., `0`).
                - `position`: Current script position in the order.
                - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
                - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
                - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
                - `version`: Script version (e.g., `0.1`).
                - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

            Example:
            ```
            {
                SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
            }
            ```

        2. **Definitions Section:**
            - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
            - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
              to delay execution or substitution.

            Example:
            ```
            d = 3                               # Define a number
            periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
            units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
            dimension = &#34;${d}&#34;                  # Variable substitution
            boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]  # List with a mix of variables and values
            atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
            ```

        3. **Templates Section:**
            - This section provides a mapping between keys and their corresponding commands or instructions.
            - The templates reference variables defined in the **Definitions** section or elsewhere.
            - Syntax:
                ```
                KEY: INSTRUCTION
                ```
                where:
                - `KEY` can be numeric or alphanumeric.
                - `INSTRUCTION` represents a command template, often referring to variables using `${variable}` notation.

            Example:
            ```
            units: units ${units}               # Template uses the &#39;units&#39; variable
            dim: dimension ${dimension}         # Template for setting the dimension
            bound: boundary ${boundary}         # Template for boundary settings
            lattice: lattice ${lattice}         # Lattice template
            ```

        4. **Attributes Section:**
            - Each template line can have customizable attributes to control behavior and conditions.
            - Default attributes include:
                - `facultative`: If `True`, the line is optional and can be removed if needed.
                - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
                - `readonly`: If `True`, the line cannot be modified later in the script.
                - `condition`: An expression that must be satisfied for the line to be included.
                - `condeval`: If `True`, the condition will be evaluated using `eval()`.
                - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

            Example:
            ```
            units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
            dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
            ```

        Note on multiple definitions
        -----------------------------
        This example demonstrates how variables defined in the `Definitions` section are handled for each template.
        Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
        can use different values for the same variable if redefined.

        content = &#34;&#34; &#34;
        # DSCRIPT SAVE FILE

        # Definitions
        var = 10

        # Template ky1
        key1: Template content with ${var}

        # Definitions
        var = 20

        # Template key2
        key2: Template content with ${var}

        # Template key3
        key3:[
            this is an underfined variable ${var31}
            this is an another underfined variable ${var32}
            this variables is defined  ${var}
            ]

        &#34;&#34; &#34;

        # Parse content using parsesyntax()
        ds = dscript.parsesyntax(content)

        # Key1 should use the first definition of &#39;var&#39; (10)
        print(ds.key1.definitions.var)  # Output: Template content with 10

        # Key2 should use the updated definition of &#39;var&#39; (20)
        print(ds.key2.definitions.var)  # Output: Template content with 10


        &#34;&#34;&#34;

        # Split the content into lines
        lines = content.splitlines()
        lines = [line for line in lines if line.strip()]  # Remove blank or empty lines
        # Raise an error if no content is left after removing blank lines
        if not lines:
            raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

        # Initialize containers for global parameters, definitions, templates, and attributes
        global_params = {}
        definitions = lambdaScriptdata()
        template = {}
        attributes = {}

        # State variables to handle multi-line global parameters and attributes
        inside_global_params = False
        inside_attributes = False
        current_attr_key = None  # Ensure this is properly initialized
        global_params_content = &#34;&#34;
        inside_template_block = False  # Track if we are inside a multi-line template
        current_template_key = None    # Track the current template key
        current_template_content = []  # Store lines for the current template content

        # Step 1: Authenticate the file
        if not lines[0].strip().startswith(&#34;# DSCRIPT SAVE FILE&#34;):
            raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

        # Step 2: Process each line dynamically
        for line in lines[1:]:
            stripped = line.strip()

            # Ignore empty lines and comments
            if not stripped or stripped.startswith(&#34;#&#34;):
                continue

            # Remove trailing comments
            stripped = remove_comments(stripped)

            # Step 3: Handle global parameters inside {...}
            if stripped.startswith(&#34;{&#34;):
                # Found the opening {, start accumulating global parameters
                inside_global_params = True
                # Remove the opening { and accumulate the remaining content
                global_params_content = stripped[stripped.index(&#39;{&#39;) + 1:].strip()

                # Check if the closing } is also on the same line
                if &#39;}&#39; in global_params_content:
                    global_params_content = global_params_content[:global_params_content.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # We found the closing } on the same line
                    # Now parse the global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block
                continue

            if inside_global_params:
                # Accumulate content until the closing } is found
                if stripped.endswith(&#34;}&#34;):
                    # Found the closing }, accumulate and process the entire block
                    global_params_content += &#34; &#34; + stripped[:stripped.index(&#39;}&#39;)].strip()
                    inside_global_params = False  # Finished reading global parameters block

                    # Now parse the entire global parameters block
                    cls._parse_global_params(global_params_content.strip(), global_params)
                    global_params_content = &#34;&#34;  # Reset for the next block if necessary
                else:
                    # Continue accumulating if } is not found
                    global_params_content += &#34; &#34; + stripped
                continue

            # Step 4: Detect the start of a multi-line template block inside [...]
            if not inside_template_block:
                template_match = re.match(r&#39;(\w+)\s*:\s*\[&#39;, stripped)
                if template_match:
                    current_template_key = template_match.group(1)  # Capture the key
                    inside_template_block = True
                    current_template_content = []  # Reset content list
                    continue

            # If inside a template block, accumulate lines until we find the closing ]
            if inside_template_block:
                if stripped == &#34;]&#34;:
                    # End of the template block, join the content and store it
                    template[current_template_key] = ScriptTemplate(
                        current_template_content,
                        definitions=lambdaScriptdata(**definitions),  # Clone current global definitions
                        verbose=True,
                        userid=current_template_key
                        )
                    template[current_template_key].refreshvar()
                    inside_template_block = False
                    current_template_key = None
                    current_template_content = []
                else:
                    # Accumulate the current line (without surrounding spaces)
                    current_template_content.append(stripped)
                continue

            # Step 5: Handle attributes inside {...}
            if inside_attributes and stripped.endswith(&#34;}&#34;):
                # Finish processing attributes for the current key
                cls._parse_attributes(attributes[current_attr_key], stripped[:-1])  # Remove trailing }
                inside_attributes = False
                current_attr_key = None
                continue

            if inside_attributes:
                # Continue accumulating attributes
                cls._parse_attributes(attributes[current_attr_key], stripped)
                continue

            # Step 6: Determine if the line is a definition, template, or attribute
            definition_match = re.match(r&#39;(\w+)\s*=\s*(.+)&#39;, stripped)
            template_match = re.match(r&#39;(\w+)\s*:\s*(?!\s*\{.*\}\s*$)(.+)&#39;, stripped) # template_match = re.match(r&#39;(\w+)\s*:\s*(?!\{)(.+)&#39;, stripped)
            attribute_match = re.match(r&#39;(\w+)\s*:\s*\{\s*(.+)\s*\}&#39;, stripped)       # attribute_match = re.match(r&#39;(\w+)\s*:\s*\{(.+)\}&#39;, stripped)

            if definition_match:
                # Line is a definition (key=value)
                key, value = definition_match.groups()
                definitions.setattr(key,cls._convert_value(value))

            elif template_match and not inside_template_block:
                # Line is a template (key: content)
                key, content = template_match.groups()
                template[key] = ScriptTemplate(
                    content,
                    definitions=lambdaScriptdata(**definitions),  # Clone current definitions
                    verbose=True,
                    userid=current_template_key)
                template[key].refreshvar()

            elif attribute_match:
                # Line is an attribute (key:{attributes...})
                current_attr_key, attr_content = attribute_match.groups()
                attributes[current_attr_key] = {}
                cls._parse_attributes(attributes[current_attr_key], attr_content)
                inside_attributes = not stripped.endswith(&#34;}&#34;)

        # Step 7: Validation and Reconstruction
        # Make sure there are no attributes without a template entry
        for key in attributes:
            if key not in template:
                raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)
            # Apply attributes to the corresponding template object
            for attr_name, attr_value in attributes[key].items():
                setattr(template[key], attr_name, attr_value)

        # Step 7: Create and return a new dscript instance
        if name is None:
            name = autoname(8)
        instance = cls(
            name = name,
            SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
            section=global_params.get(&#39;section&#39;, 0),
            position=global_params.get(&#39;position&#39;, 0),
            role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
            description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
            userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
            version=global_params.get(&#39;version&#39;, 0.1),
            verbose=global_params.get(&#39;verbose&#39;, False)
        )


        # Convert numeric string keys to integers if numerickeys is True
        if numerickeys:
            numeric_template = {}
            for key, value in template.items():
                # Check if the key is a numeric string
                if key.isdigit():
                    numeric_template[int(key)] = value
                else:
                    numeric_template[key] = value
            template = numeric_template

        # Set definitions and template
        instance.DEFINITIONS = definitions
        instance.TEMPLATE = template

        # Refresh variables (ensure that variables are detected and added to definitions)
        instance.set_all_variables()

        # Check eval
        instance.check_all_variables(verbose=False)

        # return the new instance
        return instance


    @classmethod
    def _parse_global_params(cls, content, global_params):
        &#34;&#34;&#34;
        Parses global parameters from the accumulated content enclosed in `{}`.

        ### Parameters:
            content (str): The content string containing global parameters.
            global_params (dict): A dictionary to populate with parsed parameters.

        ### Raises:
            ValueError: If invalid lines or key-value pairs are encountered.
        &#34;&#34;&#34;
        # Remove braces from the content
        content = content.strip().strip(&#34;{}&#34;)

        # Old method to split the content into lines by commas
        # lines = re.split(r&#39;,(?![^(){}\[\]]*[\)\}\]])&#39;, content.strip())
        # old parser
        # for line in lines:
        #     line = line.strip()
        #     # Match key-value pairs
        #     match = re.match(r&#39;([\w_]+)\s*=\s*(.+)&#39;, line)
        #     if match:
        #         key, value = match.groups()
        #         key = key.strip()
        #         value = value.strip()
        #         # Convert the value to the appropriate Python type and store it
        #         global_params[key] = cls._convert_value(value)
        #     else:
        #         raise ValueError(f&#34;Invalid parameter line: &#39;{line}&#39;&#34;)

        # Pattern to match key-value pairs, allowing for quoted strings and nested brackets
        pattern = r&#39;([\w_]+)\s*=\s*(&#34;.*?&#34;|\&#39;.*?\&#39;|[^\s,]+|{.*?}|\[.*?\]|\(.*?\))&#39;
        # Find all matches of key-value pairs
        matches = re.findall(pattern, content)
        for match in matches:
            key, value = match
            key = key.strip()
            value = value.strip()
            # Convert the value to the appropriate Python type and store it
            global_params[key] = cls._convert_value(value)


    @classmethod
    def _parse_attributes(cls, attr_dict, content):
        &#34;&#34;&#34;Parses attributes from the content inside {attribute=value,...}.&#34;&#34;&#34;
        attr_pairs = re.findall(r&#39;(\w+)\s*=\s*([^,]+)&#39;, content)
        for attr_name, attr_value in attr_pairs:
            attr_dict[attr_name] = cls._convert_value(attr_value)

    @classmethod
    def _convert_value(cls, value):
        &#34;&#34;&#34;Converts a string representation of a value to the appropriate Python type.&#34;&#34;&#34;
        value = value.strip()
        # Boolean and None conversion
        if value.lower() == &#39;true&#39;:
            return True
        elif value.lower() == &#39;false&#39;:
            return False
        elif value.lower() == &#39;none&#39;:
            return None
        # Handle quoted strings
        if (value.startswith(&#39;&#34;&#39;) and value.endswith(&#39;&#34;&#39;)) or (value.startswith(&#34;&#39;&#34;) and value.endswith(&#34;&#39;&#34;)):
            return value[1:-1]
        # Handle lists (Python syntax inside the file)
        if value.startswith(&#39;[&#39;) and value.endswith(&#39;]&#39;):
            return eval(value)  # Using eval to parse lists safely in this controlled scenario
        # Handle numbers
        try:
            if &#39;.&#39; in value:
                return float(value)
            return int(value)
        except ValueError:
            # Return the value as-is if it doesn&#39;t match other types
            return value

    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, copy.deepcopy(v, memo))
        return copie

    def detect_all_variables(self):
        &#34;&#34;&#34;
        Detects all variables across all templates in the dscript object.

        This method iterates through all ScriptTemplate objects in the dscript and
        collects variables from each template using the detect_variables method.

        Returns:
        --------
        list
            A sorted list of unique variables detected in all templates.
        &#34;&#34;&#34;
        all_variables = set()  # Use a set to avoid duplicates
        # Iterate through all templates in the dscript object
        for template_key, template in self.TEMPLATE.items():
            # Ensure the template is a ScriptTemplate and has the detect_variables method
            if isinstance(template, ScriptTemplate):
                detected_vars = template.detect_variables()
                all_variables.update(detected_vars)  # Add the detected variables to the set
        return sorted(all_variables)  # Return a sorted list of unique variables



    def add_dynamic_script(self, key, content=&#34;&#34;, userid=None, definitions=None, verbose=None, autorefresh=True, **USER):
        &#34;&#34;&#34;
        Add a dynamic script step to the dscript object.

        Parameters:
        -----------
        key : str
            The key for the dynamic script (usually an index or step identifier).
        content : str or list of str, optional
            The content (template) of the script step.
        definitions : lambdaScriptdata, optional
            The merged variable space (STATIC + GLOBAL + LOCAL).
        verbose : bool, optional
            If None, self.verbose will be used. Controls verbosity of the template.
        autorefresh : bool, optional
            If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
            Default = True
        USER : dict
            Additional user variables that override the definitions for this step.
        &#34;&#34;&#34;
        if definitions is None:
            definitions = lambdaScriptdata()
        if verbose is None:
            verbose = self.verbose
        # Create a new ScriptTemplate and add it to the TEMPLATE
        self.TEMPLATE[key] = ScriptTemplate(
            content=content,
            definitions=self.DEFINITIONS+definitions,
            verbose=verbose,
            userid = key if userid is None else userid,
            autorefresh=autorefresh,
            **USER
        )



    def check_all_variables(self, verbose=True, seteval=True, output=False):
        &#34;&#34;&#34;
        Checks for undefined variables for each TEMPLATE key in the dscript object.

        Parameters:
        -----------
        verbose : bool, optional, default=True
            If True, prints information about variables for each TEMPLATE key.
            Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

        seteval : bool, optional, default=True
            If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

        output : bool, optional, default=False
            If True, returns a dictionary with lists of default variables, set variables, and undefined variables.

        Returns:
        --------
        out : dict, optional
            If `output=True`, returns a dictionary with the following structure:
            - &#34;defaultvalues&#34;: List of variables set to their default value (${varname}).
            - &#34;setvalues&#34;: List of variables defined with values other than their default.
            - &#34;undefined&#34;: List of variables that are undefined.
        &#34;&#34;&#34;
        out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}

        for key in self.TEMPLATE:
            template = self.TEMPLATE[key]
            # Call the check_variables method of ScriptTemplate for each TEMPLATE key
            result = template.check_variables(verbose=verbose, seteval=seteval)

            # Update the output dictionary if needed
            out[&#34;defaultvalues&#34;].extend(result[&#34;defaultvalues&#34;])
            out[&#34;setvalues&#34;].extend(result[&#34;setvalues&#34;])
            out[&#34;undefined&#34;].extend(result[&#34;undefined&#34;])

        if output:
            return out


    def set_all_variables(self):
        &#34;&#34;&#34;
        Ensures that all variables in the templates are added to the global definitions
        with default values if they are not already defined.
        &#34;&#34;&#34;
        for key, script_template in self.TEMPLATE.items():
            # Check and update the global definitions with template-specific variables
            for var in script_template.detect_variables():
                if var not in self.DEFINITIONS:
                    # Add undefined variables with their default value
                    self.DEFINITIONS.setattr(var, f&#34;${{{var}}}&#34;)  # Set default as ${varname}




    def search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;all&#39;, protection=False, verbose=False):
        &#34;&#34;&#34;
        Search for foreign/definition key values associated with given primary key/definition value(s).

        This method searches through the global definitions first and then traverses local steps in sequential order
        to find matches for the specified primary key and retrieves the corresponding foreign key values.
        It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.

        Parameters:
            primary_key (str):
                The primary key to search for in the definitions.
            value (str, int, float, or list of these types):
                The value(s) associated with the primary key.
            foreign_key (str):
                The foreign key whose value is to be retrieved.
            include_global (bool, optional):
                If True, include global definitions in the search.
                Defaults to True.
            multiple (str, optional):
                Strategy for handling multiple matches. Options are:
                - &#39;first&#39;: Return the first match found.
                - &#39;last&#39;: Return the last match found.
                - &#39;all&#39;: Return all matches in a list.
                Defaults to &#39;all&#39;.
            protection (bool, optional):
                If False (default), removes the &#39;$&#39; prefix from the keys in the returned dictionary.
                If True, retains the &#39;$&#39; prefix.
                Defaults to False.
            verbose (bool, optional):
                If True, prints warnings about missing foreign keys and available alternative keys.
                Defaults to False.

        Returns:
            dict or scalar or None:
                - If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
                - If a single value is provided:
                    - Returns a single foreign key value if &#39;multiple&#39; is &#39;first&#39; or &#39;last&#39;.
                    - Returns a list of all matching foreign key values if &#39;multiple&#39; is &#39;all&#39;.
                - Returns None if no matches are found.

        Raises:
            TypeError:
                If the provided value is not of type str, int, or float, or if value list contains invalid types.
            ValueError:
                If an invalid option is provided for &#39;multiple&#39;.
        &#34;&#34;&#34;
        # Validate &#39;multiple&#39; parameter
        if multiple not in {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}:
            raise ValueError(&#34;Parameter &#39;multiple&#39; must be one of &#39;first&#39;, &#39;last&#39;, or &#39;all&#39;.&#34;)

        # Normalize &#39;value&#39; to a list for uniform processing
        if isinstance(value, (str, int, float)):
            values = [value]
            single_value = True
        elif isinstance(value, list):
            if not all(isinstance(v, (str, int, float)) for v in value):
                raise TypeError(&#34;All elements in &#39;value&#39; list must be of type str, int, or float.&#34;)
            values = value
            single_value = False
        else:
            raise TypeError(f&#34;&#39;value&#39; must be of type str, int, float, or list of these types, got {type(value).__name__}&#34;)

        # Initialize the result containers
        matched_foreign_keys = {}  # key: value, value: single or list of foreign_key values
        available_foreign_keys_set = set()  # set of foreign keys available where primary exists but desired foreign_key missing

        # Keys to exclude when listing available foreign keys
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Function to add a match to the results based on the &#39;multiple&#39; strategy
        def add_match(val, rvalue):
            if multiple == &#39;all&#39;:
                if val in matched_foreign_keys:
                    if isinstance(matched_foreign_keys[val], list):
                        matched_foreign_keys[val].append(rvalue)
                    else:
                        matched_foreign_keys[val] = [matched_foreign_keys[val], rvalue]
                else:
                    matched_foreign_keys[val] = [rvalue]
            elif multiple == &#39;first&#39;:
                if val not in matched_foreign_keys:
                    matched_foreign_keys[val] = rvalue
            elif multiple == &#39;last&#39;:
                matched_foreign_keys[val] = rvalue

        # Start with global definitions if included
        if include_global:
            global_definitions = self.DEFINITIONS
            if hasattr(global_definitions, primary_key):
                primary_value = getattr(global_definitions, primary_key)

                # Handle multiple primary key values within the global definitions
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists in global definitions
                            if hasattr(global_definitions, foreign_key):
                                rvalue = getattr(global_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in global definitions, excluding specified keys
                                available_keys = [
                                    k for k in global_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Then, traverse through local steps in sequential order
        for istep in range(len(self)):
            step_definitions = self[istep].definitions

            # Check if the primary key exists in the local definitions
            if hasattr(step_definitions, primary_key):
                primary_value = getattr(step_definitions, primary_key)

                # Handle multiple primary key values within the definition
                if isinstance(primary_value, (list, tuple, set)):
                    primary_values = primary_value
                else:
                    primary_values = [primary_value]

                for pv in primary_values:
                    for val in values:
                        if pv == val:
                            # Check if the foreign key exists
                            if hasattr(step_definitions, foreign_key):
                                rvalue = getattr(step_definitions, foreign_key)
                                add_match(val, rvalue)
                            else:
                                # Collect available foreign keys in this step, excluding specified keys
                                available_keys = [
                                    k for k in step_definitions.__dict__
                                    if k != primary_key and k not in excluded_keys
                                ]
                                available_foreign_keys_set.update(available_keys)

        # Process the matched_foreign_keys based on &#39;multiple&#39; strategy
        if single_value:
            if values[0] in matched_foreign_keys:
                if multiple == &#39;all&#39;:
                    # If only one match, return scalar; else, list
                    matches = matched_foreign_keys[values[0]]
                    if len(matches) == 1:
                        matches = matches[0]
                else:
                    matches = matched_foreign_keys[values[0]]
            else:
                matches = None
        else:
            matches = {}
            for val in values:
                if val in matched_foreign_keys:
                    if multiple == &#39;all&#39;:
                        if len(matched_foreign_keys[val]) == 1:
                            matches[val] = matched_foreign_keys[val][0]
                        else:
                            matches[val] = matched_foreign_keys[val]
                    else:
                        matches[val] = matched_foreign_keys[val]
                else:
                    matches[val] = None  # Or handle differently if needed

        # If there are available foreign keys, report them as an error message
        if available_foreign_keys_set and verbose:
            available_keys_sorted = sorted(list(available_foreign_keys_set))
            print(f&#34;Warning: In some steps, the foreign key &#39;{foreign_key}&#39; is missing where the primary key &#39;{primary_key}&#39; exists.&#34;)
            print(f&#34;Available foreign keys in those steps: {available_keys_sorted}&#34;)

        # If no matches found, print a message
        if (single_value and matches is None) or (not single_value and all(v is None for v in matches.values())):
            if verbose:
                print(f&#34;No matches found for primary key &#39;{primary_key}&#39; with value(s) &#39;{value}&#39;.&#34;)
            return None

        # Handle protection flag: remove &#39;$&#39; prefix from keys if protection=False
        if not single_value and isinstance(matches, dict):
            processed_matches = {}
            for k, v in matches.items():
                if not protection and isinstance(k, str):
                    # Remove any leading &#39;$&#39; and surrounding spaces
                    new_key = k.lstrip(&#39;$&#39;).strip()
                else:
                    new_key = k
                processed_matches[new_key] = v
            return processed_matches
        else:
            # For single value searches, return matches as-is
            return matches




    def list_values(self, key, include_global=True, verbose=False, order=&#39;stable&#39;, details=False):
        &#34;&#34;&#34;
        List all unique values taken by a specified key across global definitions and all steps in sequential order.

        Parameters:
            key (str): The key whose values are to be listed.
            include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
            verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
            order (str, optional): The order in which to list the unique values. Options are &#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;. Defaults to &#39;stable&#39;.
            details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.

        Returns:
            list or scalar or VariableOccurrences or None:
                - If `details=False`:
                    - Returns a list of unique values associated with the key, ordered as specified.
                    - If only one unique value exists, returns it as a scalar.
                    - Returns None if the key is not found in any global or step definitions.
                - If `details=True`:
                    - Returns a VariableOccurrences object containing detailed occurrence information across scopes.
        &#34;&#34;&#34;
        # Validate &#39;order&#39; parameter
        if order not in {&#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;}:
            raise ValueError(&#34;Parameter &#39;order&#39; must be one of &#39;stable&#39;, &#39;ascend&#39;, or &#39;descend&#39;.&#34;)

        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        unique_values = []
        seen_values = set()

        available_keys_set = set()

        # Helper function to compare lists
        def lists_are_equal(list1, list2):
            return list1 == list2

        # Function to add a key_value to unique_values
        def add_value(kv):
            if isinstance(kv, list):
                # Convert list to tuple for hashability
                try:
                    kv_tuple = tuple(kv)
                    if kv_tuple not in seen_values:
                        unique_values.append(kv.copy())  # Append a copy to preserve the list
                        seen_values.add(kv_tuple)
                except TypeError:
                    # If list contains unhashable items, compare manually
                    if not any(lists_are_equal(kv, existing) for existing in unique_values if isinstance(existing, list)):
                        unique_values.append(kv.copy())
            else:
                if kv not in seen_values:
                    unique_values.append(kv)
                    seen_values.add(kv)

        # Data structures for detailed occurrences
        occurrences_data = defaultdict(list)  # {&#39;global&#39;: [value], &#39;local&#39;: [(step, value), ...]}

        # Include global definitions
        if include_global and hasattr(self.DEFINITIONS, key):
            key_value = getattr(self.DEFINITIONS, key)
            if isinstance(key_value, list):
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value.copy()
            else:
                add_value(key_value)
                if details:
                    occurrences_data[&#39;global&#39;] = key_value
        elif include_global and verbose:
            # Collect available keys in global definitions, excluding specified keys
            available_keys = [
                k for k in self.DEFINITIONS.__dict__
                if k != key and k not in excluded_keys
            ]
            available_keys_set.update(available_keys)

        # Traverse through steps
        for step_key, step in self.TEMPLATE.items():
            if hasattr(step.definitions, key):
                key_value = getattr(step.definitions, key)
                if isinstance(key_value, list):
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value.copy()))
                else:
                    add_value(key_value)
                    if details:
                        occurrences_data[&#39;local&#39;].append((step_key, key_value))
            else:
                if verbose:
                    # Collect available keys in this step, excluding specified keys
                    available_keys = [
                        k for k in step.definitions.__dict__
                        if k != key and k not in excluded_keys
                    ]
                    available_keys_set.update(available_keys)

        # Verbose warnings
        if verbose and available_keys_set:
            available_keys_sorted = sorted(list(available_keys_set))
            print(f&#34;Warning: The key &#39;{key}&#39; is missing in some steps or global definitions.&#34;)
            print(f&#34;Available keys in those contexts: {available_keys_sorted}&#34;)

        # Ordering
        if order == &#39;stable&#39;:
            ordered_values = unique_values
        else:
            # To sort, ensure all elements are of the same type
            try:
                if all(isinstance(v, list) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                elif all(isinstance(v, type(unique_values[0])) for v in unique_values):
                    if order == &#39;ascend&#39;:
                        ordered_values = sorted(unique_values)
                    else:
                        ordered_values = sorted(unique_values, reverse=True)
                else:
                    raise TypeError
            except TypeError:
                if verbose:
                    print(&#34;Warning: Cannot sort values due to mixed or non-comparable types. Returning values in their original order.&#34;)
                ordered_values = unique_values

        if details:
            # Prepare data for VariableOccurrences
            # Convert defaultdict to regular dict
            occurrences_dict = dict(occurrences_data)

            if key.lower() == &#34;all&#34;:
                # Collect all keys and their occurrences
                all_keys = set()
                # Include global definitions if specified
                if include_global:
                    global_keys = set(self.DEFINITIONS.__dict__.keys()) - excluded_keys
                    all_keys.update(global_keys)
                # Include keys from all steps
                for step in self.TEMPLATE.values():
                    step_keys = set(step.definitions.__dict__.keys()) - excluded_keys
                    all_keys.update(step_keys)

                # Remove the &#39;all&#39; key itself if present
                all_keys.discard(&#34;all&#34;)

                variables_data = {}
                for var in all_keys:
                    var_data = defaultdict(list)
                    # Include global definitions
                    if include_global and hasattr(self.DEFINITIONS, var):
                        var_value = getattr(self.DEFINITIONS, var)
                        if isinstance(var_value, list):
                            var_data[&#39;global&#39;].append(var_value.copy())  # Directly append the value
                        else:
                            var_data[&#39;global&#39;].append(var_value)
                    # Traverse through steps
                    for step_key, step in self.TEMPLATE.items():
                        if hasattr(step.definitions, var):
                            var_value = getattr(step.definitions, var)
                            if isinstance(var_value, list):
                                var_data[&#39;local&#39;].append((step_key, var_value.copy()))
                            else:
                                var_data[&#39;local&#39;].append((step_key, var_value))
                    variables_data[var] = dict(var_data)
                return VariableOccurrences(variables_data, variables=None)  # variables=None implies multiple variables

            else:
                # Single variable case
                return VariableOccurrences(occurrences_dict, variables=key)

        # Determine return value
        if not unique_values:
            if verbose:
                print(f&#34;No values found for key &#39;{key}&#39; in any step or global definitions.&#34;)
            return None
        elif len(unique_values) == 1:
            return unique_values[0]
        else:
            return ordered_values



    def flattenvariables(self):
        &#34;&#34;&#34;
        Flatten the variable definitions for each step based on usage and precedence.

        This method ensures that for each step:
            - Only the variables used in the template are present in `self[i].definitions`.
            - The value of each variable is determined based on the following precedence:
                1. Global Definitions (`self.DEFINITIONS`)
                2. Current Step Definitions (`self[i].definitions`)
                3. Previous Step Definitions (`self[i-1].definitions`, etc.)
                4. Protected Variables (`&#34;$variable_name&#34;`)

        The method updates `self[i].definitions` to include only the necessary variables with their resolved values.
        Unused variables are removed from each step&#39;s definitions after resolution, **excluding** protected attributes.

        Raises:
            AttributeError: If a step or global definitions lack the necessary attributes.
        &#34;&#34;&#34;
        # Define the set of protected attributes that must never be removed
        excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

        # Initialize local_definitions with a copy of global definitions to prevent mutation
        local_definitions = lambdaScriptdata(**self.DEFINITIONS.__dict__)

        # Iterate through each step in order
        for i in range(len(self)):
            step = self[i]
            step_definitions = step.definitions

            # Detect variables used in the current step&#39;s template
            variables_used = step.detect_variables()

            # Temporary dictionary to store resolved variable values
            resolved_vars = {}

            # Resolve each variable&#39;s value based on precedence
            for var in variables_used:
                if hasattr(step_definitions, var):
                    # Variable defined in the current step&#39;s definitions
                    resolved_vars[var] = getattr(step_definitions, var)
                elif hasattr(local_definitions, var):
                    # Variable inherited from previous definitions (global or prior steps)
                    resolved_vars[var] = getattr(local_definitions, var)
                else:
                    # Variable not found; assign protected format
                    resolved_vars[var] = f&#34;${var}&#34;

            # Remove any variables in step_definitions not in variables_used and not in excluded_keys
            existing_vars = list(step_definitions.__dict__.keys())
            for var in existing_vars:
                if var not in variables_used and var not in excluded_keys:
                    delattr(step_definitions, var)

            # Assign resolved variables to step_definitions
            for var, value in resolved_vars.items():
                setattr(step_definitions, var, value)

            # Update local_definitions by merging with step_definitions
            # Only variables used in this step are updated in local_definitions
            local_definitions = local_definitions + step_definitions



    def clean(self, behavior=&#39;fixing&#39;, verbose=False):
        &#34;&#34;&#34;
        Clean the TEMPLATE by removing or fixing empty steps.

        An empty step is defined as one where its content is [], &#34;&#34;, or None.

        Parameters:
            behavior (str, optional):
                Determines the action to perform on empty steps.
                - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
                - &#39;fixing&#39;: Replace the content of the empty step with a comment.
                Defaults to &#39;fixing&#39;.
            verbose (bool, optional):
                If True, prints informational messages about the actions taken.
                If False, operates silently.
                Defaults to False.

        Raises:
            ValueError:
                If the provided behavior is not &#39;removing&#39; or &#39;fixing&#39;.
        &#34;&#34;&#34;
        # Validate the &#39;behavior&#39; parameter
        if behavior not in {&#39;removing&#39;, &#39;fixing&#39;}:
            raise ValueError(&#34;Parameter &#39;behavior&#39; must be either &#39;removing&#39; or &#39;fixing&#39;.&#34;)

        # Iterate over a list of keys to avoid RuntimeError due to dict size change during iteration
        for key in list(self.TEMPLATE.keys()):
            step = self.TEMPLATE[key]
            content = step.content

            # Check if the step is empty
            if content in [[], &#34;&#34;, None,[&#34;&#34;],[None],[[]]]:
                if behavior == &#39;removing&#39;:
                    # Remove the step entirely from TEMPLATE
                    del self.TEMPLATE[key]
                    if verbose:
                        print(f&#34;Removed empty step: {key}&#34;)
                elif behavior == &#39;fixing&#39;:
                    # Replace the content with a default comment
                    step.content = [f&#34;# empty &lt;step {key}&gt;&#34;]
                    if verbose:
                        print(f&#34;Fixed empty step: {key} by adding a comment.&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="group.dscript.construction_attributes"><code class="name">var <span class="ident">construction_attributes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="group.dscript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the DSCRIPT file.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional): The name of the script. If None, "Unnamed" is used.
verbose (bool, optional): Whether to include the header. Default is True.
verbosity (int, optional): Verbosity level. Overrides &lt;code&gt;verbose&lt;/code&gt; if specified.
style (int, optional): ASCII style for the header (default=2).
filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
version (str, optional): DSCRIPT version. If None, it is omitted from the header.
license (str, optional): License type. If None, it is omitted from the header.
email (str, optional): Contact email. If None, it is omitted from the header.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>str: A formatted string representing the script's metadata and initialization details.
     Returns an empty string if &lt;code&gt;verbose&lt;/code&gt; is False.
</code></pre>
<h3 id="the-header-includes">The header includes:</h3>
<pre><code>- DSCRIPT version, license, and contact email, if provided.
- The name of the script.
- Filepath, if provided.
- Information on where and when the script was generated.
</code></pre>
<h3 id="notes">Notes:</h3>
<pre><code>- If &lt;code&gt;verbosity&lt;/code&gt; is specified, it overrides &lt;code&gt;verbose&lt;/code&gt;.
- Omits metadata lines if &lt;code&gt;version&lt;/code&gt;, &lt;code&gt;license&lt;/code&gt;, or &lt;code&gt;email&lt;/code&gt; are not provided.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def header(name=None, verbose=True, verbosity=None, style=2, filepath=None, version=None, license=None, email=None):
    &#34;&#34;&#34;
    Generate a formatted header for the DSCRIPT file.

    ### Parameters:
        name (str, optional): The name of the script. If None, &#34;Unnamed&#34; is used.
        verbose (bool, optional): Whether to include the header. Default is True.
        verbosity (int, optional): Verbosity level. Overrides `verbose` if specified.
        style (int, optional): ASCII style for the header (default=2).
        filepath (str, optional): Full path to the file being saved. If None, the line mentioning the file path is excluded.
        version (str, optional): DSCRIPT version. If None, it is omitted from the header.
        license (str, optional): License type. If None, it is omitted from the header.
        email (str, optional): Contact email. If None, it is omitted from the header.

    ### Returns:
        str: A formatted string representing the script&#39;s metadata and initialization details.
             Returns an empty string if `verbose` is False.

    ### The header includes:
        - DSCRIPT version, license, and contact email, if provided.
        - The name of the script.
        - Filepath, if provided.
        - Information on where and when the script was generated.

    ### Notes:
        - If `verbosity` is specified, it overrides `verbose`.
        - Omits metadata lines if `version`, `license`, or `email` are not provided.
    &#34;&#34;&#34;
    # Resolve verbosity
    verbose = verbosity &gt; 0 if verbosity is not None else verbose
    if not verbose:
        return &#34;&#34;
    # Validate inputs
    if name is None:
        name = &#34;Unnamed&#34;
    # Prepare metadata line
    metadata = []
    if version:
        metadata.append(f&#34;v{version}&#34;)
    if license:
        metadata.append(f&#34;License: {license}&#34;)
    if email:
        metadata.append(f&#34;Email: {email}&#34;)
    metadata_line = &#34; | &#34;.join(metadata)
    # Prepare the framed header content
    lines = []
    if metadata_line:
        lines.append(f&#34;PIZZA.DSCRIPT FILE {metadata_line}&#34;)
    lines += [
        &#34;&#34;,
        f&#34;Name: {name}&#34;,
    ]
    # Add the filepath line if filepath is not None
    if filepath:
        lines.append(f&#34;Path: {filepath}&#34;)
    lines += [
        &#34;&#34;,
        f&#34;Generated on: {getpass.getuser()}@{socket.gethostname()}:{os.getcwd()}&#34;,
        f&#34;{datetime.now().strftime(&#39;%A, %B %d, %Y at %H:%M:%S&#39;)}&#34;,
    ]
    # Use the shared frame_header function to format the framed content
    return frame_header(lines, style=style)</code></pre>
</details>
</dd>
<dt id="group.dscript.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>filename, foldername=None, numerickeys=True, verbose=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a script instance from a text file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file to load the script from. If the filename does not end with ".txt",
the extension is automatically appended.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory where the file is located. If not provided, it defaults to the system's
temporary directory. If the filename does not include a full path, this folder will be used.</dd>
<dt><strong><code>numerickeys</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, numeric string keys in the template section are automatically converted into integers.
For example, the key "0" would be converted into the integer 0.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If <code>True</code>, the parser keep comments inside templates and template blocks.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, print parsed lines for refining/tracking the parsing of block and single lines</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="group.dscript" href="#group.dscript">dscript</a></code></dt>
<dd>A new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> instance populated with the content of the loaded file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the file does not start with the correct DSCRIPT header or the file format is invalid.</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified file does not exist.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The file is expected to follow the same structured format as the one produced by the <code>save()</code> method.</li>
<li>The method processes global parameters, definitions, template lines/items, and attributes. If the file
includes numeric keys as strings (e.g., "0", "1"), they can be automatically converted into integers
if <code>numerickeys=True</code>.</li>
<li>The script structure is dynamically rebuilt, and each section (global parameters, definitions,
template, and attributes) is correctly parsed and assigned to the corresponding parts of the <code><a title="group.dscript" href="#group.dscript">dscript</a></code>
instance.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load(cls, filename, foldername=None, numerickeys=True, verbose=True, debug=False):
    &#34;&#34;&#34;
    Load a script instance from a text file.

    Parameters
    ----------
    filename : str
        The name of the file to load the script from. If the filename does not end with &#34;.txt&#34;,
        the extension is automatically appended.

    foldername : str, optional
        The directory where the file is located. If not provided, it defaults to the system&#39;s
        temporary directory. If the filename does not include a full path, this folder will be used.

    numerickeys : bool, default=True
        If True, numeric string keys in the template section are automatically converted into integers.
        For example, the key &#34;0&#34; would be converted into the integer 0.

    verbose : bool, default=True
        If `True`, the parser keep comments inside templates and template blocks.

    debug : bool, default=False
        If True, print parsed lines for refining/tracking the parsing of block and single lines

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If the file does not start with the correct DSCRIPT header or the file format is invalid.

    FileNotFoundError
        If the specified file does not exist.

    Notes
    -----
    - The file is expected to follow the same structured format as the one produced by the `save()` method.
    - The method processes global parameters, definitions, template lines/items, and attributes. If the file
      includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
      if `numerickeys=True`.
    - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
      template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
      instance.
    &#34;&#34;&#34;

    # Step 0 validate filepath
    if not filename.endswith(&#39;.txt&#39;):
        filename += &#39;.txt&#39;

    # Handle foldername and relative paths
    if foldername is None or foldername == &#34;&#34;:
        # If the foldername is empty or None, use current working directory for relative paths
        if not os.path.isabs(filename):
            filepath = os.path.join(os.getcwd(), filename)
        else:
            filepath = filename  # If filename is absolute, use it directly
    else:
        # If foldername is provided and filename is not absolute, use foldername
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

    if not os.path.exists(filepath):
        raise FileExistsError(f&#34;The file &#39;{filepath}&#39; does not exist.&#34;)

    # Read the file contents
    with open(filepath, &#39;r&#39;) as f:
        content = f.read()

    # Call parsesyntax to parse the file content
    fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
    name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript
    return cls.parsesyntax(content, name=name, numerickeys=numerickeys, verbose=verbose, debug=debug)</code></pre>
</details>
</dd>
<dt id="group.dscript.parsesyntax"><code class="name flex">
<span>def <span class="ident">parsesyntax</span></span>(<span>content, name=None, numerickeys=True, verbose=False, authentification=True, debug=False, comment_chars='#%', continuation_marker='...')</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a DSCRIPT script from a string content.</p>
<pre><code>Parameters
----------
content : str
    The string content of the DSCRIPT script to be parsed.

name : str, optional
    The name of the dscript project. If &lt;code&gt;None&lt;/code&gt;, a random name is generated.

numerickeys : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, numeric string keys in the template section are automatically converted into integers.

verbose : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, the parser keep comments inside templates and template blocks.

authentification : bool, default=True
    If &lt;code&gt;True&lt;/code&gt;, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

comment_chars : str, optional (default: "#%")
    A string containing characters to identify the start of a comment.
    Any of these characters will mark the beginning of a comment unless within quotes.

continuation_marker : str, optional (default: "...")
    A string containing characters to indicate line continuation
    Any characters after the continuation marker are considered comment and are theorefore ignored

debug : bool, default=False
    Print parsed lines for refining the parsing of block lines

Returns
-------
dscript
    A new &lt;code&gt;&lt;a title="group.dscript" href="#group.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; instance populated with the content of the loaded file.

Raises
------
ValueError
    If content does not start with the correct DSCRIPT header or the file format is invalid.

Notes
-----
**DSCRIPT SAVE FILE FORMAT**

This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
and control attributes can be defined in a flexible manner.

**Mandatory First Line:**

Every DSCRIPT file must begin with the following line:

```plaintext
# DSCRIPT SAVE FILE
```

**Structure Overview:**

1. **Global Parameters Section (Optional):**

    - This section defines global script settings, enclosed within curly braces `{}`.
    - Properties include:
        - &lt;code&gt;SECTIONS&lt;/code&gt;: List of section names to be considered (e.g., `["DYNAMIC"]`).
        - &lt;code&gt;section&lt;/code&gt;: Current section index (e.g., &lt;code&gt;0&lt;/code&gt;).
        - &lt;code&gt;position&lt;/code&gt;: Current script position in the order.
        - &lt;code&gt;role&lt;/code&gt;: Defines the role of the script instance (e.g., `"dscript instance"`).
        - &lt;code&gt;description&lt;/code&gt;: A short description of the script (e.g., `"dynamic script"`).
        - &lt;code&gt;userid&lt;/code&gt;: Identifier for the user (e.g., `"dscript"`).
        - &lt;code&gt;version&lt;/code&gt;: Script version (e.g., &lt;code&gt;0.1&lt;/code&gt;).
        - &lt;code&gt;verbose&lt;/code&gt;: Verbosity flag, typically a boolean (e.g., &lt;code&gt;False&lt;/code&gt;).

    **Example:**

    ```plaintext
    {
        SECTIONS = ['INITIALIZATION', 'SIMULATION']  # Global script parameters
    }
    ```

2. **Definitions Section:**

    - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
    - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
      to delay execution or substitution.

    **Example:**

    ```plaintext
    d = 3                               # Define a number
    periodic = "$p"                     # '$' prevents immediate evaluation of 'p'
    units = "$metal"                    # '$' prevents immediate evaluation of 'metal'
    dimension = "${d}"                  # Variable substitution
    boundary = ['p', 'p', 'p']          # List with a mix of variables and values
    atom_style = "$atomic"              # String variable with delayed evaluation
    ```

3. **Templates Section:**

    - This section provides a mapping between keys and their corresponding commands or instructions.
    - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
    - **Syntax Variations**:

        Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (&lt;code&gt;...&lt;/code&gt;) as a line continuation marker.

        - **Single-line Template Without Block**:
            ```plaintext
            KEY: INSTRUCTION
            ```
            - &lt;code&gt;KEY&lt;/code&gt; is the identifier for the template (numeric or alphanumeric).
            - &lt;code&gt;INSTRUCTION&lt;/code&gt; is the command or template text, which may reference variables.

        - **Single-line Template With Block**:
            ```plaintext
            KEY: [INSTRUCTION]
            ```
            - Uses square brackets (&lt;code&gt;\[ ]&lt;/code&gt;) around the &lt;code&gt;INSTRUCTION&lt;/code&gt;, indicating that all instructions are part of the block.

        - **Multi-line Template With Block**:
            ```plaintext
            KEY: [
                INSTRUCTION1
                INSTRUCTION2
                ...
                ]
            ```
            - Begins with `KEY: [` and ends with a standalone &lt;code&gt;]&lt;/code&gt; on a new line.
            - Instructions within the block can span multiple lines, and ellipses (&lt;code&gt;...&lt;/code&gt;) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
            - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

        - **Multi-line Template With Continuation Marker (Ellipsis)**:
            - For templates with complex code containing square brackets (&lt;code&gt;\[ ]&lt;/code&gt;), the ellipsis (&lt;code&gt;...&lt;/code&gt;) can be used to prevent &lt;code&gt;]&lt;/code&gt; from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

            **Example:**
            ```plaintext
            example1: command ${value}       # Single-line template without block
            example2: [command ${value}]     # Single-line template with block

            # Multi-line template with block
            example3: [
                command1 ${var1}
                command2 ${var2} ...   # Line continues after ellipsis
                command3 ${var3} ...   # Additional instruction continues
                ]

            # Multi-line template with ellipsis (handling square brackets)
            example4: [
                A[0][1] ...            # Ellipsis allows [ ] within instructions
                B[2][3] ...            # Another instruction in the block
                ]
            ```

    - **Key Points**:
        - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
        - **Ellipsis (&lt;code&gt;...&lt;/code&gt;)** at the end of a line keeps the line open, preventing premature closing by &lt;code&gt;]&lt;/code&gt;, especially useful if the template code includes square brackets (&lt;code&gt;\[ ]&lt;/code&gt;).
        - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

    This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


4. **Attributes Section:**

    - Each template line can have customizable attributes to control behavior and conditions.
    - Default attributes include:
        - &lt;code&gt;facultative&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line is optional and can be removed if needed.
        - &lt;code&gt;eval&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line will be evaluated with Python's &lt;code&gt;eval()&lt;/code&gt; function.
        - &lt;code&gt;readonly&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the line cannot be modified later in the script.
        - &lt;code&gt;condition&lt;/code&gt;: An expression that must be satisfied for the line to be included.
        - &lt;code&gt;condeval&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, the condition will be evaluated using &lt;code&gt;eval()&lt;/code&gt;.
        - &lt;code&gt;detectvar&lt;/code&gt;: If &lt;code&gt;True&lt;/code&gt;, this creates variables in the **Definitions** section if they do not exist.

    **Example:**

    ```plaintext
    units: {facultative=False, eval=False, readonly=False, condition="${units}", condeval=False, detectvar=True}
    dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
    ```

**Note on Multiple Definitions**

This example demonstrates how variables defined in the **Definitions** section are handled for each template.
Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
can use different values for the same variable if redefined.

**Example:**

```plaintext
# DSCRIPT SAVE FILE

# Definitions
var = 10

# Template key1
key1: Template content with ${var}

# Definitions
var = 20

# Template key2
key2: Template content with ${var}

# Template key3
key3:[
    this is an undefined variable ${var31}
    this is another undefined variable ${var32}
    this variable is defined  ${var}
]
```

**Parsing and Usage:**

```python
# Parse content using parsesyntax()
ds = dscript.parsesyntax(content)

# Accessing templates and their variables
print(ds.TEMPLATE['key1'].text)  # Output: Template content with 10
print(ds.TEMPLATE['key2'].text)  # Output: Template content with 20
```

**Handling Undefined Variables:**

Variables like `${var31}` and `${var32}` in &lt;code&gt;key3&lt;/code&gt; are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

**Important Notes:**

- The parser processes the script sequentially. Definitions must appear before the templates that use them.
- Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
- Comments outside of blocks are allowed and ignored by the parser.
- Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).
</code></pre>
<p><strong>Advanced Example</strong></p>
<pre><code>Here's a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

```python
content = '''
    # GLOBAL DEFINITIONS
    dumpfile = $dump.LAMMPS
    dumpdt = 50
    thermodt = 100
    runtime = 5000

    # LOCAL DEFINITIONS for step '0'
    dimension = 3
    units = $si
    boundary = ['f', 'f', 'f']
    atom_style = $smd
    atom_modify = ['map', 'array']
    comm_modify = ['vel', 'yes']
    neigh_modify = ['every', 10, 'delay', 0, 'check', 'yes']
    newton = $off
    name = $SimulationBox

    # This is a comment line outside of blocks
    # ------------------------------------------

    0: [    % --------------[ Initialization Header (helper) for "${name}" ]--------------
        # set a parameter to None or "" to remove the definition
        dimension    ${dimension}
        units        ${units}
        boundary     ${boundary}
        atom_style   ${atom_style}
        atom_modify  ${atom_modify}
        comm_modify  ${comm_modify}
        neigh_modify ${neigh_modify}
        newton       ${newton}
        # ------------------------------------------
     ]
'''
# Parse the content
ds = dscript.parsesyntax(content, verbose=True, authentification=False)

# Access and print the rendered template
print("Template 0 content:")
print(ds.TEMPLATE[0].do())
```

**Explanation:**

- **Global Definitions:** Define variables that are accessible throughout the script.
- **Local Definitions for Step '0':** Define variables specific to a particular step or template.
- **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
- **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

**Expected Output:**

```
Template 0 content:
# --------------[ Initialization Header (helper) for "SimulationBox" ]--------------
# set a parameter to None or "" to remove the definition
dimension    3
units        si
boundary     ['f', 'f', 'f']
atom_style   smd
atom_modify  ['map', 'array']
comm_modify  ['vel', 'yes']
neigh_modify ['every', 10, 'delay', 0, 'check', 'yes']
newton       off
# ------------------------------------------
```

**Notes:**

- The &lt;code&gt;do()&lt;/code&gt; method renders the template, substituting variables with their defined values.
- Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
- The parser handles comments and blank lines appropriately, ensuring they don't interfere with the parsing logic.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parsesyntax(cls, content, name=None, numerickeys=True, verbose=False, authentification=True,
                debug=False, comment_chars=&#34;#%&#34;,continuation_marker=&#34;...&#34;):
    &#34;&#34;&#34;
    Parse a DSCRIPT script from a string content.

    Parameters
    ----------
    content : str
        The string content of the DSCRIPT script to be parsed.

    name : str, optional
        The name of the dscript project. If `None`, a random name is generated.

    numerickeys : bool, default=True
        If `True`, numeric string keys in the template section are automatically converted into integers.

    verbose : bool, default=True
        If `True`, the parser keep comments inside templates and template blocks.

    authentification : bool, default=True
        If `True`, the parser is expected that the first non empty line is # DSCRIPT SAVE FILE

    comment_chars : str, optional (default: &#34;#%&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.

    continuation_marker : str, optional (default: &#34;...&#34;)
        A string containing characters to indicate line continuation
        Any characters after the continuation marker are considered comment and are theorefore ignored

    debug : bool, default=False
        Print parsed lines for refining the parsing of block lines

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If content does not start with the correct DSCRIPT header or the file format is invalid.

    Notes
    -----
    **DSCRIPT SAVE FILE FORMAT**

    This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
    and control attributes can be defined in a flexible manner.

    **Mandatory First Line:**

    Every DSCRIPT file must begin with the following line:

    ```plaintext
    # DSCRIPT SAVE FILE
    ```

    **Structure Overview:**

    1. **Global Parameters Section (Optional):**

        - This section defines global script settings, enclosed within curly braces `{}`.
        - Properties include:
            - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
            - `section`: Current section index (e.g., `0`).
            - `position`: Current script position in the order.
            - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
            - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
            - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
            - `version`: Script version (e.g., `0.1`).
            - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

        **Example:**

        ```plaintext
        {
            SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
        }
        ```

    2. **Definitions Section:**

        - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
        - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
          to delay execution or substitution.

        **Example:**

        ```plaintext
        d = 3                               # Define a number
        periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
        units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
        dimension = &#34;${d}&#34;                  # Variable substitution
        boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]          # List with a mix of variables and values
        atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
        ```

    3. **Templates Section:**

        - This section provides a mapping between keys and their corresponding commands or instructions.
        - Each template can reference variables defined in the **Definitions** section or elsewhere, typically using the `${variable}` syntax.
        - **Syntax Variations**:

            Templates can be defined in several ways, including without blocks, with single- or multi-line blocks, and with ellipsis (`...`) as a line continuation marker.

            - **Single-line Template Without Block**:
                ```plaintext
                KEY: INSTRUCTION
                ```
                - `KEY` is the identifier for the template (numeric or alphanumeric).
                - `INSTRUCTION` is the command or template text, which may reference variables.

            - **Single-line Template With Block**:
                ```plaintext
                KEY: [INSTRUCTION]
                ```
                - Uses square brackets (`[ ]`) around the `INSTRUCTION`, indicating that all instructions are part of the block.

            - **Multi-line Template With Block**:
                ```plaintext
                KEY: [
                    INSTRUCTION1
                    INSTRUCTION2
                    ...
                    ]
                ```
                - Begins with `KEY: [` and ends with a standalone `]` on a new line.
                - Instructions within the block can span multiple lines, and ellipses (`...`) at the end of a line are used to indicate that the line continues, ignoring any content following the ellipsis as comments.
                - Comments following ellipses are removed after parsing and do not become part of the block, preserving only the instructions.

            - **Multi-line Template With Continuation Marker (Ellipsis)**:
                - For templates with complex code containing square brackets (`[ ]`), the ellipsis (`...`) can be used to prevent `]` from prematurely closing the block. The ellipsis will keep the line open across multiple lines, allowing brackets in the instructions.

                **Example:**
                ```plaintext
                example1: command ${value}       # Single-line template without block
                example2: [command ${value}]     # Single-line template with block

                # Multi-line template with block
                example3: [
                    command1 ${var1}
                    command2 ${var2} ...   # Line continues after ellipsis
                    command3 ${var3} ...   # Additional instruction continues
                    ]

                # Multi-line template with ellipsis (handling square brackets)
                example4: [
                    A[0][1] ...            # Ellipsis allows [ ] within instructions
                    B[2][3] ...            # Another instruction in the block
                    ]
                ```

        - **Key Points**:
            - **Blocks** allow grouping of multiple instructions for a single key, enclosed in square brackets.
            - **Ellipsis (`...`)** at the end of a line keeps the line open, preventing premature closing by `]`, especially useful if the template code includes square brackets (`[ ]`).
            - **Comments** placed after the ellipsis are removed after parsing and are not part of the final block content.

        This flexibility supports both simple and complex template structures, allowing instructions to be grouped logically while keeping code and comments distinct.


    4. **Attributes Section:**

        - Each template line can have customizable attributes to control behavior and conditions.
        - Default attributes include:
            - `facultative`: If `True`, the line is optional and can be removed if needed.
            - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
            - `readonly`: If `True`, the line cannot be modified later in the script.
            - `condition`: An expression that must be satisfied for the line to be included.
            - `condeval`: If `True`, the condition will be evaluated using `eval()`.
            - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

        **Example:**

        ```plaintext
        units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
        dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
        ```

    **Note on Multiple Definitions**

    This example demonstrates how variables defined in the **Definitions** section are handled for each template.
    Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
    can use different values for the same variable if redefined.

    **Example:**

    ```plaintext
    # DSCRIPT SAVE FILE

    # Definitions
    var = 10

    # Template key1
    key1: Template content with ${var}

    # Definitions
    var = 20

    # Template key2
    key2: Template content with ${var}

    # Template key3
    key3:[
        this is an undefined variable ${var31}
        this is another undefined variable ${var32}
        this variable is defined  ${var}
    ]
    ```

    **Parsing and Usage:**

    ```python
    # Parse content using parsesyntax()
    ds = dscript.parsesyntax(content)

    # Accessing templates and their variables
    print(ds.TEMPLATE[&#39;key1&#39;].text)  # Output: Template content with 10
    print(ds.TEMPLATE[&#39;key2&#39;].text)  # Output: Template content with 20
    ```

    **Handling Undefined Variables:**

    Variables like `${var31}` and `${var32}` in `key3` are undefined. The parser will handle them based on your substitution logic or raise an error if they are required.

    **Important Notes:**

    - The parser processes the script sequentially. Definitions must appear before the templates that use them.
    - Templates capture the variable definitions at the time they are parsed. Redefining a variable affects only subsequent templates.
    - Comments outside of blocks are allowed and ignored by the parser.
    - Content within templates is treated as-is, allowing for any syntax required by the target system (e.g., LAMMPS commands).


**Advanced Example**

    Here&#39;s a more advanced example demonstrating the use of global definitions, local definitions, templates, and how to parse and render the template content.

    ```python
    content = &#39;&#39;&#39;
        # GLOBAL DEFINITIONS
        dumpfile = $dump.LAMMPS
        dumpdt = 50
        thermodt = 100
        runtime = 5000

        # LOCAL DEFINITIONS for step &#39;0&#39;
        dimension = 3
        units = $si
        boundary = [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
        atom_style = $smd
        atom_modify = [&#39;map&#39;, &#39;array&#39;]
        comm_modify = [&#39;vel&#39;, &#39;yes&#39;]
        neigh_modify = [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
        newton = $off
        name = $SimulationBox

        # This is a comment line outside of blocks
        # ------------------------------------------

        0: [    % --------------[ Initialization Header (helper) for &#34;${name}&#34; ]--------------
            # set a parameter to None or &#34;&#34; to remove the definition
            dimension    ${dimension}
            units        ${units}
            boundary     ${boundary}
            atom_style   ${atom_style}
            atom_modify  ${atom_modify}
            comm_modify  ${comm_modify}
            neigh_modify ${neigh_modify}
            newton       ${newton}
            # ------------------------------------------
         ]
    &#39;&#39;&#39;
    # Parse the content
    ds = dscript.parsesyntax(content, verbose=True, authentification=False)

    # Access and print the rendered template
    print(&#34;Template 0 content:&#34;)
    print(ds.TEMPLATE[0].do())
    ```

    **Explanation:**

    - **Global Definitions:** Define variables that are accessible throughout the script.
    - **Local Definitions for Step &#39;0&#39;:** Define variables specific to a particular step or template.
    - **Template Block:** Identified by `0: [ ... ]`, it contains the content where variables will be substituted.
    - **Comments:** Lines starting with `#` are comments and are ignored by the parser outside of template blocks.

    **Expected Output:**

    ```
    Template 0 content:
    # --------------[ Initialization Header (helper) for &#34;SimulationBox&#34; ]--------------
    # set a parameter to None or &#34;&#34; to remove the definition
    dimension    3
    units        si
    boundary     [&#39;f&#39;, &#39;f&#39;, &#39;f&#39;]
    atom_style   smd
    atom_modify  [&#39;map&#39;, &#39;array&#39;]
    comm_modify  [&#39;vel&#39;, &#39;yes&#39;]
    neigh_modify [&#39;every&#39;, 10, &#39;delay&#39;, 0, &#39;check&#39;, &#39;yes&#39;]
    newton       off
    # ------------------------------------------
    ```

    **Notes:**

    - The `do()` method renders the template, substituting variables with their defined values.
    - Variables like `${dimension}` are replaced with their corresponding values defined in the local or global definitions.
    - The parser handles comments and blank lines appropriately, ensuring they don&#39;t interfere with the parsing logic.


    &#34;&#34;&#34;
    # Split the content into lines
    lines = content.splitlines()
    if not lines:
        raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

    # Initialize containers
    global_params = {}
    GLOBALdefinitions = lambdaScriptdata()
    LOCALdefinitions = lambdaScriptdata()
    template = {}
    attributes = {}

    # State variables
    inside_global_params = False
    global_params_content = &#34;&#34;
    inside_template_block = False
    current_template_key = None
    current_template_content = []
    current_var_value = lambdaScriptdata()

    # Initialize line number
    line_number = 0
    last_successful_line = 0

    # Step 1: Authenticate the file
    if authentification:
        auth_line_found = False
        max_header_lines = 10
        header_end_idx = -1
        for idx, line in enumerate(lines[:max_header_lines]):
            stripped_line = line.strip()
            if not stripped_line:
                continue
            if stripped_line.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
                auth_line_found = True
                header_end_idx = idx
                break
            elif stripped_line.startswith(&#34;#&#34;) or stripped_line.startswith(&#34;%&#34;):
                continue
            else:
                raise ValueError(f&#34;Unexpected content before authentication line (# DSCRIPT SAVE FILE) at line {idx + 1}:\n{line}&#34;)
        if not auth_line_found:
            raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

        # Remove header lines
        lines = lines[header_end_idx + 1:]
        line_number = header_end_idx + 1
        last_successful_line = line_number - 1
    else:
        line_number = 0
        last_successful_line = 0

    # Process each line
    for idx, line in enumerate(lines):
        line_number += 1
        line_content = line.rstrip(&#39;\n&#39;)
        if debug: print(f&#34;RAW L{line_number}    :{line_content}\n&#34;)

        # Determine if we&#39;re inside a template block
        if inside_template_block:
            # Extract the code with its eventual continuation_marker
            code_line = remove_comments(
                    line_content,
                    comment_chars=comment_chars,
                    continuation_marker=continuation_marker,
                    remove_continuation_marker=False,
                    ).rstrip()

            # Check if line should continue
            if code_line.endswith(continuation_marker):
                # Append line up to the continuation marker
                endofline_index = line_content.rindex(continuation_marker)
                trimmed_content = line_content[:endofline_index].rstrip()
                if trimmed_content:
                    current_template_content.append(trimmed_content)
                    if debug:print(f&#34;A|DEBUG L{line_number}:{trimmed_content}\n&#34;)
                continue
            elif code_line.endswith(&#34;]&#34;):  # End of multi-line block
                closing_index = code_line.rindex(&#39;]&#39;)
                trimmed_content = code_line[:closing_index].rstrip()

                # Append any valid content before `]`, if non-empty
                if trimmed_content:
                    current_template_content.append(trimmed_content)
                    if debug:print(f&#34;B|DEBUG L{line_number}:{trimmed_content}\n&#34;)

                # End of template block
                content = &#39;\n&#39;.join(current_template_content)
                template[current_template_key] = ScriptTemplate(
                    content=content,
                    autorefresh=False,
                    definitions=LOCALdefinitions,
                    verbose=verbose,
                    userid=current_template_key)
                # Refresh variables definitions
                template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                LOCALdefinitions = lambdaScriptdata()
                # Reset state for next block
                inside_template_block = False
                current_template_key = None
                current_template_content = []
                last_successful_line = line_number
                continue
            else:
                # Append the entire original line content if not ending with `...` or `]`
                current_template_content.append(line_content)
                if debug:print(f&#34;C|DEBUG L{line_number}:{line_content}\n&#34;)

            continue

        # Not inside a template block
        stripped_no_comments = remove_comments(line_content)

        # Ignore empty lines after removing comments
        if not stripped_no_comments.strip():
            continue

        # If the original line is a comment line, skip it
        if line_content.strip().startswith(&#34;#&#34;) or line_content.strip().startswith(&#34;%&#34;):
            continue

        stripped = stripped_no_comments.strip()

        # Handle start of a new template block
        template_block_match = re.match(r&#39;^(\w+)\s*:\s*\[&#39;, stripped)
        if template_block_match:
            current_template_key = template_block_match.group(1)
            if inside_template_block:
                # Collect error context
                context_start = max(0, last_successful_line - 3)
                context_end = min(len(lines), line_number + 2)
                error_context_lines = lines[context_start:context_end]
                error_context = &#34;&#34;
                for i, error_line in enumerate(error_context_lines):
                    line_num = context_start + i + 1
                    indicator = &#34;&gt;&#34; if line_num == line_number else &#34;*&#34; if line_num == last_successful_line else &#34; &#34;
                    error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

                raise ValueError(
                    f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} (*) was not properly closed before starting a new one at line {line_number} (&gt;).\n\n&#34;
                    f&#34;Error context:\n{error_context}&#34;
                )
            else:
                inside_template_block = True
                idx_open_bracket = line_content.index(&#39;[&#39;)
                remainder = line_content[idx_open_bracket + 1:].strip()
                if remainder:
                    remainder_code = remove_comments(remainder, comment_chars=comment_chars).rstrip()
                    if remainder_code.endswith(&#34;]&#34;):
                        closing_index = remainder_code.rindex(&#39;]&#39;)
                        content_line = remainder_code[:closing_index].strip()
                        if content_line:
                            current_template_content.append(content_line)
                            if debug:print(f&#34;D|DEBUG L{line_number}:{content_line}\n&#34;)
                        content = &#39;\n&#39;.join(current_template_content)
                        template[current_template_key] = ScriptTemplate(
                            content=content,
                            autorefresh=False,
                            definitions=LOCALdefinitions,
                            verbose=verbose,
                            userid=current_template_key)
                        template[current_template_key].refreshvar(globaldefinitions=GLOBALdefinitions)
                        LOCALdefinitions = lambdaScriptdata()
                        inside_template_block = False
                        current_template_key = None
                        current_template_content = []
                        last_successful_line = line_number
                        continue
                    else:
                        current_template_content.append(remainder)
                        if debug:print(f&#34;E|DEBUG L{line_number}:{remainder}\n&#34;)
                last_successful_line = line_number
            continue

        # Handle start of global parameters
        if stripped.startswith(&#39;{&#39;) and not inside_global_params:
            if &#39;}&#39; in stripped:
                global_params_content = stripped
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;
                last_successful_line = line_number
            else:
                inside_global_params = True
                global_params_content = stripped
            continue

        # Handle global parameters inside {...}
        if inside_global_params:
            global_params_content += &#39; &#39; + stripped
            if &#39;}&#39; in stripped:
                inside_global_params = False
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;
                last_successful_line = line_number
            continue

        # Handle attributes
        attribute_match = re.match(r&#39;^(\w+)\s*:\s*\{(.+)\}&#39;, stripped)
        if attribute_match:
            key, attr_content = attribute_match.groups()
            attributes[key] = {}
            cls._parse_attributes(attributes[key], attr_content.strip())
            last_successful_line = line_number
            continue

        # Handle definitions
        definition_match = re.match(r&#39;^(\w+)\s*=\s*(.+)&#39;, stripped)
        if definition_match:
            key, value = definition_match.groups()
            convertedvalue = cls._convert_value(value)
            if key in GLOBALdefinitions:
                if (GLOBALdefinitions.getattr(key) != convertedvalue) or \
                    (getattr(current_var_value, key) != convertedvalue):
                    LOCALdefinitions.setattr(key, convertedvalue)
            else:
                GLOBALdefinitions.setattr(key, convertedvalue)
            last_successful_line = line_number
            setattr(current_var_value, key, convertedvalue)
            continue

        # Handle single-line templates (updated on 20250104 to handle empty content)
        template_match = re.match(r&#39;^(\w+)\s*:\s*(.*)&#39;, stripped)
        if template_match:
            key, content = template_match.groups()
            content = content.strip()  # Strip whitespace for consistency
            if not content:
                content = f&#34;# empty &lt;step {key}&gt;&#34;
                if debug: print(f&#34;F|DEBUG L{line_number}:Empty content detected for key: {key}, default value assigned\n&#34;)
            if debug: print(f&#34;F|DEBUG L{line_number}:{content}\n&#34;)
            template[key] = ScriptTemplate(
                content = content,
                autorefresh = False,
                definitions=LOCALdefinitions,
                verbose=verbose,
                userid=key)
            template[key].refreshvar(globaldefinitions=GLOBALdefinitions)
            if debug:print(f&#34;G|DEBUG L{line_number}:{template[key].content}\n&#34;)
            LOCALdefinitions = lambdaScriptdata()
            last_successful_line = line_number
            continue

        # Unrecognized line
        if verbose:
            print(f&#34;Warning: Unrecognized line at {line_number}: {line_content}&#34;)
            if debug:
                raise ValueError(f&#39;ERROR: stripped content &#34;{stripped}&#34;&#39;)
        last_successful_line = line_number
        continue

    # At the end, check if any template block was left unclosed
    if inside_template_block:
        # Collect error context
        context_start = max(0, last_successful_line - 3)
        context_end = min(len(lines), last_successful_line + 3)
        error_context_lines = lines[context_start:context_end]
        error_context = &#34;&#34;
        for i, error_line in enumerate(error_context_lines):
            line_num = context_start + i
            indicator = &#34;&gt;&#34; if line_num == last_successful_line else &#34; &#34;
            error_context += f&#34;{indicator} {line_num}: {error_line}\n&#34;

        raise ValueError(
            f&#34;Template block &#39;{current_template_key}&#39; starting at line {last_successful_line} was not properly closed.\n\n&#34;
            f&#34;Error context:\n{error_context}&#34;
        )

    # Apply attributes to templates
    for key in attributes:
        if key in template:
            for attr_name, attr_value in attributes[key].items():
                setattr(template[key], attr_name, attr_value)
            template[key]._autorefresh = True # restore the default behavior for the end-user
        else:
            raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)

    # Create and return new instance
    if name is None:
        name = autoname(8)
    instance = cls(
        name=name,
        SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
        section=global_params.get(&#39;section&#39;, 0),
        position=global_params.get(&#39;position&#39;, 0),
        role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
        description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
        userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
        version=global_params.get(&#39;version&#39;, 0.1),
        verbose=global_params.get(&#39;verbose&#39;, False)
    )

    # Convert numeric string keys to integers if numerickeys is True
    if numerickeys:
        numeric_template = {}
        for key, value in template.items():
            if key.isdigit():
                numeric_template[int(key)] = value
            else:
                numeric_template[key] = value
        template = numeric_template

    # Set definitions and template
    instance.DEFINITIONS = GLOBALdefinitions
    instance.TEMPLATE = template

    # Refresh variables
    instance.set_all_variables()

    # Check variables
    instance.check_all_variables(verbose=False)

    return instance</code></pre>
</details>
</dd>
<dt id="group.dscript.parsesyntax_legacy"><code class="name flex">
<span>def <span class="ident">parsesyntax_legacy</span></span>(<span>content, name=None, numerickeys=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a script from a string content.
[ ------------------------------------------------------]
[ Legacy parsesyntax method for backward compatibility. ]
[ ------------------------------------------------------]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>content</code></strong> :&ensp;<code>str</code></dt>
<dd>The string content of the script to be parsed.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the dscript project (if None, it is set randomly)</dd>
<dt><strong><code>numerickeys</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, numeric string keys in the template section are automatically converted into integers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="group.dscript" href="#group.dscript">dscript</a></code></dt>
<dd>A new <code><a title="group.dscript" href="#group.dscript">dscript</a></code> instance populated with the content of the loaded file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If content does not start with the correct DSCRIPT header or the file format is invalid.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The file is expected to follow the same structured format as the one produced by the <code>save()</code> method.</li>
<li>The method processes global parameters, definitions, template lines/items, and attributes. If the file
includes numeric keys as strings (e.g., "0", "1"), they can be automatically converted into integers
if <code>numerickeys=True</code>.</li>
<li>The script structure is dynamically rebuilt, and each section (global parameters, definitions,
template, and attributes) is correctly parsed and assigned to the corresponding parts of the <code><a title="group.dscript" href="#group.dscript">dscript</a></code>
instance.</li>
</ul>
<h2 id="pizzadscript-save-file-format">PIZZA.DSCRIPT SAVE FILE FORMAT</h2>
<p>This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
and control attributes can be defined in a flexible manner.</p>
<h3 id="mandatory-first-line">Mandatory First Line:</h3>
<p>Every DSCRIPT file must begin with the following line:
# DSCRIPT SAVE FILE</p>
<h3 id="structure-overview">Structure Overview:</h3>
<ol>
<li>
<p><strong>Global Parameters Section (Optional):</strong></p>
<ul>
<li>This section defines global script settings, enclosed within curly braces <code>{ }</code>.</li>
<li>Properties include:<ul>
<li><code>SECTIONS</code>: List of section names to be considered (e.g., <code>["DYNAMIC"]</code>).</li>
<li><code>section</code>: Current section index (e.g., <code>0</code>).</li>
<li><code>position</code>: Current script position in the order.</li>
<li><code>role</code>: Defines the role of the script instance (e.g., <code>"dscript instance"</code>).</li>
<li><code>description</code>: A short description of the script (e.g., <code>"dynamic script"</code>).</li>
<li><code>userid</code>: Identifier for the user (e.g., <code>"dscript"</code>).</li>
<li><code>version</code>: Script version (e.g., <code>0.1</code>).</li>
<li><code>verbose</code>: Verbosity flag, typically a boolean (e.g., <code>False</code>).</li>
</ul>
</li>
</ul>
<p>Example:
<code>{
SECTIONS = ['INITIALIZATION', 'SIMULATION']
# Global script parameters
}</code></p>
</li>
<li>
<p><strong>Definitions Section:</strong></p>
<ul>
<li>Variables are defined in Python-like syntax, allowing for dynamic variable substitution.</li>
<li>Variables can be numbers, strings, or lists, and they can include placeholders using <code>$</code>
to delay execution or substitution.</li>
</ul>
<p>Example:
<code>d = 3
# Define a number
periodic = "$p"
# '$' prevents immediate evaluation of 'p'
units = "$metal"
# '$' prevents immediate evaluation of 'metal'
dimension = "${d}"
# Variable substitution
boundary = ['p', 'p', 'p']
# List with a mix of variables and values
atom_style = "$atomic"
# String variable with delayed evaluation</code></p>
</li>
<li>
<p><strong>Templates Section:</strong></p>
<ul>
<li>This section provides a mapping between keys and their corresponding commands or instructions.</li>
<li>The templates reference variables defined in the <strong>Definitions</strong> section or elsewhere.</li>
<li>Syntax:
<code>KEY: INSTRUCTION</code>
where:<ul>
<li><code>KEY</code> can be numeric or alphanumeric.</li>
<li><code>INSTRUCTION</code> represents a command template, often referring to variables using <code>${variable}</code> notation.</li>
</ul>
</li>
</ul>
<p>Example:
<code>units: units ${units}
# Template uses the 'units' variable
dim: dimension ${dimension}
# Template for setting the dimension
bound: boundary ${boundary}
# Template for boundary settings
lattice: lattice ${lattice}
# Lattice template</code></p>
</li>
<li>
<p><strong>Attributes Section:</strong></p>
<ul>
<li>Each template line can have customizable attributes to control behavior and conditions.</li>
<li>Default attributes include:<ul>
<li><code>facultative</code>: If <code>True</code>, the line is optional and can be removed if needed.</li>
<li><code>eval</code>: If <code>True</code>, the line will be evaluated with Python's <code>eval()</code> function.</li>
<li><code>readonly</code>: If <code>True</code>, the line cannot be modified later in the script.</li>
<li><code>condition</code>: An expression that must be satisfied for the line to be included.</li>
<li><code>condeval</code>: If <code>True</code>, the condition will be evaluated using <code>eval()</code>.</li>
<li><code>detectvar</code>: If <code>True</code>, this creates variables in the <strong>Definitions</strong> section if they do not exist.</li>
</ul>
</li>
</ul>
<p>Example:
<code>units: {facultative=False, eval=False, readonly=False, condition="${units}", condeval=False, detectvar=True}
dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}</code></p>
</li>
</ol>
<h2 id="note-on-multiple-definitions">Note On Multiple Definitions</h2>
<p>This example demonstrates how variables defined in the <code>Definitions</code> section are handled for each template.
Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
can use different values for the same variable if redefined.</p>
<p>content = "" "</p>
<h1 id="dscript-save-file">DSCRIPT SAVE FILE</h1>
<h1 id="definitions">Definitions</h1>
<p>var = 10</p>
<h1 id="template-ky1">Template ky1</h1>
<p>key1: Template content with ${var}</p>
<h1 id="definitions_1">Definitions</h1>
<p>var = 20</p>
<h1 id="template-key2">Template key2</h1>
<p>key2: Template content with ${var}</p>
<h1 id="template-key3">Template key3</h1>
<p>key3:[
this is an underfined variable ${var31}
this is an another underfined variable ${var32}
this variables is defined
${var}
]</p>
<p>"" "</p>
<h1 id="parse-content-using-parsesyntax">Parse content using parsesyntax()</h1>
<p>ds = dscript.parsesyntax(content)</p>
<h1 id="key1-should-use-the-first-definition-of-var-10">Key1 should use the first definition of 'var' (10)</h1>
<p>print(ds.key1.definitions.var)
# Output: Template content with 10</p>
<h1 id="key2-should-use-the-updated-definition-of-var-20">Key2 should use the updated definition of 'var' (20)</h1>
<p>print(ds.key2.definitions.var)
# Output: Template content with 10</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parsesyntax_legacy(cls, content, name=None, numerickeys=True):
    &#34;&#34;&#34;
    Parse a script from a string content.
    [ ------------------------------------------------------]
    [ Legacy parsesyntax method for backward compatibility. ]
    [ ------------------------------------------------------]

    Parameters
    ----------
    content : str
        The string content of the script to be parsed.

    name : str
        The name of the dscript project (if None, it is set randomly)

    numerickeys : bool, default=True
        If True, numeric string keys in the template section are automatically converted into integers.

    Returns
    -------
    dscript
        A new `dscript` instance populated with the content of the loaded file.

    Raises
    ------
    ValueError
        If content does not start with the correct DSCRIPT header or the file format is invalid.

    Notes
    -----
    - The file is expected to follow the same structured format as the one produced by the `save()` method.
    - The method processes global parameters, definitions, template lines/items, and attributes. If the file
      includes numeric keys as strings (e.g., &#34;0&#34;, &#34;1&#34;), they can be automatically converted into integers
      if `numerickeys=True`.
    - The script structure is dynamically rebuilt, and each section (global parameters, definitions,
      template, and attributes) is correctly parsed and assigned to the corresponding parts of the `dscript`
      instance.


    PIZZA.DSCRIPT SAVE FILE FORMAT
    -------------------------------
    This script syntax is designed for creating dynamic and customizable input files, where variables, templates,
    and control attributes can be defined in a flexible manner.

    ### Mandatory First Line:
    Every DSCRIPT file must begin with the following line:
        # DSCRIPT SAVE FILE

    ### Structure Overview:

    1. **Global Parameters Section (Optional):**
        - This section defines global script settings, enclosed within curly braces `{ }`.
        - Properties include:
            - `SECTIONS`: List of section names to be considered (e.g., `[&#34;DYNAMIC&#34;]`).
            - `section`: Current section index (e.g., `0`).
            - `position`: Current script position in the order.
            - `role`: Defines the role of the script instance (e.g., `&#34;dscript instance&#34;`).
            - `description`: A short description of the script (e.g., `&#34;dynamic script&#34;`).
            - `userid`: Identifier for the user (e.g., `&#34;dscript&#34;`).
            - `version`: Script version (e.g., `0.1`).
            - `verbose`: Verbosity flag, typically a boolean (e.g., `False`).

        Example:
        ```
        {
            SECTIONS = [&#39;INITIALIZATION&#39;, &#39;SIMULATION&#39;]  # Global script parameters
        }
        ```

    2. **Definitions Section:**
        - Variables are defined in Python-like syntax, allowing for dynamic variable substitution.
        - Variables can be numbers, strings, or lists, and they can include placeholders using `$`
          to delay execution or substitution.

        Example:
        ```
        d = 3                               # Define a number
        periodic = &#34;$p&#34;                     # &#39;$&#39; prevents immediate evaluation of &#39;p&#39;
        units = &#34;$metal&#34;                    # &#39;$&#39; prevents immediate evaluation of &#39;metal&#39;
        dimension = &#34;${d}&#34;                  # Variable substitution
        boundary = [&#39;p&#39;, &#39;p&#39;, &#39;p&#39;]  # List with a mix of variables and values
        atom_style = &#34;$atomic&#34;              # String variable with delayed evaluation
        ```

    3. **Templates Section:**
        - This section provides a mapping between keys and their corresponding commands or instructions.
        - The templates reference variables defined in the **Definitions** section or elsewhere.
        - Syntax:
            ```
            KEY: INSTRUCTION
            ```
            where:
            - `KEY` can be numeric or alphanumeric.
            - `INSTRUCTION` represents a command template, often referring to variables using `${variable}` notation.

        Example:
        ```
        units: units ${units}               # Template uses the &#39;units&#39; variable
        dim: dimension ${dimension}         # Template for setting the dimension
        bound: boundary ${boundary}         # Template for boundary settings
        lattice: lattice ${lattice}         # Lattice template
        ```

    4. **Attributes Section:**
        - Each template line can have customizable attributes to control behavior and conditions.
        - Default attributes include:
            - `facultative`: If `True`, the line is optional and can be removed if needed.
            - `eval`: If `True`, the line will be evaluated with Python&#39;s `eval()` function.
            - `readonly`: If `True`, the line cannot be modified later in the script.
            - `condition`: An expression that must be satisfied for the line to be included.
            - `condeval`: If `True`, the condition will be evaluated using `eval()`.
            - `detectvar`: If `True`, this creates variables in the **Definitions** section if they do not exist.

        Example:
        ```
        units: {facultative=False, eval=False, readonly=False, condition=&#34;${units}&#34;, condeval=False, detectvar=True}
        dim: {facultative=False, eval=False, readonly=False, condition=None, condeval=False, detectvar=True}
        ```

    Note on multiple definitions
    -----------------------------
    This example demonstrates how variables defined in the `Definitions` section are handled for each template.
    Each template retains its own snapshot of the variable definitions at the time it is created, ensuring that templates
    can use different values for the same variable if redefined.

    content = &#34;&#34; &#34;
    # DSCRIPT SAVE FILE

    # Definitions
    var = 10

    # Template ky1
    key1: Template content with ${var}

    # Definitions
    var = 20

    # Template key2
    key2: Template content with ${var}

    # Template key3
    key3:[
        this is an underfined variable ${var31}
        this is an another underfined variable ${var32}
        this variables is defined  ${var}
        ]

    &#34;&#34; &#34;

    # Parse content using parsesyntax()
    ds = dscript.parsesyntax(content)

    # Key1 should use the first definition of &#39;var&#39; (10)
    print(ds.key1.definitions.var)  # Output: Template content with 10

    # Key2 should use the updated definition of &#39;var&#39; (20)
    print(ds.key2.definitions.var)  # Output: Template content with 10


    &#34;&#34;&#34;

    # Split the content into lines
    lines = content.splitlines()
    lines = [line for line in lines if line.strip()]  # Remove blank or empty lines
    # Raise an error if no content is left after removing blank lines
    if not lines:
        raise ValueError(&#34;File/Content is empty or only contains blank lines.&#34;)

    # Initialize containers for global parameters, definitions, templates, and attributes
    global_params = {}
    definitions = lambdaScriptdata()
    template = {}
    attributes = {}

    # State variables to handle multi-line global parameters and attributes
    inside_global_params = False
    inside_attributes = False
    current_attr_key = None  # Ensure this is properly initialized
    global_params_content = &#34;&#34;
    inside_template_block = False  # Track if we are inside a multi-line template
    current_template_key = None    # Track the current template key
    current_template_content = []  # Store lines for the current template content

    # Step 1: Authenticate the file
    if not lines[0].strip().startswith(&#34;# DSCRIPT SAVE FILE&#34;):
        raise ValueError(&#34;File/Content is not a valid DSCRIPT file.&#34;)

    # Step 2: Process each line dynamically
    for line in lines[1:]:
        stripped = line.strip()

        # Ignore empty lines and comments
        if not stripped or stripped.startswith(&#34;#&#34;):
            continue

        # Remove trailing comments
        stripped = remove_comments(stripped)

        # Step 3: Handle global parameters inside {...}
        if stripped.startswith(&#34;{&#34;):
            # Found the opening {, start accumulating global parameters
            inside_global_params = True
            # Remove the opening { and accumulate the remaining content
            global_params_content = stripped[stripped.index(&#39;{&#39;) + 1:].strip()

            # Check if the closing } is also on the same line
            if &#39;}&#39; in global_params_content:
                global_params_content = global_params_content[:global_params_content.index(&#39;}&#39;)].strip()
                inside_global_params = False  # We found the closing } on the same line
                # Now parse the global parameters block
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;  # Reset for the next block
            continue

        if inside_global_params:
            # Accumulate content until the closing } is found
            if stripped.endswith(&#34;}&#34;):
                # Found the closing }, accumulate and process the entire block
                global_params_content += &#34; &#34; + stripped[:stripped.index(&#39;}&#39;)].strip()
                inside_global_params = False  # Finished reading global parameters block

                # Now parse the entire global parameters block
                cls._parse_global_params(global_params_content.strip(), global_params)
                global_params_content = &#34;&#34;  # Reset for the next block if necessary
            else:
                # Continue accumulating if } is not found
                global_params_content += &#34; &#34; + stripped
            continue

        # Step 4: Detect the start of a multi-line template block inside [...]
        if not inside_template_block:
            template_match = re.match(r&#39;(\w+)\s*:\s*\[&#39;, stripped)
            if template_match:
                current_template_key = template_match.group(1)  # Capture the key
                inside_template_block = True
                current_template_content = []  # Reset content list
                continue

        # If inside a template block, accumulate lines until we find the closing ]
        if inside_template_block:
            if stripped == &#34;]&#34;:
                # End of the template block, join the content and store it
                template[current_template_key] = ScriptTemplate(
                    current_template_content,
                    definitions=lambdaScriptdata(**definitions),  # Clone current global definitions
                    verbose=True,
                    userid=current_template_key
                    )
                template[current_template_key].refreshvar()
                inside_template_block = False
                current_template_key = None
                current_template_content = []
            else:
                # Accumulate the current line (without surrounding spaces)
                current_template_content.append(stripped)
            continue

        # Step 5: Handle attributes inside {...}
        if inside_attributes and stripped.endswith(&#34;}&#34;):
            # Finish processing attributes for the current key
            cls._parse_attributes(attributes[current_attr_key], stripped[:-1])  # Remove trailing }
            inside_attributes = False
            current_attr_key = None
            continue

        if inside_attributes:
            # Continue accumulating attributes
            cls._parse_attributes(attributes[current_attr_key], stripped)
            continue

        # Step 6: Determine if the line is a definition, template, or attribute
        definition_match = re.match(r&#39;(\w+)\s*=\s*(.+)&#39;, stripped)
        template_match = re.match(r&#39;(\w+)\s*:\s*(?!\s*\{.*\}\s*$)(.+)&#39;, stripped) # template_match = re.match(r&#39;(\w+)\s*:\s*(?!\{)(.+)&#39;, stripped)
        attribute_match = re.match(r&#39;(\w+)\s*:\s*\{\s*(.+)\s*\}&#39;, stripped)       # attribute_match = re.match(r&#39;(\w+)\s*:\s*\{(.+)\}&#39;, stripped)

        if definition_match:
            # Line is a definition (key=value)
            key, value = definition_match.groups()
            definitions.setattr(key,cls._convert_value(value))

        elif template_match and not inside_template_block:
            # Line is a template (key: content)
            key, content = template_match.groups()
            template[key] = ScriptTemplate(
                content,
                definitions=lambdaScriptdata(**definitions),  # Clone current definitions
                verbose=True,
                userid=current_template_key)
            template[key].refreshvar()

        elif attribute_match:
            # Line is an attribute (key:{attributes...})
            current_attr_key, attr_content = attribute_match.groups()
            attributes[current_attr_key] = {}
            cls._parse_attributes(attributes[current_attr_key], attr_content)
            inside_attributes = not stripped.endswith(&#34;}&#34;)

    # Step 7: Validation and Reconstruction
    # Make sure there are no attributes without a template entry
    for key in attributes:
        if key not in template:
            raise ValueError(f&#34;Attributes found for undefined template key: {key}&#34;)
        # Apply attributes to the corresponding template object
        for attr_name, attr_value in attributes[key].items():
            setattr(template[key], attr_name, attr_value)

    # Step 7: Create and return a new dscript instance
    if name is None:
        name = autoname(8)
    instance = cls(
        name = name,
        SECTIONS=global_params.get(&#39;SECTIONS&#39;, [&#39;DYNAMIC&#39;]),
        section=global_params.get(&#39;section&#39;, 0),
        position=global_params.get(&#39;position&#39;, 0),
        role=global_params.get(&#39;role&#39;, &#39;dscript instance&#39;),
        description=global_params.get(&#39;description&#39;, &#39;dynamic script&#39;),
        userid=global_params.get(&#39;userid&#39;, &#39;dscript&#39;),
        version=global_params.get(&#39;version&#39;, 0.1),
        verbose=global_params.get(&#39;verbose&#39;, False)
    )


    # Convert numeric string keys to integers if numerickeys is True
    if numerickeys:
        numeric_template = {}
        for key, value in template.items():
            # Check if the key is a numeric string
            if key.isdigit():
                numeric_template[int(key)] = value
            else:
                numeric_template[key] = value
        template = numeric_template

    # Set definitions and template
    instance.DEFINITIONS = definitions
    instance.TEMPLATE = template

    # Refresh variables (ensure that variables are detected and added to definitions)
    instance.set_all_variables()

    # Check eval
    instance.check_all_variables(verbose=False)

    # return the new instance
    return instance</code></pre>
</details>
</dd>
<dt id="group.dscript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>scriptcontent, filename=None, foldername=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the provided script content to a specified file in a given folder, with a header if necessary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scriptcontent</code></strong> :&ensp;<code>str</code></dt>
<dd>The content to be written to the file.</dd>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file. If not provided, a random name will be generated.
The extension <code>.txt</code> will be appended if not already present.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The folder where the file will be saved. If not provided, the current working directory is used.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If False (default), raises a <code>FileExistsError</code> if the file already exists. If True, the file will be overwritten if it exists.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The full path to the written file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and <code>overwrite</code> is set to False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>A header is prepended to the content if it does not already exist, using the <code>header</code> method.</li>
<li>The header includes metadata such as the current date, username, hostname, and file details.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write(scriptcontent, filename=None, foldername=None, overwrite=False):
    &#34;&#34;&#34;
    Writes the provided script content to a specified file in a given folder, with a header if necessary.

    Parameters
    ----------
    scriptcontent : str
        The content to be written to the file.

    filename : str, optional
        The name of the file. If not provided, a random name will be generated.
        The extension `.txt` will be appended if not already present.

    foldername : str, optional
        The folder where the file will be saved. If not provided, the current working directory is used.

    overwrite : bool, optional
        If False (default), raises a `FileExistsError` if the file already exists. If True, the file will be overwritten if it exists.

    Returns
    -------
    str
        The full path to the written file.

    Raises
    ------
    FileExistsError
        If the file already exists and `overwrite` is set to False.

    Notes
    -----
    - A header is prepended to the content if it does not already exist, using the `header` method.
    - The header includes metadata such as the current date, username, hostname, and file details.
    &#34;&#34;&#34;
    # Generate a random name if filename is not provided
    if filename is None:
        filename = autoname(8)  # Generates a random name of 8 letters

    # Ensure the filename ends with &#39;.txt&#39;
    if not filename.endswith(&#39;.txt&#39;):
        filename += &#39;.txt&#39;

    # Handle foldername and relative paths
    if foldername is None or foldername == &#34;&#34;:
        # If foldername is empty or None, use current working directory for relative paths
        if not os.path.isabs(filename):
            filepath = os.path.join(os.getcwd(), filename)
        else:
            filepath = filename  # If filename is absolute, use it directly
    else:
        # If foldername is provided and filename is not absolute, use foldername
        if not os.path.isabs(filename):
            filepath = os.path.join(foldername, filename)
        else:
            filepath = filename

    # Check if file already exists, raise exception if it does and overwrite is False
    if os.path.exists(filepath) and not overwrite:
        raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

    # Count total and non-empty lines in the content
    total_lines = len(scriptcontent.splitlines())
    non_empty_lines = sum(1 for line in scriptcontent.splitlines() if line.strip())

    # Prepare header if not already present
    if not scriptcontent.startswith(&#34;# DSCRIPT SAVE FILE&#34;):
        fname = os.path.basename(filepath)  # Extracts the filename (e.g., &#34;myscript.txt&#34;)
        name, _ = os.path.splitext(fname)   # Removes the extension, e.g., &#34;myscript&#34;
        metadata = get_metadata()           # retrieve all metadata (statically)
        header = dscript.header(name=name, verbosity=True,style=1,filepath=filepath,
                version = metadata[&#34;version&#34;], license = metadata[&#34;license&#34;], email = metadata[&#34;email&#34;])
        # Add line count information to the header
        footer = frame_header(
            lines=[
                f&#34;Total lines written: {total_lines}&#34;,
                f&#34;Non-empty lines: {non_empty_lines}&#34;
            ],
            style=1
        )
        scriptcontent = header + &#34;\n&#34; + scriptcontent + &#34;\n&#34; + footer

    # Write the content to the file
    with open(filepath, &#39;w&#39;) as file:
        file.write(scriptcontent)
    return filepath</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="group.dscript.add_dynamic_script"><code class="name flex">
<span>def <span class="ident">add_dynamic_script</span></span>(<span>self, key, content='', userid=None, definitions=None, verbose=None, autorefresh=True, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a dynamic script step to the dscript object.</p>
<h2 id="parameters">Parameters:</h2>
<p>key : str
The key for the dynamic script (usually an index or step identifier).
content : str or list of str, optional
The content (template) of the script step.
definitions : lambdaScriptdata, optional
The merged variable space (STATIC + GLOBAL + LOCAL).
verbose : bool, optional
If None, self.verbose will be used. Controls verbosity of the template.
autorefresh : bool, optional
If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
Default = True
USER : dict
Additional user variables that override the definitions for this step.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dynamic_script(self, key, content=&#34;&#34;, userid=None, definitions=None, verbose=None, autorefresh=True, **USER):
    &#34;&#34;&#34;
    Add a dynamic script step to the dscript object.

    Parameters:
    -----------
    key : str
        The key for the dynamic script (usually an index or step identifier).
    content : str or list of str, optional
        The content (template) of the script step.
    definitions : lambdaScriptdata, optional
        The merged variable space (STATIC + GLOBAL + LOCAL).
    verbose : bool, optional
        If None, self.verbose will be used. Controls verbosity of the template.
    autorefresh : bool, optional
        If True, detected variables (e.g., var) and undefined are assiged to their default value (e.g., ${var})
        Default = True
    USER : dict
        Additional user variables that override the definitions for this step.
    &#34;&#34;&#34;
    if definitions is None:
        definitions = lambdaScriptdata()
    if verbose is None:
        verbose = self.verbose
    # Create a new ScriptTemplate and add it to the TEMPLATE
    self.TEMPLATE[key] = ScriptTemplate(
        content=content,
        definitions=self.DEFINITIONS+definitions,
        verbose=verbose,
        userid = key if userid is None else userid,
        autorefresh=autorefresh,
        **USER
    )</code></pre>
</details>
</dd>
<dt id="group.dscript.check_all_variables"><code class="name flex">
<span>def <span class="ident">check_all_variables</span></span>(<span>self, verbose=True, seteval=True, output=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks for undefined variables for each TEMPLATE key in the dscript object.</p>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional, default=True
If True, prints information about variables for each TEMPLATE key.
Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.</p>
<p>seteval : bool, optional, default=True
If True, sets the <code>eval</code> attribute to True if at least one variable is defined or set to its default value.</p>
<p>output : bool, optional, default=False
If True, returns a dictionary with lists of default variables, set variables, and undefined variables.</p>
<h2 id="returns">Returns:</h2>
<p>out : dict, optional
If <code>output=True</code>, returns a dictionary with the following structure:
- "defaultvalues": List of variables set to their default value (${varname}).
- "setvalues": List of variables defined with values other than their default.
- "undefined": List of variables that are undefined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_all_variables(self, verbose=True, seteval=True, output=False):
    &#34;&#34;&#34;
    Checks for undefined variables for each TEMPLATE key in the dscript object.

    Parameters:
    -----------
    verbose : bool, optional, default=True
        If True, prints information about variables for each TEMPLATE key.
        Shows [-] if the variable is set to its default value, [+] if it is defined, and [ ] if it is undefined.

    seteval : bool, optional, default=True
        If True, sets the `eval` attribute to True if at least one variable is defined or set to its default value.

    output : bool, optional, default=False
        If True, returns a dictionary with lists of default variables, set variables, and undefined variables.

    Returns:
    --------
    out : dict, optional
        If `output=True`, returns a dictionary with the following structure:
        - &#34;defaultvalues&#34;: List of variables set to their default value (${varname}).
        - &#34;setvalues&#34;: List of variables defined with values other than their default.
        - &#34;undefined&#34;: List of variables that are undefined.
    &#34;&#34;&#34;
    out = {&#34;defaultvalues&#34;: [], &#34;setvalues&#34;: [], &#34;undefined&#34;: []}

    for key in self.TEMPLATE:
        template = self.TEMPLATE[key]
        # Call the check_variables method of ScriptTemplate for each TEMPLATE key
        result = template.check_variables(verbose=verbose, seteval=seteval)

        # Update the output dictionary if needed
        out[&#34;defaultvalues&#34;].extend(result[&#34;defaultvalues&#34;])
        out[&#34;setvalues&#34;].extend(result[&#34;setvalues&#34;])
        out[&#34;undefined&#34;].extend(result[&#34;undefined&#34;])

    if output:
        return out</code></pre>
</details>
</dd>
<dt id="group.dscript.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, behavior='fixing', verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean the TEMPLATE by removing or fixing empty steps.</p>
<p>An empty step is defined as one where its content is [], "", or None.</p>
<h2 id="parameters">Parameters</h2>
<p>behavior (str, optional):
Determines the action to perform on empty steps.
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.
Defaults to 'fixing'.
verbose (bool, optional):
If True, prints informational messages about the actions taken.
If False, operates silently.
Defaults to False.</p>
<h2 id="raises">Raises</h2>
<p>ValueError:
If the provided behavior is not 'removing' or 'fixing'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, behavior=&#39;fixing&#39;, verbose=False):
    &#34;&#34;&#34;
    Clean the TEMPLATE by removing or fixing empty steps.

    An empty step is defined as one where its content is [], &#34;&#34;, or None.

    Parameters:
        behavior (str, optional):
            Determines the action to perform on empty steps.
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.
            Defaults to &#39;fixing&#39;.
        verbose (bool, optional):
            If True, prints informational messages about the actions taken.
            If False, operates silently.
            Defaults to False.

    Raises:
        ValueError:
            If the provided behavior is not &#39;removing&#39; or &#39;fixing&#39;.
    &#34;&#34;&#34;
    # Validate the &#39;behavior&#39; parameter
    if behavior not in {&#39;removing&#39;, &#39;fixing&#39;}:
        raise ValueError(&#34;Parameter &#39;behavior&#39; must be either &#39;removing&#39; or &#39;fixing&#39;.&#34;)

    # Iterate over a list of keys to avoid RuntimeError due to dict size change during iteration
    for key in list(self.TEMPLATE.keys()):
        step = self.TEMPLATE[key]
        content = step.content

        # Check if the step is empty
        if content in [[], &#34;&#34;, None,[&#34;&#34;],[None],[[]]]:
            if behavior == &#39;removing&#39;:
                # Remove the step entirely from TEMPLATE
                del self.TEMPLATE[key]
                if verbose:
                    print(f&#34;Removed empty step: {key}&#34;)
            elif behavior == &#39;fixing&#39;:
                # Replace the content with a default comment
                step.content = [f&#34;# empty &lt;step {key}&gt;&#34;]
                if verbose:
                    print(f&#34;Fixed empty step: {key} by adding a comment.&#34;)</code></pre>
</details>
</dd>
<dt id="group.dscript.createEmptyVariables"><code class="name flex">
<span>def <span class="ident">createEmptyVariables</span></span>(<span>self, vars)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates empty variables in DEFINITIONS if they don't already exist.</p>
<h2 id="parameters">Parameters:</h2>
<p>vars : str or list of str
The variable name or list of variable names to be created in DEFINITIONS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createEmptyVariables(self, vars):
    &#34;&#34;&#34;
    Creates empty variables in DEFINITIONS if they don&#39;t already exist.

    Parameters:
    -----------
    vars : str or list of str
        The variable name or list of variable names to be created in DEFINITIONS.
    &#34;&#34;&#34;
    if isinstance(vars, str):
        vars = [vars]  # Convert single variable name to list for uniform processing
    for varname in vars:
        if varname not in self.DEFINITIONS:
            self.DEFINITIONS.setattr(varname,&#34;${&#34; + varname + &#34;}&#34;)</code></pre>
</details>
</dd>
<dt id="group.dscript.detect_all_variables"><code class="name flex">
<span>def <span class="ident">detect_all_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detects all variables across all templates in the dscript object.</p>
<p>This method iterates through all ScriptTemplate objects in the dscript and
collects variables from each template using the detect_variables method.</p>
<h2 id="returns">Returns:</h2>
<p>list
A sorted list of unique variables detected in all templates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_all_variables(self):
    &#34;&#34;&#34;
    Detects all variables across all templates in the dscript object.

    This method iterates through all ScriptTemplate objects in the dscript and
    collects variables from each template using the detect_variables method.

    Returns:
    --------
    list
        A sorted list of unique variables detected in all templates.
    &#34;&#34;&#34;
    all_variables = set()  # Use a set to avoid duplicates
    # Iterate through all templates in the dscript object
    for template_key, template in self.TEMPLATE.items():
        # Ensure the template is a ScriptTemplate and has the detect_variables method
        if isinstance(template, ScriptTemplate):
            detected_vars = template.detect_variables()
            all_variables.update(detected_vars)  # Add the detected variables to the set
    return sorted(all_variables)  # Return a sorted list of unique variables</code></pre>
</details>
</dd>
<dt id="group.dscript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, printflag=None, verbose=None, softrun=False, return_definitions=False, comment_chars='#%', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes or previews all <code>ScriptTemplate</code> instances in <code>TEMPLATE</code>, concatenating their processed content.
Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with <code>softrun</code>.
Accumulates definitions across all templates if <code>return_definitions=True</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>printflag</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, enables print output during execution. Defaults to the instance's print flag if <code>None</code>.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, includes headers and footers in the output, providing additional detail.
Defaults to the instance's verbosity setting if <code>None</code>.</dd>
<dt><strong><code>softrun</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, executes the script in a preliminary mode:
- Bypasses full variable substitution for a preview of the content, useful for validating structure.
- If <code>False</code> (default), performs full processing, including variable substitutions and evaluations.</dd>
<dt><strong><code>return_definitions</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If <code>True</code>, returns a tuple where the second element contains accumulated definitions from all templates.
If <code>False</code> (default), returns only the concatenated output.</dd>
<dt><strong><code>comment_chars</code></strong> :&ensp;<code>str</code>, optional <code>(default: "#%")</code></dt>
<dd>A string containing characters to identify the start of a comment.
Any of these characters will mark the beginning of a comment unless within quotes.</dd>
<dt><strong><code>**USER</code></strong> :&ensp;<code>keyword arguments</code></dt>
<dd>Allows for the provision of additional user-defined definitions, where each keyword represents a
definition key and the associated value represents the definition's content. These definitions
can override or supplement template-level definitions during execution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code> or <code>tuple</code></dt>
<dd>
<ul>
<li>If <code>return_definitions=False</code>, returns the concatenated output of all <code>ScriptTemplate</code> instances,
with optional headers, footers, and execution summary based on verbosity.</li>
<li>If <code>return_definitions=True</code>, returns a tuple of (<code>output</code>, <code>accumulated_definitions</code>), where
<code>accumulated_definitions</code> contains all definitions used across templates.</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Each <code>ScriptTemplate</code> in <code>TEMPLATE</code> is processed individually using its own <code>do()</code> method.</li>
<li>The <code>softrun</code> mode provides a preliminary content preview without full variable substitution,
helpful for inspecting the script structure or gathering local definitions.</li>
<li>When <code>verbose</code> is enabled, the method includes detailed headers, footers, and a summary of processed and
ignored items, providing insight into the script's construction and variable usage.</li>
<li>Accumulated definitions from each <code>ScriptTemplate</code> are combined if <code>return_definitions=True</code>, which can be
useful for tracking all variables and definitions applied across the templates.</li>
</ul>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; dscript_instance = dscript(name=&quot;ExampleScript&quot;)
&gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
...     content=[&quot;units ${units}&quot;, &quot;boundary ${boundary}&quot;],
...     definitions=lambdaScriptdata(units=&quot;lj&quot;, boundary=&quot;p p p&quot;),
...     attributes={'eval': True}
... )
&gt;&gt;&gt; dscript_instance.do(verbose=True, units=&quot;real&quot;)
# Output:
# --------------
# TEMPLATE &quot;ExampleScript&quot;
# --------------
units real
boundary p p p
# ---&gt; Total items: 2 - Ignored items: 0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, printflag=None, verbose=None, softrun=False, return_definitions=False,comment_chars=&#34;#%&#34;, **USER):
    &#34;&#34;&#34;
    Executes or previews all `ScriptTemplate` instances in `TEMPLATE`, concatenating their processed content.
    Allows for optional headers and footers based on verbosity settings, and offers a preliminary preview mode with `softrun`.
    Accumulates definitions across all templates if `return_definitions=True`.

    Parameters
    ----------
    printflag : bool, optional
        If `True`, enables print output during execution. Defaults to the instance&#39;s print flag if `None`.
    verbose : bool, optional
        If `True`, includes headers and footers in the output, providing additional detail.
        Defaults to the instance&#39;s verbosity setting if `None`.
    softrun : bool, optional
        If `True`, executes the script in a preliminary mode:
        - Bypasses full variable substitution for a preview of the content, useful for validating structure.
        - If `False` (default), performs full processing, including variable substitutions and evaluations.
    return_definitions : bool, optional
        If `True`, returns a tuple where the second element contains accumulated definitions from all templates.
        If `False` (default), returns only the concatenated output.
    comment_chars : str, optional (default: &#34;#%&#34;)
        A string containing characters to identify the start of a comment.
        Any of these characters will mark the beginning of a comment unless within quotes.
    **USER : keyword arguments
        Allows for the provision of additional user-defined definitions, where each keyword represents a
        definition key and the associated value represents the definition&#39;s content. These definitions
        can override or supplement template-level definitions during execution.

    Returns
    -------
    str or tuple
        - If `return_definitions=False`, returns the concatenated output of all `ScriptTemplate` instances,
          with optional headers, footers, and execution summary based on verbosity.
        - If `return_definitions=True`, returns a tuple of (`output`, `accumulated_definitions`), where
          `accumulated_definitions` contains all definitions used across templates.

    Notes
    -----
    - Each `ScriptTemplate` in `TEMPLATE` is processed individually using its own `do()` method.
    - The `softrun` mode provides a preliminary content preview without full variable substitution,
      helpful for inspecting the script structure or gathering local definitions.
    - When `verbose` is enabled, the method includes detailed headers, footers, and a summary of processed and
      ignored items, providing insight into the script&#39;s construction and variable usage.
    - Accumulated definitions from each `ScriptTemplate` are combined if `return_definitions=True`, which can be
      useful for tracking all variables and definitions applied across the templates.

    Example
    -------
    &gt;&gt;&gt; dscript_instance = dscript(name=&#34;ExampleScript&#34;)
    &gt;&gt;&gt; dscript_instance.TEMPLATE[0] = ScriptTemplate(
    ...     content=[&#34;units ${units}&#34;, &#34;boundary ${boundary}&#34;],
    ...     definitions=lambdaScriptdata(units=&#34;lj&#34;, boundary=&#34;p p p&#34;),
    ...     attributes={&#39;eval&#39;: True}
    ... )
    &gt;&gt;&gt; dscript_instance.do(verbose=True, units=&#34;real&#34;)
    # Output:
    # --------------
    # TEMPLATE &#34;ExampleScript&#34;
    # --------------
    units real
    boundary p p p
    # ---&gt; Total items: 2 - Ignored items: 0
    &#34;&#34;&#34;

    printflag = self.printflag if printflag is None else printflag
    verbose = self.verbose if verbose is None else verbose
    header = f&#34;# --------------[ TEMPLATE \&#34;{self.name}\&#34; ]--------------&#34; if verbose else &#34;&#34;
    footer = &#34;# --------------------------------------------&#34; if verbose else &#34;&#34;

    # Initialize output, counters, and optional definitions accumulator
    output = [header]
    non_empty_lines = 0
    ignored_lines = 0
    accumulated_definitions = self.DEFINITIONS if return_definitions else None

    for key, template in self.TEMPLATE.items():
        # Process each template with softrun if enabled, otherwise use full processing
        result = template.do(softrun=softrun,globaldefinitions=self.DEFINITIONS,USER=lambdaScriptdata(**USER))
        if result:
            # Apply comment removal based on verbosity
            final_result = result if verbose else remove_comments(result,comment_chars=comment_chars)
            if final_result or verbose:
                output.append(final_result)
                non_empty_lines += 1
            else:
                ignored_lines += 1
            # Accumulate definitions if return_definitions is enabled
            if return_definitions:
                accumulated_definitions += template.definitions
        else:
            ignored_lines += 1

    # Add footer summary if verbose
    nel_word = &#39;items&#39; if non_empty_lines &gt; 1 else &#39;item&#39;
    il_word = &#39;items&#39; if ignored_lines &gt; 1 else &#39;item&#39;
    footer += f&#34;\n# ---&gt; Total {nel_word}: {non_empty_lines} - Ignored {il_word}: {ignored_lines}&#34; if verbose else &#34;&#34;
    output.append(footer)

    # Concatenate output and determine return type based on return_definitions
    output_content = &#34;\n&#34;.join(output)
    return (output_content, accumulated_definitions) if return_definitions else output_content</code></pre>
</details>
</dd>
<dt id="group.dscript.flattenvariables"><code class="name flex">
<span>def <span class="ident">flattenvariables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flatten the variable definitions for each step based on usage and precedence.</p>
<p>This method ensures that for each step:
- Only the variables used in the template are present in <code>self[i].definitions</code>.
- The value of each variable is determined based on the following precedence:
1. Global Definitions (<code>self.DEFINITIONS</code>)
2. Current Step Definitions (<code>self[i].definitions</code>)
3. Previous Step Definitions (<code>self[i-1].definitions</code>, etc.)
4. Protected Variables (<code>"$variable_name"</code>)</p>
<p>The method updates <code>self[i].definitions</code> to include only the necessary variables with their resolved values.
Unused variables are removed from each step's definitions after resolution, <strong>excluding</strong> protected attributes.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If a step or global definitions lack the necessary attributes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flattenvariables(self):
    &#34;&#34;&#34;
    Flatten the variable definitions for each step based on usage and precedence.

    This method ensures that for each step:
        - Only the variables used in the template are present in `self[i].definitions`.
        - The value of each variable is determined based on the following precedence:
            1. Global Definitions (`self.DEFINITIONS`)
            2. Current Step Definitions (`self[i].definitions`)
            3. Previous Step Definitions (`self[i-1].definitions`, etc.)
            4. Protected Variables (`&#34;$variable_name&#34;`)

    The method updates `self[i].definitions` to include only the necessary variables with their resolved values.
    Unused variables are removed from each step&#39;s definitions after resolution, **excluding** protected attributes.

    Raises:
        AttributeError: If a step or global definitions lack the necessary attributes.
    &#34;&#34;&#34;
    # Define the set of protected attributes that must never be removed
    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    # Initialize local_definitions with a copy of global definitions to prevent mutation
    local_definitions = lambdaScriptdata(**self.DEFINITIONS.__dict__)

    # Iterate through each step in order
    for i in range(len(self)):
        step = self[i]
        step_definitions = step.definitions

        # Detect variables used in the current step&#39;s template
        variables_used = step.detect_variables()

        # Temporary dictionary to store resolved variable values
        resolved_vars = {}

        # Resolve each variable&#39;s value based on precedence
        for var in variables_used:
            if hasattr(step_definitions, var):
                # Variable defined in the current step&#39;s definitions
                resolved_vars[var] = getattr(step_definitions, var)
            elif hasattr(local_definitions, var):
                # Variable inherited from previous definitions (global or prior steps)
                resolved_vars[var] = getattr(local_definitions, var)
            else:
                # Variable not found; assign protected format
                resolved_vars[var] = f&#34;${var}&#34;

        # Remove any variables in step_definitions not in variables_used and not in excluded_keys
        existing_vars = list(step_definitions.__dict__.keys())
        for var in existing_vars:
            if var not in variables_used and var not in excluded_keys:
                delattr(step_definitions, var)

        # Assign resolved variables to step_definitions
        for var, value in resolved_vars.items():
            setattr(step_definitions, var, value)

        # Update local_definitions by merging with step_definitions
        # Only variables used in this step are updated in local_definitions
        local_definitions = local_definitions + step_definitions</code></pre>
</details>
</dd>
<dt id="group.dscript.generator"><code class="name flex">
<span>def <span class="ident">generator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>STR</code></dt>
<dd>generated code corresponding to dscript (using dscript syntax/language).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generator(self):
    &#34;&#34;&#34;
    Returns
    -------
    STR
        generated code corresponding to dscript (using dscript syntax/language).

    &#34;&#34;&#34;
    return self.save(generatoronly=True)</code></pre>
</details>
</dd>
<dt id="group.dscript.get_attributes_by_index"><code class="name flex">
<span>def <span class="ident">get_attributes_by_index</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the attributes of the ScriptTemplate at the specified index.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_attributes_by_index(self, index):
    &#34;&#34;&#34; Returns the attributes of the ScriptTemplate at the specified index.&#34;&#34;&#34;
    key = list(self.TEMPLATE.keys())[index]
    return self.TEMPLATE[key].attributes</code></pre>
</details>
</dd>
<dt id="group.dscript.get_content_by_index"><code class="name flex">
<span>def <span class="ident">get_content_by_index</span></span>(<span>self, index, do=True, protected=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the content of the ScriptTemplate at the specified index.</p>
<h2 id="parameters">Parameters:</h2>
<p>index : int
The index of the template in the TEMPLATE dictionary.
do : bool, optional (default=True)
If True, the content will be processed based on conditions and evaluation flags.
protected : bool, optional (default=True)
Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).</p>
<h2 id="returns">Returns:</h2>
<p>str or list of str
The content of the template after processing, or an empty string if conditions or evaluation flags block it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_by_index(self, index, do=True, protected=True):
    &#34;&#34;&#34;
    Returns the content of the ScriptTemplate at the specified index.

    Parameters:
    -----------
    index : int
        The index of the template in the TEMPLATE dictionary.
    do : bool, optional (default=True)
        If True, the content will be processed based on conditions and evaluation flags.
    protected : bool, optional (default=True)
        Controls whether variable evaluation is protected (e.g., prevents overwriting certain definitions).

    Returns:
    --------
    str or list of str
        The content of the template after processing, or an empty string if conditions or evaluation flags block it.
    &#34;&#34;&#34;
    key = list(self.TEMPLATE.keys())[index]
    s = self.TEMPLATE[key].content
    att = self.TEMPLATE[key].attributes
    # Return an empty string if the facultative attribute is True and do is True
    if att[&#34;facultative&#34;] and do:
        return &#34;&#34;
    # Evaluate the condition (if any)
    if att[&#34;condition&#34;] is not None:
        cond = eval(self.DEFINITIONS.formateval(att[&#34;condition&#34;], protected))
    else:
        cond = True
    # If the condition is met, process the content
    if cond:
        # Apply formateval only if the eval attribute is True and do is True
        if att[&#34;eval&#34;] and do:
            if isinstance(s, list):
                # Apply formateval to each item in the list if s is a list
                return [self.DEFINITIONS.formateval(line, protected) for line in s]
            else:
                # Apply formateval to the single string content
                return self.DEFINITIONS.formateval(s, protected)
        else:
            return s  # Return the raw content if no evaluation is needed
    elif do:
        return &#34;&#34;  # Return an empty string if the condition is not met and do is True
    else:
        return s  # Return the raw content if do is False</code></pre>
</details>
</dd>
<dt id="group.dscript.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    return ((key, s.content) for key, s in self.TEMPLATE.items())</code></pre>
</details>
</dd>
<dt id="group.dscript.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the keys of the TEMPLATE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    &#34;&#34;&#34;Return the keys of the TEMPLATE.&#34;&#34;&#34;
    return self.TEMPLATE.keys()</code></pre>
</details>
</dd>
<dt id="group.dscript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, key, include_global=True, verbose=False, order='stable', details=False)</span>
</code></dt>
<dd>
<div class="desc"><p>List all unique values taken by a specified key across global definitions and all steps in sequential order.</p>
<h2 id="parameters">Parameters</h2>
<p>key (str): The key whose values are to be listed.
include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
order (str, optional): The order in which to list the unique values. Options are 'stable', 'ascend', 'descend'. Defaults to 'stable'.
details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.</p>
<h2 id="returns">Returns</h2>
<p>list or scalar or VariableOccurrences or None:
- If <code>details=False</code>:
- Returns a list of unique values associated with the key, ordered as specified.
- If only one unique value exists, returns it as a scalar.
- Returns None if the key is not found in any global or step definitions.
- If <code>details=True</code>:
- Returns a VariableOccurrences object containing detailed occurrence information across scopes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, key, include_global=True, verbose=False, order=&#39;stable&#39;, details=False):
    &#34;&#34;&#34;
    List all unique values taken by a specified key across global definitions and all steps in sequential order.

    Parameters:
        key (str): The key whose values are to be listed.
        include_global (bool, optional): If True, include global definitions in the search. Defaults to True.
        verbose (bool, optional): If True, print warnings about steps where the key is missing and list available keys. Defaults to False.
        order (str, optional): The order in which to list the unique values. Options are &#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;. Defaults to &#39;stable&#39;.
        details (bool, optional): If True, return a VariableOccurrences object containing detailed occurrence information. If False, return a list or scalar as before. Defaults to False.

    Returns:
        list or scalar or VariableOccurrences or None:
            - If `details=False`:
                - Returns a list of unique values associated with the key, ordered as specified.
                - If only one unique value exists, returns it as a scalar.
                - Returns None if the key is not found in any global or step definitions.
            - If `details=True`:
                - Returns a VariableOccurrences object containing detailed occurrence information across scopes.
    &#34;&#34;&#34;
    # Validate &#39;order&#39; parameter
    if order not in {&#39;stable&#39;, &#39;ascend&#39;, &#39;descend&#39;}:
        raise ValueError(&#34;Parameter &#39;order&#39; must be one of &#39;stable&#39;, &#39;ascend&#39;, or &#39;descend&#39;.&#34;)

    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    unique_values = []
    seen_values = set()

    available_keys_set = set()

    # Helper function to compare lists
    def lists_are_equal(list1, list2):
        return list1 == list2

    # Function to add a key_value to unique_values
    def add_value(kv):
        if isinstance(kv, list):
            # Convert list to tuple for hashability
            try:
                kv_tuple = tuple(kv)
                if kv_tuple not in seen_values:
                    unique_values.append(kv.copy())  # Append a copy to preserve the list
                    seen_values.add(kv_tuple)
            except TypeError:
                # If list contains unhashable items, compare manually
                if not any(lists_are_equal(kv, existing) for existing in unique_values if isinstance(existing, list)):
                    unique_values.append(kv.copy())
        else:
            if kv not in seen_values:
                unique_values.append(kv)
                seen_values.add(kv)

    # Data structures for detailed occurrences
    occurrences_data = defaultdict(list)  # {&#39;global&#39;: [value], &#39;local&#39;: [(step, value), ...]}

    # Include global definitions
    if include_global and hasattr(self.DEFINITIONS, key):
        key_value = getattr(self.DEFINITIONS, key)
        if isinstance(key_value, list):
            add_value(key_value)
            if details:
                occurrences_data[&#39;global&#39;] = key_value.copy()
        else:
            add_value(key_value)
            if details:
                occurrences_data[&#39;global&#39;] = key_value
    elif include_global and verbose:
        # Collect available keys in global definitions, excluding specified keys
        available_keys = [
            k for k in self.DEFINITIONS.__dict__
            if k != key and k not in excluded_keys
        ]
        available_keys_set.update(available_keys)

    # Traverse through steps
    for step_key, step in self.TEMPLATE.items():
        if hasattr(step.definitions, key):
            key_value = getattr(step.definitions, key)
            if isinstance(key_value, list):
                add_value(key_value)
                if details:
                    occurrences_data[&#39;local&#39;].append((step_key, key_value.copy()))
            else:
                add_value(key_value)
                if details:
                    occurrences_data[&#39;local&#39;].append((step_key, key_value))
        else:
            if verbose:
                # Collect available keys in this step, excluding specified keys
                available_keys = [
                    k for k in step.definitions.__dict__
                    if k != key and k not in excluded_keys
                ]
                available_keys_set.update(available_keys)

    # Verbose warnings
    if verbose and available_keys_set:
        available_keys_sorted = sorted(list(available_keys_set))
        print(f&#34;Warning: The key &#39;{key}&#39; is missing in some steps or global definitions.&#34;)
        print(f&#34;Available keys in those contexts: {available_keys_sorted}&#34;)

    # Ordering
    if order == &#39;stable&#39;:
        ordered_values = unique_values
    else:
        # To sort, ensure all elements are of the same type
        try:
            if all(isinstance(v, list) for v in unique_values):
                if order == &#39;ascend&#39;:
                    ordered_values = sorted(unique_values)
                else:
                    ordered_values = sorted(unique_values, reverse=True)
            elif all(isinstance(v, type(unique_values[0])) for v in unique_values):
                if order == &#39;ascend&#39;:
                    ordered_values = sorted(unique_values)
                else:
                    ordered_values = sorted(unique_values, reverse=True)
            else:
                raise TypeError
        except TypeError:
            if verbose:
                print(&#34;Warning: Cannot sort values due to mixed or non-comparable types. Returning values in their original order.&#34;)
            ordered_values = unique_values

    if details:
        # Prepare data for VariableOccurrences
        # Convert defaultdict to regular dict
        occurrences_dict = dict(occurrences_data)

        if key.lower() == &#34;all&#34;:
            # Collect all keys and their occurrences
            all_keys = set()
            # Include global definitions if specified
            if include_global:
                global_keys = set(self.DEFINITIONS.__dict__.keys()) - excluded_keys
                all_keys.update(global_keys)
            # Include keys from all steps
            for step in self.TEMPLATE.values():
                step_keys = set(step.definitions.__dict__.keys()) - excluded_keys
                all_keys.update(step_keys)

            # Remove the &#39;all&#39; key itself if present
            all_keys.discard(&#34;all&#34;)

            variables_data = {}
            for var in all_keys:
                var_data = defaultdict(list)
                # Include global definitions
                if include_global and hasattr(self.DEFINITIONS, var):
                    var_value = getattr(self.DEFINITIONS, var)
                    if isinstance(var_value, list):
                        var_data[&#39;global&#39;].append(var_value.copy())  # Directly append the value
                    else:
                        var_data[&#39;global&#39;].append(var_value)
                # Traverse through steps
                for step_key, step in self.TEMPLATE.items():
                    if hasattr(step.definitions, var):
                        var_value = getattr(step.definitions, var)
                        if isinstance(var_value, list):
                            var_data[&#39;local&#39;].append((step_key, var_value.copy()))
                        else:
                            var_data[&#39;local&#39;].append((step_key, var_value))
                variables_data[var] = dict(var_data)
            return VariableOccurrences(variables_data, variables=None)  # variables=None implies multiple variables

        else:
            # Single variable case
            return VariableOccurrences(occurrences_dict, variables=key)

    # Determine return value
    if not unique_values:
        if verbose:
            print(f&#34;No values found for key &#39;{key}&#39; in any step or global definitions.&#34;)
        return None
    elif len(unique_values) == 1:
        return unique_values[0]
    else:
        return ordered_values</code></pre>
</details>
</dd>
<dt id="group.dscript.pipescript"><code class="name flex">
<span>def <span class="ident">pipescript</span></span>(<span>self, *keys, printflag=None, verbose=None, verbosity=None, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pipescript object by combining script objects corresponding to the given keys.</p>
<h2 id="parameters">Parameters:</h2>
<p><em>keys : one or more keys that correspond to the <code>TEMPLATE</code> entries.
printflag : bool, optional
Whether to enable printing of additional information.
verbose : bool, optional
Whether to run in verbose mode for debugging or detailed output.
</em>*USER : dict, optional
Additional user-defined variables to pass into the script.</p>
<h2 id="returns">Returns:</h2>
<p>A <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> object that combines the script objects generated from the selected
dscript subobjects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipescript(self, *keys, printflag=None, verbose=None, verbosity=None, **USER):
    &#34;&#34;&#34;
    Returns a pipescript object by combining script objects corresponding to the given keys.

    Parameters:
    -----------
    *keys : one or more keys that correspond to the `TEMPLATE` entries.
    printflag : bool, optional
        Whether to enable printing of additional information.
    verbose : bool, optional
        Whether to run in verbose mode for debugging or detailed output.
    **USER : dict, optional
        Additional user-defined variables to pass into the script.

    Returns:
    --------
    A `pipescript` object that combines the script objects generated from the selected
    dscript subobjects.
    &#34;&#34;&#34;
    # Start with an empty pipescript
    # combined_pipescript = None
    # # Iterate over the provided keys to extract corresponding subobjects
    # for key in keys:
    #     # Extract the dscript subobject for the given key
    #     sub_dscript = self(key)
    #     # Convert the dscript subobject to a script object, passing USER, printflag, and verbose
    #     script_obj = sub_dscript.script(printflag=printflag, verbose=verbose, **USER)
    #     # Combine script objects into a pipescript object
    #     if combined_pipescript is None:
    #         combined_pipescript = pipescript(script_obj)  # Initialize pipescript
    #     else:
    #         combined_pipescript = combined_pipescript | script_obj  # Use pipe operator
    # if combined_pipescript is None:
    #     ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
    # return combined_pipescript
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Loop over all keys in TEMPLATE and combine them
    combined_pipescript = None
    localvariables = scriptdata()
    for key in self.keys():
        # Create a new dscript object with only the current key in TEMPLATE
        focused_dscript = dscript(name=f&#34;{self.name}:{key}&#34;)
        focused_dscript.TEMPLATE[key] = self.TEMPLATE[key]
        localvariables = localvariables+scriptdata(**self.TEMPLATE[key].definitions)
        focused_dscript.TEMPLATE[key].definitions = localvariables
        focused_dscript.DEFINITIONS = scriptdata(**self.DEFINITIONS)
        focused_dscript.SECTIONS = self.SECTIONS[:]
        focused_dscript.section = self.section
        focused_dscript.position = self.position
        focused_dscript.role = self.role
        focused_dscript.description = self.description
        focused_dscript.userid = self.userid
        focused_dscript.version = self.version
        focused_dscript.verbose = verbose
        focused_dscript.printflag = printflag

        # Convert the focused dscript object to a script object
        script_obj = focused_dscript.script(printflag=printflag, verbose=verbose, **USER)

        # Combine the script objects into a pipescript object using the pipe operator
        if combined_pipescript is None:
            combined_pipescript = pipescript(script_obj)  # Initialize pipescript
        else:
            combined_pipescript = combined_pipescript | pipescript(script_obj)  # Use pipe operator

    if combined_pipescript is None:
        ValueError(&#39;The conversion to pipescript from {type{self}} falled&#39;)
    return combined_pipescript</code></pre>
</details>
</dd>
<dt id="group.dscript.print_var_info"><code class="name flex">
<span>def <span class="ident">print_var_info</span></span>(<span>self, what='all', output_file=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Print or save a neatly formatted table of variable information based on the analysis from <code>var_info()</code>.</p>
<p>This method retrieves variable information using the <code>var_info()</code> method and presents it in a
Markdown-compatible table or an HTML table. Users can choose to display information for all variables
or a specific subset by providing a list of variable names. Additionally, users can opt to save the
table to a file with options to control file extension, path validity, and overwrite behavior.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>what</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Specifies which variables' information to print.
- If set to 'all' (default), information for all variables is displayed.
- If set to a list of variable names, only those variables are displayed.</dd>
<dt><strong><code>output_file</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The path to the file where the table will be saved.
- If set to <code>None</code> (default), the table is printed to the console.
- If a file path is provided, the table is saved to the specified file.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>Determines whether to overwrite the file if it already exists.
- If <code>False</code> and the file exists, a <code>FileExistsError</code> is raised.
- If <code>True</code>, the existing file is overwritten.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>
<ul>
<li>If <code>what</code> is neither <code>'all'</code> nor a list of strings.</li>
<li>If the file extension is neither <code>.md</code>, <code>.txt</code>, nor <code>.html</code>.</li>
</ul>
</dd>
<dt><code>FileNotFoundError</code></dt>
<dd>If the specified directory in <code>output_file</code> does not exist.</dd>
<dt><code>PermissionError</code></dt>
<dd>If the specified path is not writable.</dd>
<dt><code>FileExistsError</code></dt>
<dd>If the file exists and <code>overwrite</code> is set to <code>False</code>.</dd>
<dt><code>IOError</code></dt>
<dd>If an error occurs during file writing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_var_info(self, what=&#39;all&#39;, output_file=None, overwrite=False):
    &#34;&#34;&#34;
    Print or save a neatly formatted table of variable information based on the analysis from `var_info()`.

    This method retrieves variable information using the `var_info()` method and presents it in a
    Markdown-compatible table or an HTML table. Users can choose to display information for all variables
    or a specific subset by providing a list of variable names. Additionally, users can opt to save the
    table to a file with options to control file extension, path validity, and overwrite behavior.

    Parameters
    ----------
    what : str or list of str, optional
        Specifies which variables&#39; information to print.
        - If set to &#39;all&#39; (default), information for all variables is displayed.
        - If set to a list of variable names, only those variables are displayed.

    output_file : str, optional
        The path to the file where the table will be saved.
        - If set to `None` (default), the table is printed to the console.
        - If a file path is provided, the table is saved to the specified file.

    overwrite : bool, default=False
        Determines whether to overwrite the file if it already exists.
        - If `False` and the file exists, a `FileExistsError` is raised.
        - If `True`, the existing file is overwritten.

    Raises
    ------
    ValueError
        - If `what` is neither `&#39;all&#39;` nor a list of strings.
        - If the file extension is neither `.md`, `.txt`, nor `.html`.
    FileNotFoundError
        If the specified directory in `output_file` does not exist.
    PermissionError
        If the specified path is not writable.
    FileExistsError
        If the file exists and `overwrite` is set to `False`.
    IOError
        If an error occurs during file writing.
    &#34;&#34;&#34;
    # Retrieve the variable information dictionary
    varnfo = self.var_info()

    # Determine which variables to display
    if what == &#39;all&#39;:
        variables_to_print = list(varnfo.keys())
    elif isinstance(what, list):
        # Ensure all items in the list are strings
        if not all(isinstance(var, str) for var in what):
            raise ValueError(&#34;All items in the &#39;what&#39; list must be strings representing variable names.&#34;)
        variables_to_print = what
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be either &#39;all&#39; or a list of variable names.&#34;)

    # Filter out variables that are not present in varnfo
    missing_vars = [var for var in variables_to_print if var not in varnfo]
    if missing_vars:
        print(f&#34;Warning: The following variables were not found and will be skipped: {missing_vars}&#34;)
        # Remove missing variables from the list
        variables_to_print = [var for var in variables_to_print if var in varnfo]

    if not variables_to_print:
        print(&#34;No variables to display.&#34;)
        return

    # Define the headers based on varnfo fields
    headers = [
        &#34;Variable Name&#34;,
        &#34;Value&#34;,
        &#34;Updated Value&#34;,
        &#34;Is Default&#34;,
        &#34;First Def&#34;,
        &#34;First Use&#34;,
        &#34;First Val&#34;,
        &#34;Override Index&#34;,
        &#34;Is Autodef&#34;,
        &#34;Is Empty&#34;,
        &#34;Is Global&#34;,
        &#34;Value Counter&#34;,
        &#34;First Use IsGlobal&#34;,
        &#34;Set In&#34;,
        &#34;Set As&#34;,
        &#34;Values&#34;,
        &#34;Used In&#34;
    ]

    # Initialize a list to hold all rows
    table_rows = []

    # Populate the table rows with variable information
    for var in variables_to_print:
        info = varnfo[var]
        row = [
            var,
            self._format_field(info.get(&#34;value&#34;)),
            self._format_field(info.get(&#34;updatedvalue&#34;)),
            self._format_field(info.get(&#34;is_default&#34;)),
            self._format_field(info.get(&#34;first_def&#34;)),
            self._format_field(info.get(&#34;first_use&#34;)),
            self._format_field(info.get(&#34;first_val&#34;)),
            self._format_field(info.get(&#34;override_index&#34;)),
            self._format_field(info.get(&#34;is_autodef&#34;)),
            self._format_field(info.get(&#34;is_empty&#34;)),
            self._format_field(info.get(&#34;is_global&#34;)),
            self._format_field(info.get(&#34;value_counter&#34;)),
            self._format_field(info.get(&#34;first_use_isglobal&#34;)),
            self._format_list(info.get(&#34;set_in&#34;)),
            self._format_list(info.get(&#34;set_as&#34;)),
            self._format_values(info.get(&#34;values&#34;)),
            self._format_list(info.get(&#34;used_in&#34;))
        ]
        table_rows.append(row)

    # Calculate the maximum width for each column
    column_widths = [len(header) for header in headers]
    for row in table_rows:
        for idx, cell in enumerate(row):
            cell_length = len(str(cell))
            if cell_length &gt; column_widths[idx]:
                column_widths[idx] = cell_length

    # Build the Markdown table
    # Header row
    header_row = &#34;| &#34; + &#34; | &#34;.join(f&#34;{header.ljust(column_widths[idx])}&#34; for idx, header in enumerate(headers)) + &#34; |&#34;
    # Separator row
    separator_row = &#34;|-&#34; + &#34;-|-&#34;.join(&#39;-&#39; * column_widths[idx] for idx in range(len(headers))) + &#34;-|&#34;
    # Data rows
    data_rows = [
        &#34;| &#34; + &#34; | &#34;.join(f&#34;{str(cell).ljust(column_widths[idx])}&#34; for idx, cell in enumerate(row)) + &#34; |&#34;
        for row in table_rows
    ]

    # Combine all parts for Markdown
    markdown_table = &#34;\n&#34;.join([header_row, separator_row] + data_rows)

    # Generate HTML table if needed
    html_table = None
    if output_file:
        _, file_extension = os.path.splitext(output_file)
        file_extension = file_extension.lower()

        if file_extension not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;, &#39;&#39;]:
            raise ValueError(&#34;File extension must be either &#39;.md&#39;, &#39;.txt&#39;, or &#39;.html&#39;.&#34;)

        if file_extension == &#39;&#39;:
            # Default to .md
            output_file += &#39;.md&#39;
            file_extension = &#39;.md&#39;

        # Extract directory from the output_file path
        directory = os.path.dirname(os.path.abspath(output_file))
        if directory and not os.path.exists(directory):
            raise FileNotFoundError(f&#34;The directory &#39;{directory}&#39; does not exist.&#34;)

        if directory and not os.access(directory, os.W_OK):
            raise PermissionError(f&#34;The directory &#39;{directory}&#39; is not writable.&#34;)

        # Check if the file exists
        if os.path.exists(output_file) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{output_file}&#39; already exists and overwrite is set to False.&#34;)

        # Prepare title and timestamp
        timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        title = f&#34;{self.name} - Variable Information&#34;
        subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;

        if file_extension == &#39;.html&#39;:
            # Build HTML table with embedded CSS
            html_table = self._build_html_table(headers, table_rows, column_widths, title, subtitle)
        else:
            # For Markdown and TXT, prepare content with title and timestamp
            content = f&#34;# {title}\n\n&#34;
            content += f&#34;**{subtitle}**\n\n&#34;
            content += markdown_table + &#34;\n&#34;

    # If output_file is not specified, print to console
    if output_file is None:
        # Print title and timestamp
        timestamp = datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        title = f&#34;{self.name} - Variable Information&#34;
        subtitle = f&#34;Generated on {timestamp} by {self.userid}&#34;
        print(f&#34;### {title}\n&#34;)
        print(f&#34;**{subtitle}**\n&#34;)
        # Print the Markdown table
        print(markdown_table)
    else:
        # Save to file based on extension
        try:
            if file_extension in [&#39;.md&#39;, &#39;.txt&#39;]:
                # Prepare content with title and timestamp
                content = f&#34;# {title}\n\n&#34;
                content += f&#34;**{subtitle}**\n\n&#34;
                content += markdown_table + &#34;\n&#34;

                # Write to file
                with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                    f.write(content)
                print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
            elif file_extension == &#39;.html&#39;:
                # Write HTML content
                with open(output_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
                    f.write(html_table)
                print(f&#34;Variable information successfully written to &#39;{output_file}&#39;.&#34;)
        except IOError as e:
            raise IOError(f&#34;An error occurred while writing to the file: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="group.dscript.reorder"><code class="name flex">
<span>def <span class="ident">reorder</span></span>(<span>self, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder the TEMPLATE lines according to a list of indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reorder(self, order):
    &#34;&#34;&#34;Reorder the TEMPLATE lines according to a list of indices.&#34;&#34;&#34;
    # Get the original items as a list of (key, value) pairs
    original_items = list(self.TEMPLATE.items())
    # Create a new dictionary with reordered scripts, preserving original keys
    new_scripts = {original_items[i][0]: original_items[i][1] for i in order}
    # Create a new dscript object with reordered scripts
    reordered_script = dscript()
    reordered_script.TEMPLATE = new_scripts
    return reordered_script</code></pre>
</details>
</dd>
<dt id="group.dscript.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the current script instance to a text file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name of the file to save the script to. If not provided, <code>self.name</code> is used.
The extension ".txt" is automatically appended if not included.</dd>
<dt><strong><code>foldername</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The directory where the file will be saved. If not provided, it defaults to the system's
temporary directory. If the filename does not include a full path, this folder will be used.</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>Whether to overwrite the file if it already exists. If set to False, an exception is raised
if the file exists.</dd>
<dt><strong><code>generatoronly</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>If True, the method returns the generated content string without saving to a file.</dd>
<dt><strong><code>onlyusedvariables</code></strong> :&ensp;<code>bool</code>, default=<code>True</code></dt>
<dd>If True, local definitions are only saved if they are used within the template content.
If False, all local definitions are saved, regardless of whether they are referenced in
the template.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and <code>overwrite</code> is set to False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>The script is saved in a plain text format, and each section (global parameters, definitions,
template, and attributes) is written in a structured format with appropriate comments.</li>
<li>If <code>self.name</code> is used as the filename, it must be a valid string that can serve as a file name.</li>
<li>
<p>The file structure follows the format:
# DSCRIPT SAVE FILE
# generated on YYYY-MM-DD on user@hostname</p>
<h1 id="global-parameters">GLOBAL PARAMETERS</h1>
<p>{ &hellip; }</p>
<h1 id="definitions-number-of-definitions">DEFINITIONS (number of definitions=&hellip;)</h1>
<p>key=value</p>
<h1 id="templates-number-of-items">TEMPLATES (number of items=&hellip;)</h1>
<p>key: template_content</p>
<h1 id="attributes-number-of-items-with-explicit-attributes">ATTRIBUTES (number of items with explicit attributes=&hellip;)</h1>
<p>key:{attr1=value1, attr2=value2, &hellip;}</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=None, foldername=None, overwrite=False, generatoronly=False, onlyusedvariables=True):
    &#34;&#34;&#34;
    Save the current script instance to a text file.

    Parameters
    ----------
    filename : str, optional
        The name of the file to save the script to. If not provided, `self.name` is used.
        The extension &#34;.txt&#34; is automatically appended if not included.

    foldername : str, optional
        The directory where the file will be saved. If not provided, it defaults to the system&#39;s
        temporary directory. If the filename does not include a full path, this folder will be used.

    overwrite : bool, default=True
        Whether to overwrite the file if it already exists. If set to False, an exception is raised
        if the file exists.

    generatoronly : bool, default=False
        If True, the method returns the generated content string without saving to a file.

    onlyusedvariables : bool, default=True
        If True, local definitions are only saved if they are used within the template content.
        If False, all local definitions are saved, regardless of whether they are referenced in
        the template.

    Raises
    ------
    FileExistsError
        If the file already exists and `overwrite` is set to False.

    Notes
    -----
    - The script is saved in a plain text format, and each section (global parameters, definitions,
      template, and attributes) is written in a structured format with appropriate comments.
    - If `self.name` is used as the filename, it must be a valid string that can serve as a file name.
    - The file structure follows the format:
        # DSCRIPT SAVE FILE
        # generated on YYYY-MM-DD on user@hostname

        # GLOBAL PARAMETERS
        { ... }

        # DEFINITIONS (number of definitions=...)
        key=value

        # TEMPLATES (number of items=...)
        key: template_content

        # ATTRIBUTES (number of items with explicit attributes=...)
        key:{attr1=value1, attr2=value2, ...}
    &#34;&#34;&#34;
    # At the beginning of the save method
    start_time = time.time()  # Start the timer

    if not generatoronly:
        # Use self.name if filename is not provided
        if filename is None:
            filename = span(self.name, sep=&#34;\n&#34;)

        # Ensure the filename ends with &#39;.txt&#39;
        if not filename.endswith(&#39;.txt&#39;):
            filename += &#39;.txt&#39;

        # Construct the full path
        if foldername in [None, &#34;&#34;]:  # Handle cases where foldername is None or an empty string
            filepath = os.path.abspath(filename)
        else:
            filepath = os.path.join(foldername, filename)

        # Check if the file already exists, and raise an exception if it does and overwrite is False
        if os.path.exists(filepath) and not overwrite:
            raise FileExistsError(f&#34;The file &#39;{filepath}&#39; already exists.&#34;)

    # Header with current date, username, and host
    header = &#34;# DSCRIPT SAVE FILE\n&#34;
    header += &#34;\n&#34;*2
    if generatoronly:
        header += dscript.header(verbose=True,filepath=&#39;dynamic code generation (no file)&#39;,
                                 name = self.name, version=self.version, license=self.license, email=self.email)
    else:
        header += dscript.header(verbose=True,filepath=filepath,
                                 name = self.name, version=self.version, license=self.license, email=self.email)
    header += &#34;\n&#34;*2

    # Global parameters in strict Python syntax
    global_params = &#34;# GLOBAL PARAMETERS (8 parameters)\n&#34;
    global_params += &#34;{\n&#34;
    global_params += f&#34;    SECTIONS = {self.SECTIONS},\n&#34;
    global_params += f&#34;    section = {self.section},\n&#34;
    global_params += f&#34;    position = {self.position},\n&#34;
    global_params += f&#34;    role = {self.role!r},\n&#34;
    global_params += f&#34;    description = {self.description!r},\n&#34;
    global_params += f&#34;    userid = {self.userid!r},\n&#34;
    global_params += f&#34;    version = {self.version},\n&#34;
    global_params += f&#34;    verbose = {self.verbose}\n&#34;
    global_params += &#34;}\n&#34;

    # Initialize definitions with self.DEFINITIONS
    #allvars = self.DEFINITIONS

    # Temporary dictionary to track global variable information
    vinfo = self.var_info()

    # Filter global definitions based on usage, overrides, and first_def
    #  and info[&#34;is_default&#34;]
    filtered_globals = {
        var: info for var, info in vinfo.items()
        if ((info[&#34;is_global&#34;]and not info[&#34;is_empty&#34;]) and (info[&#34;first_use_isglobal&#34;]) and (info[&#34;override_index&#34;] is None))
        }

    # Generate the definitions output based on filtered globals
    definitions = f&#34;\n# GLOBAL DEFINITIONS (number of definitions={len(filtered_globals)})\n&#34;
    for var, info in filtered_globals.items():
        if info[&#34;is_default&#34;] and (info[&#34;first_def&#34;]&gt;info[&#34;first_use&#34;] if info[&#34;first_def&#34;] else True):
            definitions += f&#34;{var} = ${{{var}}}  # value assumed to be defined outside this DSCRIPT file\n&#34;
        else:
            value = info[&#34;first_val&#34;]   #info[&#34;value&#34;]
            if info[&#34;is_empty&#34;]:        #value in [&#34;&#34;, None]
                definitions += f&#39;{var} = &#34;&#34;\n&#39;
            elif isinstance(value, str):
                safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                definitions += f&#34;{var} = {safe_value}\n&#34;
            else:
                definitions += f&#34;{var} = {value}\n&#34;

    # Template (number of lines/items)
    printsinglecontent = False
    template = f&#34;\n# TEMPLATES (number of items={len(self.TEMPLATE)})\n&#34;
    #for key, script_template in self.TEMPLATE.items():
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        # Get local template definitions and detected variables
        template_vars = script_template.definitions
        used_variables = script_template.detect_variables()
        islocal = False
        # Temporary dictionary to accumulate variables to add to allvars
        valid_local_vars = lambdaScriptdata()
        # Write template-specific definitions only if they meet the updated conditions
        for var in template_vars.keys():
            # Conditions for adding a variable to the local template and to `allvars`
            if (var in used_variables or not onlyusedvariables) \
               and (template_index in vinfo[var][&#34;set_in&#34;]) \
               and (var not in filtered_globals):
            # if (var in used_variables or not onlyusedvariables) and (
            #    script_template.is_variable_set_value_only(var) and
            #    (var not in allvars or getattr(template_vars, var) != getattr(allvars, var))
            #):
                # Start local definitions section if this is the first local variable for the template
                if not islocal:
                    template += f&#34;\n# LOCAL DEFINITIONS for key &#39;{key}&#39;\n&#34;
                    islocal = True
                # Retrieve and process the variable value
                # value = getattr(template_vars, var)
                value = next((ref for idx, ref in vinfo[var][&#34;values&#34;] if idx == template_index), None)
                if value in [&#34;&#34;, None]:
                    template += f&#39;{var} = &#34;&#34;\n&#39;  # Set empty or None values as &#34;&#34;
                elif isinstance(value, str):
                    safe_value = value.replace(&#39;\\&#39;, &#39;\\\\&#39;).replace(&#39;\n&#39;, &#39;\\n&#39;)
                    template += f&#34;{var} = {safe_value}\n&#34;
                else:
                    template += f&#34;{var} = {value}\n&#34;
                # Add the variable to valid_local_vars for selective update of allvars
                valid_local_vars.setattr(var, value)
        # Update allvars only with filtered, valid local variables
        # allvars += valid_local_vars

        # Write the template content
        if isinstance(script_template.content, list):
            if len(script_template.content) == 1:
                # Single-line template saved as a single line
                content_str = script_template.content[0].strip()
                template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
                template += f&#34;{key}: {content_str}\n&#34;
                printsinglecontent = True
            else:
                content_str = &#39;\n    &#39;.join(script_template.content)
                template += f&#34;\n{key}: [\n    {content_str}\n ]\n&#34;
                printsinglecontent = False
        else:
            template += &#34;&#34; if printsinglecontent else &#34;\n&#34;
            template += f&#34;{key}: {script_template.content}\n&#34;
            printsinglecontent = True

    # Attributes (number of lines/items with explicit attributes)
    attributes = f&#34;# ATTRIBUTES (number of items with explicit attributes={len(self.TEMPLATE)})\n&#34;
    for key, script_template in self.TEMPLATE.items():
        attr_str = &#34;, &#34;.join(f&#34;{attr_name}={repr(attr_value)}&#34;
                             for attr_name, attr_value in script_template.attributes.items())
        attributes += f&#34;{key}:{{{attr_str}}}\n&#34;

    # Combine all sections into one content
    content = header + &#34;\n&#34; + global_params + &#34;\n&#34; + definitions + &#34;\n&#34; + template + &#34;\n&#34; + attributes + &#34;\n&#34;


    # Append footer information to the content
    non_empty_lines = sum(1 for line in content.splitlines() if line.strip())  # Count non-empty lines
    execution_time = time.time() - start_time  # Calculate the execution time in seconds
    # Prepare the footer content
    footer_lines = [
        [&#34;Non-empty lines&#34;, str(non_empty_lines)],
        [&#34;Execution time (seconds)&#34;, f&#34;{execution_time:.4f}&#34;],
    ]
    # Format footer into tabular style
    footer_content = [
        f&#34;{row[0]:&lt;25} {row[1]:&lt;15}&#34; for row in footer_lines
    ]
    # Use frame_header to format footer
    footer = frame_header(
        lines=[&#34;DSCRIPT SAVE FILE generator&#34;] + footer_content,
        style=1
    )
    # Append footer to the content
    content += f&#34;\n{footer}&#34;

    if generatoronly:
        return content
    else:
        # Write the content to the file
        with open(filepath, &#39;w&#39;) as f:
            f.write(content)
        print(f&#34;\nScript saved to {filepath}&#34;)
        return filepath</code></pre>
</details>
</dd>
<dt id="group.dscript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, printflag=None, verbose=None, verbosity=None, **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the corresponding script</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,printflag=None, verbose=None, verbosity=None, **USER):
    &#34;&#34;&#34;
    returns the corresponding script
    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    return lamdaScript(self,persistentfile=True, persistentfolder=None,
                       printflag=printflag, verbose=verbose,
                       **USER)</code></pre>
</details>
</dd>
<dt id="group.dscript.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, primary_key, value, foreign_key, include_global=True, multiple='all', protection=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Search for foreign/definition key values associated with given primary key/definition value(s).</p>
<p>This method searches through the global definitions first and then traverses local steps in sequential order
to find matches for the specified primary key and retrieves the corresponding foreign key values.
It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.</p>
<h2 id="parameters">Parameters</h2>
<p>primary_key (str):
The primary key to search for in the definitions.
value (str, int, float, or list of these types):
The value(s) associated with the primary key.
foreign_key (str):
The foreign key whose value is to be retrieved.
include_global (bool, optional):
If True, include global definitions in the search.
Defaults to True.
multiple (str, optional):
Strategy for handling multiple matches. Options are:
- 'first': Return the first match found.
- 'last': Return the last match found.
- 'all': Return all matches in a list.
Defaults to 'all'.
protection (bool, optional):
If False (default), removes the '$' prefix from the keys in the returned dictionary.
If True, retains the '$' prefix.
Defaults to False.
verbose (bool, optional):
If True, prints warnings about missing foreign keys and available alternative keys.
Defaults to False.</p>
<h2 id="returns">Returns</h2>
<p>dict or scalar or None:
- If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
- If a single value is provided:
- Returns a single foreign key value if 'multiple' is 'first' or 'last'.
- Returns a list of all matching foreign key values if 'multiple' is 'all'.
- Returns None if no matches are found.</p>
<h2 id="raises">Raises</h2>
<p>TypeError:
If the provided value is not of type str, int, or float, or if value list contains invalid types.
ValueError:
If an invalid option is provided for 'multiple'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, primary_key, value, foreign_key, include_global=True, multiple=&#39;all&#39;, protection=False, verbose=False):
    &#34;&#34;&#34;
    Search for foreign/definition key values associated with given primary key/definition value(s).

    This method searches through the global definitions first and then traverses local steps in sequential order
    to find matches for the specified primary key and retrieves the corresponding foreign key values.
    It also identifies available foreign keys in steps where the primary key exists but the desired foreign key is missing.

    Parameters:
        primary_key (str):
            The primary key to search for in the definitions.
        value (str, int, float, or list of these types):
            The value(s) associated with the primary key.
        foreign_key (str):
            The foreign key whose value is to be retrieved.
        include_global (bool, optional):
            If True, include global definitions in the search.
            Defaults to True.
        multiple (str, optional):
            Strategy for handling multiple matches. Options are:
            - &#39;first&#39;: Return the first match found.
            - &#39;last&#39;: Return the last match found.
            - &#39;all&#39;: Return all matches in a list.
            Defaults to &#39;all&#39;.
        protection (bool, optional):
            If False (default), removes the &#39;$&#39; prefix from the keys in the returned dictionary.
            If True, retains the &#39;$&#39; prefix.
            Defaults to False.
        verbose (bool, optional):
            If True, prints warnings about missing foreign keys and available alternative keys.
            Defaults to False.

    Returns:
        dict or scalar or None:
            - If multiple values are provided, returns a dictionary mapping each value to its foreign key value(s).
            - If a single value is provided:
                - Returns a single foreign key value if &#39;multiple&#39; is &#39;first&#39; or &#39;last&#39;.
                - Returns a list of all matching foreign key values if &#39;multiple&#39; is &#39;all&#39;.
            - Returns None if no matches are found.

    Raises:
        TypeError:
            If the provided value is not of type str, int, or float, or if value list contains invalid types.
        ValueError:
            If an invalid option is provided for &#39;multiple&#39;.
    &#34;&#34;&#34;
    # Validate &#39;multiple&#39; parameter
    if multiple not in {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}:
        raise ValueError(&#34;Parameter &#39;multiple&#39; must be one of &#39;first&#39;, &#39;last&#39;, or &#39;all&#39;.&#34;)

    # Normalize &#39;value&#39; to a list for uniform processing
    if isinstance(value, (str, int, float)):
        values = [value]
        single_value = True
    elif isinstance(value, list):
        if not all(isinstance(v, (str, int, float)) for v in value):
            raise TypeError(&#34;All elements in &#39;value&#39; list must be of type str, int, or float.&#34;)
        values = value
        single_value = False
    else:
        raise TypeError(f&#34;&#39;value&#39; must be of type str, int, float, or list of these types, got {type(value).__name__}&#34;)

    # Initialize the result containers
    matched_foreign_keys = {}  # key: value, value: single or list of foreign_key values
    available_foreign_keys_set = set()  # set of foreign keys available where primary exists but desired foreign_key missing

    # Keys to exclude when listing available foreign keys
    excluded_keys = {&#39;_evaluation&#39;, &#39;_excludedattr&#39;, &#39;_protection&#39;, &#39;_returnerror&#39;}

    # Function to add a match to the results based on the &#39;multiple&#39; strategy
    def add_match(val, rvalue):
        if multiple == &#39;all&#39;:
            if val in matched_foreign_keys:
                if isinstance(matched_foreign_keys[val], list):
                    matched_foreign_keys[val].append(rvalue)
                else:
                    matched_foreign_keys[val] = [matched_foreign_keys[val], rvalue]
            else:
                matched_foreign_keys[val] = [rvalue]
        elif multiple == &#39;first&#39;:
            if val not in matched_foreign_keys:
                matched_foreign_keys[val] = rvalue
        elif multiple == &#39;last&#39;:
            matched_foreign_keys[val] = rvalue

    # Start with global definitions if included
    if include_global:
        global_definitions = self.DEFINITIONS
        if hasattr(global_definitions, primary_key):
            primary_value = getattr(global_definitions, primary_key)

            # Handle multiple primary key values within the global definitions
            if isinstance(primary_value, (list, tuple, set)):
                primary_values = primary_value
            else:
                primary_values = [primary_value]

            for pv in primary_values:
                for val in values:
                    if pv == val:
                        # Check if the foreign key exists in global definitions
                        if hasattr(global_definitions, foreign_key):
                            rvalue = getattr(global_definitions, foreign_key)
                            add_match(val, rvalue)
                        else:
                            # Collect available foreign keys in global definitions, excluding specified keys
                            available_keys = [
                                k for k in global_definitions.__dict__
                                if k != primary_key and k not in excluded_keys
                            ]
                            available_foreign_keys_set.update(available_keys)

    # Then, traverse through local steps in sequential order
    for istep in range(len(self)):
        step_definitions = self[istep].definitions

        # Check if the primary key exists in the local definitions
        if hasattr(step_definitions, primary_key):
            primary_value = getattr(step_definitions, primary_key)

            # Handle multiple primary key values within the definition
            if isinstance(primary_value, (list, tuple, set)):
                primary_values = primary_value
            else:
                primary_values = [primary_value]

            for pv in primary_values:
                for val in values:
                    if pv == val:
                        # Check if the foreign key exists
                        if hasattr(step_definitions, foreign_key):
                            rvalue = getattr(step_definitions, foreign_key)
                            add_match(val, rvalue)
                        else:
                            # Collect available foreign keys in this step, excluding specified keys
                            available_keys = [
                                k for k in step_definitions.__dict__
                                if k != primary_key and k not in excluded_keys
                            ]
                            available_foreign_keys_set.update(available_keys)

    # Process the matched_foreign_keys based on &#39;multiple&#39; strategy
    if single_value:
        if values[0] in matched_foreign_keys:
            if multiple == &#39;all&#39;:
                # If only one match, return scalar; else, list
                matches = matched_foreign_keys[values[0]]
                if len(matches) == 1:
                    matches = matches[0]
            else:
                matches = matched_foreign_keys[values[0]]
        else:
            matches = None
    else:
        matches = {}
        for val in values:
            if val in matched_foreign_keys:
                if multiple == &#39;all&#39;:
                    if len(matched_foreign_keys[val]) == 1:
                        matches[val] = matched_foreign_keys[val][0]
                    else:
                        matches[val] = matched_foreign_keys[val]
                else:
                    matches[val] = matched_foreign_keys[val]
            else:
                matches[val] = None  # Or handle differently if needed

    # If there are available foreign keys, report them as an error message
    if available_foreign_keys_set and verbose:
        available_keys_sorted = sorted(list(available_foreign_keys_set))
        print(f&#34;Warning: In some steps, the foreign key &#39;{foreign_key}&#39; is missing where the primary key &#39;{primary_key}&#39; exists.&#34;)
        print(f&#34;Available foreign keys in those steps: {available_keys_sorted}&#34;)

    # If no matches found, print a message
    if (single_value and matches is None) or (not single_value and all(v is None for v in matches.values())):
        if verbose:
            print(f&#34;No matches found for primary key &#39;{primary_key}&#39; with value(s) &#39;{value}&#39;.&#34;)
        return None

    # Handle protection flag: remove &#39;$&#39; prefix from keys if protection=False
    if not single_value and isinstance(matches, dict):
        processed_matches = {}
        for k, v in matches.items():
            if not protection and isinstance(k, str):
                # Remove any leading &#39;$&#39; and surrounding spaces
                new_key = k.lstrip(&#39;$&#39;).strip()
            else:
                new_key = k
            processed_matches[new_key] = v
        return processed_matches
    else:
        # For single value searches, return matches as-is
        return matches</code></pre>
</details>
</dd>
<dt id="group.dscript.set_all_variables"><code class="name flex">
<span>def <span class="ident">set_all_variables</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that all variables in the templates are added to the global definitions
with default values if they are not already defined.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_all_variables(self):
    &#34;&#34;&#34;
    Ensures that all variables in the templates are added to the global definitions
    with default values if they are not already defined.
    &#34;&#34;&#34;
    for key, script_template in self.TEMPLATE.items():
        # Check and update the global definitions with template-specific variables
        for var in script_template.detect_variables():
            if var not in self.DEFINITIONS:
                # Add undefined variables with their default value
                self.DEFINITIONS.setattr(var, f&#34;${{{var}}}&#34;)  # Set default as ${varname}</code></pre>
</details>
</dd>
<dt id="group.dscript.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ScriptTemplate objects in TEMPLATE.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    &#34;&#34;&#34;Return the ScriptTemplate objects in TEMPLATE.&#34;&#34;&#34;
    return self.TEMPLATE.values()</code></pre>
</details>
</dd>
<dt id="group.dscript.var_info"><code class="name flex">
<span>def <span class="ident">var_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyze and gather comprehensive information about variables used in the script.</p>
<p>This method performs a sophisticated analysis of both global and local variables within
the script. It identifies variable usage, overrides, defaults, and counts the number of
different values each variable holds across various templates.</p>
<p>The analysis considers two scopes:
- <strong>Global:</strong> Variables defined in the global definitions (<code>self.DEFINITIONS</code>).
- <strong>Local:</strong> Variables defined within each template's definitions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>A dictionary named <code>varnfo</code> where each key is a variable name and the value is
another dictionary containing detailed information about that variable. The structure
of <code>varnfo</code> is as follows:</p>
<p>{
"variable_name": {
"value": <initial_value_from_global>,
"updatedvalue": <current_value_after_overrides>,
"is_default": <bool>,
"first_def": <template_index_or_None>,
"first_use": <template_index>,
"first_val": <value_at_first_use>,
"override_index": <template_index_or_None>,
"is_global": <bool>,
"value_counter": <int>
etc.
},
&hellip;
}</p>
<p><strong>Field Descriptions:</strong>
- <code>value</code>: Initial value of the variable from global definitions (if applicable).
- <code>updatedvalue</code>: Current value after any overrides in local templates.
- <code>is_default</code>: Indicates if the variable is set to a default value.
- <code>first_def</code>: The index of the first template where the variable is defined locally.
- <code>first_use</code>: The index of the first template where the variable is used.
- <code>first_val</code>: The value of the variable at its first use.
- <code>override_index</code>: The index of the template where the variable was overridden (if any).
- <code>is_autodef</code>: Flag, True if ${variable} is defined automatically as ${variable}
- <code>is_empty</code>: Flag,
True if the variable is empty (None,"",[], etc.)
- <code>is_global</code>: Indicates if the variable originates from global definitions.
- <code>value_counter</code>: Counts the number of different values the variable has across templates.
- <code>first_use_isglobal</code> : Flag, True if the global value is used at first use
- <code>set_in</code>: Lists all template indices values where the variable is assigned/changed,
- <code>set_as</code>: Lists assigned values as reported in <code>set_in</code>,
- <code>values</code>: Lists variable changes (template index, refvalue),
- <code>used_in</code>: Lists template indices where the variable is used</p>
</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If <code>self.DEFINITIONS</code> does not have the specified key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def var_info(self):
    &#34;&#34;&#34;
    Analyze and gather comprehensive information about variables used in the script.

    This method performs a sophisticated analysis of both global and local variables within
    the script. It identifies variable usage, overrides, defaults, and counts the number of
    different values each variable holds across various templates.

    The analysis considers two scopes:
    - **Global:** Variables defined in the global definitions (`self.DEFINITIONS`).
    - **Local:** Variables defined within each template&#39;s definitions.

    Returns:
        dict: A dictionary named `varnfo` where each key is a variable name and the value is
              another dictionary containing detailed information about that variable. The structure
              of `varnfo` is as follows:

              {
                  &#34;variable_name&#34;: {
                      &#34;value&#34;: &lt;initial_value_from_global&gt;,
                      &#34;updatedvalue&#34;: &lt;current_value_after_overrides&gt;,
                      &#34;is_default&#34;: &lt;bool&gt;,
                      &#34;first_def&#34;: &lt;template_index_or_None&gt;,
                      &#34;first_use&#34;: &lt;template_index&gt;,
                      &#34;first_val&#34;: &lt;value_at_first_use&gt;,
                      &#34;override_index&#34;: &lt;template_index_or_None&gt;,
                      &#34;is_global&#34;: &lt;bool&gt;,
                      &#34;value_counter&#34;: &lt;int&gt;
                      etc.
                  },
                  ...
              }

              **Field Descriptions:**
              - `value`: Initial value of the variable from global definitions (if applicable).
              - `updatedvalue`: Current value after any overrides in local templates.
              - `is_default`: Indicates if the variable is set to a default value.
              - `first_def`: The index of the first template where the variable is defined locally.
              - `first_use`: The index of the first template where the variable is used.
              - `first_val`: The value of the variable at its first use.
              - `override_index`: The index of the template where the variable was overridden (if any).
              - `is_autodef`: Flag, True if ${variable} is defined automatically as ${variable}
              - `is_empty`: Flag,  True if the variable is empty (None,&#34;&#34;,[], etc.)
              - `is_global`: Indicates if the variable originates from global definitions.
              - `value_counter`: Counts the number of different values the variable has across templates.
              - `first_use_isglobal` : Flag, True if the global value is used at first use
              - `set_in`: Lists all template indices values where the variable is assigned/changed,
              - `set_as`: Lists assigned values as reported in `set_in`,
              - `values`: Lists variable changes (template index, refvalue),
              - `used_in`: Lists template indices where the variable is used

    Raises:
        AttributeError: If `self.DEFINITIONS` does not have the specified key.
    &#34;&#34;&#34;

    start_time = time.time()  # Start the timer

    # Initialize definitions with self.DEFINITIONS
    allvars = self.DEFINITIONS

    # Temporary dictionary to track global variable information
    varnfo = {}

    # Loop over each template item to detect and record variable usage and overrides
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        # Detect variables used in this template
        used_variables = script_template.detect_variables()

        # Check each variable used in this template
        for var in used_variables:
            # Get global and local values for the variable
            global_value = getattr(allvars, var, None)
            local_value = getattr(script_template.definitions, var, None)
            is_autodef = global_value == f&#34;${{{var}}}&#34;
            is_global = var in allvars  # Check if the variable originates in global space
            is_empty = global_value in (None,&#34;&#34;,[],[&#34;&#34;])
            is_default = is_global and (is_empty or is_autodef)

            # If the variable is not yet tracked, initialize its info
            if var not in varnfo:
                initialcounter = 1 if local_value is None or local_value==global_value else 2
                first_use_isglobal = initialcounter==1
                refvalue = global_value if first_use_isglobal else local_value
                override_index = template_index if ((local_value is not None) and not first_use_isglobal and not is_default) else None
                varnfo[var] = {
                    &#34;value&#34;: refvalue,        # Initial value from allvars if exists
                    &#34;updatedvalue&#34;: refvalue, # Initial value from allvars if exists
                    &#34;is_default&#34;: is_default,     # Check if its set to a default value
                    &#34;first_def&#34;: None,            # First definition (to be updated later)
                    &#34;first_use&#34;: template_index,  # First time the variable is used
                    &#34;first_val&#34;: refvalue,        # First value
                    &#34;override_index&#34;: override_index,  # Set override if defined locally
                    &#34;is_autodef&#34;: is_autodef,     # automatic definition ${variable}
                    &#34;is_empty&#34;: is_empty,         # Track if the variable is empty (None,&#34;&#34;,[], etc.)
                    &#34;is_global&#34;: is_global,       # Track if the variable originates as global
                    &#34;value_counter&#34;: initialcounter, # Count the number of different values
                    &#34;first_use_isglobal&#34;: first_use_isglobal, # True if the global value is used at first use
                    &#34;set_in&#34;: [template_index],
                    &#34;set_as&#34;: [refvalue],
                    &#34;values&#34;:[(template_index, refvalue)],
                    &#34;used_in&#34;: [template_index]
                }
            else:
                # Update `override_index` if the variable is defined locally and its value changes
                varnfo[var][&#34;used_in&#34;].append(template_index)
                if local_value is not None:
                    # Check if the local value differs from the tracked value in varnfo
                    current_value = varnfo[var][&#34;updatedvalue&#34;] # varnfo[var][&#34;value&#34;]
                    if current_value != local_value:
                        varnfo[var][&#34;override_index&#34;] = template_index
                        varnfo[var][&#34;updatedvalue&#34;] = local_value  # Update the tracked value
                        varnfo[var][&#34;value_counter&#34;] += 1
                        varnfo[var][&#34;set_in&#34;].append(template_index)
                        varnfo[var][&#34;set_as&#34;].append(local_value)
                        varnfo[var][&#34;values&#34;].append((template_index, local_value))

    # Second loop: Update `first_def` for all variables
    for template_index, (key, script_template) in enumerate(self.TEMPLATE.items()):
        local_definitions = script_template.definitions.keys()
        for var in local_definitions:
            if var in varnfo and varnfo[var][&#34;first_def&#34;] is None:
                varnfo[var][&#34;first_def&#34;] = template_index
                varnfo[var][&#34;first_val&#34;] = getattr(script_template.definitions, var)

    execution_time = time.time() - start_time  # Calculate the execution time in seconds

    if self.verbose:
        print(f&#34;Variable analysis completed in {execution_time:.4f} seconds.&#34;)

    return varnfo</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="group.group"><code class="flex name class">
<span>class <span class="ident">group</span></span>
<span>(</span><span>name=None, groups=None, group_names=None, collection=None, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for managing LAMMPS group operations and generating LAMMPS scripts.</p>
<h3 id="overview">Overview</h3>
<p>The <code><a title="group.group" href="#group.group">group</a></code> class provides an object-oriented interface to define and manage
groups of atoms in LAMMPS simulations. Groups in LAMMPS are collections of
atoms that can be manipulated together, allowing users to apply fixes,
compute properties, or perform operations on specific subsets of atoms.</p>
<p>This class allows you to create, combine, and manipulate groups using
algebraic operations (union, intersection, subtraction), and to generate
the corresponding LAMMPS commands. It also provides methods to output the
group commands as scripts, which can be integrated into LAMMPS input files.</p>
<h3 id="key-features">Key Features</h3>
<ul>
<li><strong>Create and Manage Groups</strong>: Define new groups based on atom types,
regions, IDs, or variables.</li>
<li><strong>Flexible Group Creation</strong>: Create multiple groups at once and define groups
using concise criteria through the <code>add_group_criteria</code> method.</li>
<li><strong>Algebraic Operations</strong>: Combine groups using union (<code>+</code>), intersection (<code>*</code>),
and subtraction (<code>-</code>) operations.</li>
<li><strong>Subindexing with Callable Syntax</strong>: Retrieve multiple group operations
by calling the <code><a title="group.group" href="#group.group">group</a></code> instance with names or indices.</li>
<li><strong>Script Generation</strong>: Generate LAMMPS script lines for group definitions,
which can be output as scripts or pipelines.</li>
<li><strong>Dynamic Evaluation</strong>: Evaluate complex group expressions and store the
resulting operations.</li>
<li><strong>Integration with Scripting Tools</strong>: Convert group operations into
<code><a title="group.dscript" href="#group.dscript">dscript</a></code> or <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> objects for advanced script management.</li>
</ul>
<h3 id="lammps-context">LAMMPS Context</h3>
<p>In LAMMPS (Large-scale Atomic/Molecular Massively Parallel Simulator),
groups are fundamental for specifying subsets of atoms for applying
operations like forces, fixes, and computes. The <code><a title="group.group" href="#group.group">group</a></code> command in LAMMPS
allows users to define groups based on various criteria such as atom IDs,
types, regions, and variables.</p>
<p>This <code><a title="group.group" href="#group.group">group</a></code> class abstracts the complexity of managing group definitions
and operations, providing a high-level interface to define and manipulate
groups programmatically.</p>
<h3 id="usage-examples">Usage Examples</h3>
<p><strong>Creating Multiple Groups at Once</strong></p>
<pre><code class="language-python"># Create groups 'o1', 'o2', 'o3', 'o4' upon instantiation
G = group(group_names=['o1', 'o2', 'o3', 'o4'])
</code></pre>
<p><strong>Defining Groups Based on Criteria</strong></p>
<pre><code class="language-python">G = group()
G.add_group_criteria('lower', type=[1])
G.add_group_criteria('central', region='central_cyl')
G.add_group_criteria('new_group', create=True)
G.add_group_criteria('upper', clear=True)
G.add_group_criteria('subtract_group', subtract=['group1', 'group2'])
</code></pre>
<p><strong>Defining a Group Based on a Variable</strong></p>
<pre><code class="language-python">G = group()
G.variable('myVar', 'x &gt; 5')          # Assign a variable
G.byvariable('myGroup', 'myVar')      # Define group based on the variable
</code></pre>
<p><strong>Using <code>add_group_criteria</code> with Variable</strong></p>
<pre><code class="language-python">G.add_group_criteria('myGroup', variable={'name': 'myVar', 'expression': 'x &gt; 5'})
</code></pre>
<p><strong>Defining Groups Using a Dictionary</strong></p>
<pre><code class="language-python">group_definitions = {
    'group1': {'type': [1, 2]},
    'group2': {'region': 'my_region'},
    'group3': {'variable': {'name': 'var1', 'expression': 'x &gt; 5'}},
    'group4': {'union': ['group1', 'group2']},
}
G.add_group_criteria(group_definitions)
</code></pre>
<p><strong>Creating a Group from a Collection of <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> Instances</strong></p>
<pre><code class="language-python"># Import the classes
# from groupobject import groupobject
# from group import group

# Create groupobject instances
o1 = groupobject(beadtype=1, group=[&quot;all&quot;, &quot;A&quot;], mass=1.0)
o2 = groupobject(beadtype=2, group=[&quot;all&quot;, &quot;B&quot;, &quot;C&quot;])
o3 = groupobject(beadtype=3, group=&quot;C&quot;, mass=2.5)

# Create a group instance with the collection
G = group(name=&quot;mycollection&quot;, collection=[o1, o2, o3])
# or
G = group(name=None, collection=[o1, o2, o3])  # Name will be generated as &quot;1+2+3&quot;

# Generate the LAMMPS script
script_content = G.code()
print(script_content)
</code></pre>
<p><strong>Expected Output:</strong></p>
<pre><code>group all type 1 2 3
group A type 1
group B type 2
group C type 2 3
</code></pre>
<p><strong>Accessing Groups and Performing Operations</strong></p>
<pre><code class="language-python"># Access groups via attribute-style or item-style access
op1 = G.group1
op2 = G['group2']

# Combine groups using algebraic operations
complex_op = op1 + op2 - G.group3

# Evaluate the operation and store the result
G.evaluate('combined_group', complex_op)
</code></pre>
<p><strong>Subindexing with Callable Syntax</strong></p>
<pre><code class="language-python"># Retrieve multiple operations by names or indices
subG = G('group1', 2, 'group3')  # Retrieves 'group1', third operation, and 'group3'

# Display the names of operations in subG
operation_names = [op.name for op in subG._operations]
print(operation_names)  # Output: ['group1', 'group3', 'group3']

# Generate the LAMMPS script for the subgroup
script_content = subG.code()
print(script_content)
</code></pre>
<p><strong>Generating LAMMPS Script</strong></p>
<pre><code class="language-python">script_content = G.code()
print(script_content)
</code></pre>
<h3 id="class-methods">Class Methods</h3>
<h4 id="initialization-and-setup">Initialization and Setup</h4>
<ul>
<li><code>__init__(self, name=None, groups=None, group_names=None, printflag=False, verbose=True)</code>: Initializes a new <code><a title="group.group" href="#group.group">group</a></code> instance.</li>
<li><code>name</code> (str): Optional name for the group instance.</li>
<li><code>groups</code> (dict): Dictionary of group definitions to create upon initialization.</li>
<li><code>group_names</code> (list): List of group names to create empty groups upon initialization.</li>
<li>
<p><code>collection</code> (list or tuple of groupobject, optional): Collection of groupobject instances.</p>
</li>
<li>
<p><code>printflag</code> (bool): If True, enables printing of script generation.</p>
</li>
<li>
<p><code>verbose</code> (bool): If True, enables verbose output.</p>
</li>
<li>
<p><code>create_groups(self, *group_names)</code>: Creates multiple new groups with the given names.</p>
</li>
<li>
<p><code>add_group_criteria(self, *args, **kwargs)</code>: Adds group(s) based on criteria.</p>
</li>
<li>Supports two usages:<ul>
<li><code>add_group_criteria(group_name, **criteria)</code>: Adds a single group.</li>
<li><code>add_group_criteria(group_definitions)</code>: Adds multiple groups from a dictionary.</li>
</ul>
</li>
</ul>
<h4 id="group-creation-methods">Group Creation Methods</h4>
<ul>
<li><code>create(self, group_name)</code>: Creates a new empty group with the given name.</li>
<li><code>bytype(self, group_name, type_values)</code>: Defines a group based on atom types.</li>
<li><code>byid(self, group_name, id_values)</code>: Defines a group based on atom IDs.</li>
<li><code>byregion(self, group_name, region_name)</code>: Defines a group based on a region.</li>
<li><code>variable(self, variable_name, expression, style="atom")</code>: Assigns an expression to a LAMMPS variable.</li>
<li><code>byvariable(self, group_name, variable_name)</code>: Defines a group based on a variable.</li>
<li><code>clear(self, group_name)</code>: Clears an existing group.</li>
</ul>
<h4 id="algebraic-operations">Algebraic Operations</h4>
<ul>
<li><code>union(self, group_name, *groups)</code>: Performs a union of the specified groups.</li>
<li><code>intersect(self, group_name, *groups)</code>: Performs an intersection of the specified groups.</li>
<li><code>subtract(self, group_name, *groups)</code>: Subtracts groups from the first group.</li>
<li><code>evaluate(self, group_name, group_op)</code>: Evaluates a group operation and stores the result.</li>
</ul>
<h4 id="access-and-manipulation">Access and Manipulation</h4>
<ul>
<li><code>__getitem__(self, key)</code>: Allows accessing operations by name or index.</li>
<li><code>__getattr__(self, operation_name)</code>: Enables attribute-style access to operations.</li>
<li><code>__call__(self, *keys)</code>: Returns a new <code><a title="group.group" href="#group.group">group</a></code> instance containing specified operations.</li>
<li><strong>Parameters</strong>:<ul>
<li><code>*keys</code> (str or int): One or more names or indices of operations to retrieve.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li><code><a title="group.group" href="#group.group">group</a></code>: A new <code><a title="group.group" href="#group.group">group</a></code> instance containing the specified operations.</li>
</ul>
</li>
<li><strong>Example</strong>:
<code>python
subG = G('group1', 1, 'group3')
# Retrieves 'group1', second operation, and 'group3'</code></li>
<li><code>list(self)</code>: Returns a list of all operation names.</li>
<li><code>find(self, name)</code>: Finds the index of an operation based on its name.</li>
<li><code>disp(self, name)</code>: Displays the content of an operation.</li>
<li><code>delete(self, name)</code>: Deletes an operation by name.</li>
<li><code>copy(self, source_name, new_name)</code>: Copies an existing operation to a new name.</li>
<li><code>rename(self, old_name, new_name)</code>: Renames an existing operation.</li>
<li><code>reindex(self, name, new_idx)</code>: Changes the index of an operation.</li>
</ul>
<h4 id="script-generation">Script Generation</h4>
<ul>
<li><code>code(self)</code>: Returns the generated LAMMPS commands as a string.</li>
<li><code>dscript(self, name=None)</code>: Generates a <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object containing the group's commands.</li>
<li><code>script(self, name=None)</code>: Generates a script object containing the group's commands.</li>
<li><code><a title="group.pipescript" href="#group.pipescript">pipescript</a>(self)</code>: Generates a <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> object containing each group's command as a separate script in a pipeline.</li>
</ul>
<h3 id="operator-overloading">Operator Overloading</h3>
<ul>
<li><strong>Addition (<code>+</code>)</strong>: Union of groups.</li>
<li><strong>Subtraction (<code>-</code>)</strong>: Subtraction of groups.</li>
<li><strong>Multiplication (<code>*</code>)</strong>: Intersection of groups.</li>
</ul>
<p>These operators are overloaded in the <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class and can be used to combine group operations.</p>
<h3 id="internal-functionality">Internal Functionality</h3>
<p>The class maintains a list <code>_operations</code>, which stores all the group operations
defined. Each operation is an instance of the <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class, which represents
a LAMMPS group command along with its operands and operator.</p>
<h3 id="subindexing-with-callable-syntax">Subindexing with Callable Syntax</h3>
<p>The <code><a title="group.group" href="#group.group">group</a></code> class allows you to retrieve multiple operations by calling the
instance with names or indices:</p>
<ul>
<li><code>__call__(self, *keys)</code>: Returns a new <code><a title="group.group" href="#group.group">group</a></code> instance containing the specified operations.</li>
<li><strong>Parameters</strong>:<ul>
<li><code>*keys</code> (str or int): One or more names or indices of operations to retrieve.</li>
</ul>
</li>
<li><strong>Returns</strong>:<ul>
<li><code><a title="group.group" href="#group.group">group</a></code>: A new <code><a title="group.group" href="#group.group">group</a></code> instance containing the specified operations.</li>
</ul>
</li>
<li><strong>Example</strong>:
<code>python
subG = G('group1', 1, 'group3')
# Retrieves 'group1', second operation, and 'group3'</code></li>
<li><strong>Notes</strong>:<ul>
<li>Indices are 0-based integers.</li>
<li>Duplicate operations are avoided in the new <code><a title="group.group" href="#group.group">group</a></code> instance.</li>
</ul>
</li>
</ul>
<h3 id="integration-with-scripts">Integration with Scripts</h3>
<p>The <code><a title="group.group" href="#group.group">group</a></code> class integrates with <code><a title="group.dscript" href="#group.dscript">dscript</a></code> and <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> classes to allow
advanced script management:</p>
<ul>
<li><strong><code><a title="group.dscript" href="#group.dscript">dscript</a></code></strong>: A dynamic script management class that handles script lines
with variable substitution and conditional execution.</li>
<li><strong><code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code></strong>: Manages a pipeline of scripts, allowing sequential execution
and advanced variable space management.</li>
</ul>
<h3 id="important-notes">Important Notes</h3>
<ul>
<li><strong>Operator Overloading</strong>: The class overloads the <code>+</code>, <code>-</code>, and <code>*</code> operators
for the <code><a title="group.Operation" href="#group.Operation">Operation</a></code> class to perform union, subtraction, and intersection
respectively.</li>
<li><strong>Flexible Group Creation</strong>: Groups can be created upon instantiation or added later using concise methods.</li>
<li><strong>Variable Assignment and Group Definition</strong>: When defining groups based on variables, variable assignment and group creation are handled separately.</li>
<li><strong>Subindexing with <code>__call__</code></strong>: The <code>__call__</code> method allows you to retrieve multiple operations and create subgroups.</li>
<li><strong>Error Handling</strong>: The class includes robust error checking and provides informative error messages.</li>
<li><strong>Lazy Evaluation</strong>: Group operations are stored and only evaluated when
the <code>evaluate</code> method is called.</li>
<li><strong>Name Management</strong>: The class ensures that group names are unique within
the instance to prevent conflicts.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The <code><a title="group.group" href="#group.group">group</a></code> class simplifies the management of groups in LAMMPS simulations,
allowing for clear and maintainable code when dealing with complex group
operations. By providing high-level abstractions, operator overloading,
subindexing capabilities, and integration with script management tools,
it enhances productivity and reduces the potential for errors in simulation setup.</p>
<p>Initializes a new instance of the group class.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional): Name for the group instance. If &lt;code&gt;None&lt;/code&gt; or empty and &lt;code&gt;collection&lt;/code&gt; is provided,
                      generates a name based on beadtypes (e.g., "1+2+3").
groups (dict, optional): Dictionary of group definitions to create upon initialization.
group_names (list or tuple, optional): List of group names to create empty groups upon initialization.
collection (list, tuple, or groupcollection, optional):
    - If a list or tuple, it should contain &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instances.
    - If a &lt;code&gt;&lt;a title="group.groupcollection" href="#group.groupcollection"&gt;groupcollection&lt;/a&gt;&lt;/code&gt; object, it will extract the &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instances from it.
printflag (bool, optional): If &lt;code&gt;True&lt;/code&gt;, enables printing of script generation.
verbose (bool, optional): If &lt;code&gt;True&lt;/code&gt;, enables verbose output.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>TypeError:
    - If &lt;code&gt;groups&lt;/code&gt; is not a dictionary.
    - If &lt;code&gt;group\_names&lt;/code&gt; is not a list or tuple.
    - If &lt;code&gt;collection&lt;/code&gt; is not a list, tuple, or &lt;code&gt;&lt;a title="group.groupcollection" href="#group.groupcollection"&gt;groupcollection&lt;/a&gt;&lt;/code&gt; object.
    - If any item in &lt;code&gt;collection&lt;/code&gt; (when it's a list or tuple) is not a &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instance.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class group:
    &#34;&#34;&#34;
    A class for managing LAMMPS group operations and generating LAMMPS scripts.

    ### Overview

    The `group` class provides an object-oriented interface to define and manage
    groups of atoms in LAMMPS simulations. Groups in LAMMPS are collections of
    atoms that can be manipulated together, allowing users to apply fixes,
    compute properties, or perform operations on specific subsets of atoms.

    This class allows you to create, combine, and manipulate groups using
    algebraic operations (union, intersection, subtraction), and to generate
    the corresponding LAMMPS commands. It also provides methods to output the
    group commands as scripts, which can be integrated into LAMMPS input files.

    ### Key Features

    - **Create and Manage Groups**: Define new groups based on atom types,
      regions, IDs, or variables.
    - **Flexible Group Creation**: Create multiple groups at once and define groups
      using concise criteria through the `add_group_criteria` method.
    - **Algebraic Operations**: Combine groups using union (`+`), intersection (`*`),
      and subtraction (`-`) operations.
    - **Subindexing with Callable Syntax**: Retrieve multiple group operations
      by calling the `group` instance with names or indices.
    - **Script Generation**: Generate LAMMPS script lines for group definitions,
      which can be output as scripts or pipelines.
    - **Dynamic Evaluation**: Evaluate complex group expressions and store the
      resulting operations.
    - **Integration with Scripting Tools**: Convert group operations into
      `dscript` or `pipescript` objects for advanced script management.

    ### LAMMPS Context

    In LAMMPS (Large-scale Atomic/Molecular Massively Parallel Simulator),
    groups are fundamental for specifying subsets of atoms for applying
    operations like forces, fixes, and computes. The `group` command in LAMMPS
    allows users to define groups based on various criteria such as atom IDs,
    types, regions, and variables.

    This `group` class abstracts the complexity of managing group definitions
    and operations, providing a high-level interface to define and manipulate
    groups programmatically.


    ### Usage Examples

    **Creating Multiple Groups at Once**

    ```python
    # Create groups &#39;o1&#39;, &#39;o2&#39;, &#39;o3&#39;, &#39;o4&#39; upon instantiation
    G = group(group_names=[&#39;o1&#39;, &#39;o2&#39;, &#39;o3&#39;, &#39;o4&#39;])
    ```

    **Defining Groups Based on Criteria**

    ```python
    G = group()
    G.add_group_criteria(&#39;lower&#39;, type=[1])
    G.add_group_criteria(&#39;central&#39;, region=&#39;central_cyl&#39;)
    G.add_group_criteria(&#39;new_group&#39;, create=True)
    G.add_group_criteria(&#39;upper&#39;, clear=True)
    G.add_group_criteria(&#39;subtract_group&#39;, subtract=[&#39;group1&#39;, &#39;group2&#39;])
    ```

    **Defining a Group Based on a Variable**

    ```python
    G = group()
    G.variable(&#39;myVar&#39;, &#39;x &gt; 5&#39;)          # Assign a variable
    G.byvariable(&#39;myGroup&#39;, &#39;myVar&#39;)      # Define group based on the variable
    ```

    **Using `add_group_criteria` with Variable**

    ```python
    G.add_group_criteria(&#39;myGroup&#39;, variable={&#39;name&#39;: &#39;myVar&#39;, &#39;expression&#39;: &#39;x &gt; 5&#39;})
    ```

    **Defining Groups Using a Dictionary**

    ```python
    group_definitions = {
        &#39;group1&#39;: {&#39;type&#39;: [1, 2]},
        &#39;group2&#39;: {&#39;region&#39;: &#39;my_region&#39;},
        &#39;group3&#39;: {&#39;variable&#39;: {&#39;name&#39;: &#39;var1&#39;, &#39;expression&#39;: &#39;x &gt; 5&#39;}},
        &#39;group4&#39;: {&#39;union&#39;: [&#39;group1&#39;, &#39;group2&#39;]},
    }
    G.add_group_criteria(group_definitions)
    ```

    **Creating a Group from a Collection of `groupobject` Instances**

    ```python
    # Import the classes
    # from groupobject import groupobject
    # from group import group

    # Create groupobject instances
    o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
    o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
    o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)

    # Create a group instance with the collection
    G = group(name=&#34;mycollection&#34;, collection=[o1, o2, o3])
    # or
    G = group(name=None, collection=[o1, o2, o3])  # Name will be generated as &#34;1+2+3&#34;

    # Generate the LAMMPS script
    script_content = G.code()
    print(script_content)
    ```

    **Expected Output:**
    ```
    group all type 1 2 3
    group A type 1
    group B type 2
    group C type 2 3
    ```

    **Accessing Groups and Performing Operations**

    ```python
    # Access groups via attribute-style or item-style access
    op1 = G.group1
    op2 = G[&#39;group2&#39;]

    # Combine groups using algebraic operations
    complex_op = op1 + op2 - G.group3

    # Evaluate the operation and store the result
    G.evaluate(&#39;combined_group&#39;, complex_op)
    ```


    **Subindexing with Callable Syntax**

    ```python
    # Retrieve multiple operations by names or indices
    subG = G(&#39;group1&#39;, 2, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, third operation, and &#39;group3&#39;

    # Display the names of operations in subG
    operation_names = [op.name for op in subG._operations]
    print(operation_names)  # Output: [&#39;group1&#39;, &#39;group3&#39;, &#39;group3&#39;]

    # Generate the LAMMPS script for the subgroup
    script_content = subG.code()
    print(script_content)
    ```

    **Generating LAMMPS Script**

    ```python
    script_content = G.code()
    print(script_content)
    ```

    ### Class Methods

    #### Initialization and Setup

    - `__init__(self, name=None, groups=None, group_names=None, printflag=False, verbose=True)`: Initializes a new `group` instance.
      - `name` (str): Optional name for the group instance.
      - `groups` (dict): Dictionary of group definitions to create upon initialization.
      - `group_names` (list): List of group names to create empty groups upon initialization.
      - `collection` (list or tuple of groupobject, optional): Collection of groupobject instances.

      - `printflag` (bool): If True, enables printing of script generation.
      - `verbose` (bool): If True, enables verbose output.

    - `create_groups(self, *group_names)`: Creates multiple new groups with the given names.

    - `add_group_criteria(self, *args, **kwargs)`: Adds group(s) based on criteria.
      - Supports two usages:
        - `add_group_criteria(group_name, **criteria)`: Adds a single group.
        - `add_group_criteria(group_definitions)`: Adds multiple groups from a dictionary.

    #### Group Creation Methods

    - `create(self, group_name)`: Creates a new empty group with the given name.
    - `bytype(self, group_name, type_values)`: Defines a group based on atom types.
    - `byid(self, group_name, id_values)`: Defines a group based on atom IDs.
    - `byregion(self, group_name, region_name)`: Defines a group based on a region.
    - `variable(self, variable_name, expression, style=&#34;atom&#34;)`: Assigns an expression to a LAMMPS variable.
    - `byvariable(self, group_name, variable_name)`: Defines a group based on a variable.
    - `clear(self, group_name)`: Clears an existing group.

    #### Algebraic Operations

    - `union(self, group_name, *groups)`: Performs a union of the specified groups.
    - `intersect(self, group_name, *groups)`: Performs an intersection of the specified groups.
    - `subtract(self, group_name, *groups)`: Subtracts groups from the first group.
    - `evaluate(self, group_name, group_op)`: Evaluates a group operation and stores the result.

    #### Access and Manipulation

    - `__getitem__(self, key)`: Allows accessing operations by name or index.
    - `__getattr__(self, operation_name)`: Enables attribute-style access to operations.
    - `__call__(self, *keys)`: Returns a new `group` instance containing specified operations.
      - **Parameters**:
        - `*keys` (str or int): One or more names or indices of operations to retrieve.
      - **Returns**:
        - `group`: A new `group` instance containing the specified operations.
      - **Example**:
        ```python
        subG = G(&#39;group1&#39;, 1, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, second operation, and &#39;group3&#39;
        ```
    - `list(self)`: Returns a list of all operation names.
    - `find(self, name)`: Finds the index of an operation based on its name.
    - `disp(self, name)`: Displays the content of an operation.
    - `delete(self, name)`: Deletes an operation by name.
    - `copy(self, source_name, new_name)`: Copies an existing operation to a new name.
    - `rename(self, old_name, new_name)`: Renames an existing operation.
    - `reindex(self, name, new_idx)`: Changes the index of an operation.

    #### Script Generation

    - `code(self)`: Returns the generated LAMMPS commands as a string.
    - `dscript(self, name=None)`: Generates a `dscript` object containing the group&#39;s commands.
    - `script(self, name=None)`: Generates a script object containing the group&#39;s commands.
    - `pipescript(self)`: Generates a `pipescript` object containing each group&#39;s command as a separate script in a pipeline.

    ### Operator Overloading

    - **Addition (`+`)**: Union of groups.
    - **Subtraction (`-`)**: Subtraction of groups.
    - **Multiplication (`*`)**: Intersection of groups.

    These operators are overloaded in the `Operation` class and can be used to combine group operations.

    ### Internal Functionality

    The class maintains a list `_operations`, which stores all the group operations
    defined. Each operation is an instance of the `Operation` class, which represents
    a LAMMPS group command along with its operands and operator.

    ### Subindexing with Callable Syntax

    The `group` class allows you to retrieve multiple operations by calling the
    instance with names or indices:

    - `__call__(self, *keys)`: Returns a new `group` instance containing the specified operations.
      - **Parameters**:
        - `*keys` (str or int): One or more names or indices of operations to retrieve.
      - **Returns**:
        - `group`: A new `group` instance containing the specified operations.
      - **Example**:
        ```python
        subG = G(&#39;group1&#39;, 1, &#39;group3&#39;)  # Retrieves &#39;group1&#39;, second operation, and &#39;group3&#39;
        ```
      - **Notes**:
        - Indices are 0-based integers.
        - Duplicate operations are avoided in the new `group` instance.

    ### Integration with Scripts

    The `group` class integrates with `dscript` and `pipescript` classes to allow
    advanced script management:

    - **`dscript`**: A dynamic script management class that handles script lines
      with variable substitution and conditional execution.
    - **`pipescript`**: Manages a pipeline of scripts, allowing sequential execution
      and advanced variable space management.

    ### Important Notes

    - **Operator Overloading**: The class overloads the `+`, `-`, and `*` operators
      for the `Operation` class to perform union, subtraction, and intersection
      respectively.
    - **Flexible Group Creation**: Groups can be created upon instantiation or added later using concise methods.
    - **Variable Assignment and Group Definition**: When defining groups based on variables, variable assignment and group creation are handled separately.
    - **Subindexing with `__call__`**: The `__call__` method allows you to retrieve multiple operations and create subgroups.
    - **Error Handling**: The class includes robust error checking and provides informative error messages.
    - **Lazy Evaluation**: Group operations are stored and only evaluated when
      the `evaluate` method is called.
    - **Name Management**: The class ensures that group names are unique within
      the instance to prevent conflicts.

    ### Conclusion

    The `group` class simplifies the management of groups in LAMMPS simulations,
    allowing for clear and maintainable code when dealing with complex group
    operations. By providing high-level abstractions, operator overloading,
    subindexing capabilities, and integration with script management tools,
    it enhances productivity and reduces the potential for errors in simulation setup.
    &#34;&#34;&#34;


    def __init__(self, name=None, groups=None, group_names=None, collection=None, printflag=False, verbose=True, verbosity=None):
        &#34;&#34;&#34;
        Initializes a new instance of the group class.

        ### Parameters:
            name (str, optional): Name for the group instance. If `None` or empty and `collection` is provided,
                                  generates a name based on beadtypes (e.g., &#34;1+2+3&#34;).
            groups (dict, optional): Dictionary of group definitions to create upon initialization.
            group_names (list or tuple, optional): List of group names to create empty groups upon initialization.
            collection (list, tuple, or groupcollection, optional):
                - If a list or tuple, it should contain `groupobject` instances.
                - If a `groupcollection` object, it will extract the `groupobject` instances from it.
            printflag (bool, optional): If `True`, enables printing of script generation.
            verbose (bool, optional): If `True`, enables verbose output.

        ### Raises:
            TypeError:
                - If `groups` is not a dictionary.
                - If `group_names` is not a list or tuple.
                - If `collection` is not a list, tuple, or `groupcollection` object.
                - If any item in `collection` (when it&#39;s a list or tuple) is not a `groupobject` instance.
        &#34;&#34;&#34;
        self._in_construction = True  # Indicate that the object is under construction
        # Handle &#39;name&#39; parameter
        if not name:
            name = generate_random_name()
        self._name = name

        # Initialize other attributes
        self._operations = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = verbosity
        self._in_construction = False  # Set the flag to indicate construction is finished
        # Handle &#39;groups&#39; parameter
        if groups:
            if not isinstance(groups, dict):
                raise TypeError(&#34;Parameter &#39;groups&#39; must be a dictionary.&#34;)
            self.add_group_criteria(groups)
        # Handle &#39;group_names&#39; parameter
        if group_names:
            if not isinstance(group_names, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;group_names&#39; must be a list or tuple of group names.&#34;)
            self.create_groups(*group_names)
        # Handle &#39;collection&#39; parameter
        if collection:
            if isinstance(collection, groupcollection):
                # Extract the list of groupobject instances from the groupcollection
                collection = collection.collection
            elif not isinstance(collection, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;collection&#39; must be a list, tuple, or `groupcollection` object.&#34;)
            # If collection is a list or tuple, validate its items
            if isinstance(collection, (list, tuple)):
                for obj in collection:
                    if not isinstance(obj, groupobject):
                        raise TypeError(&#34;All items in &#39;collection&#39; must be `groupobject` instances.&#34;)
                self.generate_group_definitions_from_collection(collection)



    def create_groups(self, *group_names):
        for group_name in group_names:
            if not isinstance(group_name, str):
                raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
            self.create(group_name)


    def __str__(self):
        return f&#39;Group &#34;{self._name}&#34; with {len(self._operations)} operations\n&#39;


    def format_cell_content(self, content, max_width):
        content = str(content) if content is not None else &#39;&#39;
        if len(content) &gt; max_width:
            start = content[: (max_width - 5) // 2]
            end = content[-((max_width - 5) // 2):]
            content = f&#34;{start} ... {end}&#34;
        return content


    def __repr__(self):
        &#34;&#34;&#34;
        Returns a neatly formatted table representation of the group&#39;s operations.

        Each row represents an operation in the group, displaying its index, name,
        operator, and operands. The table adjusts column widths dynamically and
        truncates content based on maximum column widths.

        ### Returns:
            str: A formatted string representation of the group operations.
        &#34;&#34;&#34;
        # Define headers for the table
        headers = [&#34;Idx&#34;, &#34;Name&#34;, &#34;Operator&#34;, &#34;Operands&#34;]
        col_max_widths = [5, 20, 20, 40]
        align = [&#34;R&#34;, &#34;C&#34;, &#34;C&#34;, &#34;L&#34;]
        # Prepare rows by iterating over the operations
        rows = []
        for idx, op in enumerate(self._operations):
            rows.append([
                str(idx),                    # Index
                str(op.name),                # Name
                str(op.operator),            # Operator
                str(span(op.operands)),      # Operands
            ])
        # Use the helper to format the table
        table = format_table(headers, rows, col_max_widths, align)
        # Append the string representation of the group itself
        return f&#34;{table}\n\n{str(self)}&#34;


    def __len__(self):
        &#34;&#34;&#34; return the number of stored operations &#34;&#34;&#34;
        return len(self._operations)

    def list(self):
        &#34;&#34;&#34; return the list of all operations &#34;&#34;&#34;
        return [op.name for op in self._operations]


    def code(self):
        &#34;&#34;&#34;
            Joins the `code` attributes of all stored `operation` objects with &#39;\n&#39;.
        &#34;&#34;&#34;
        return &#39;\n&#39;.join([op.code for op in self._operations])

    def find(self, name):
        &#34;&#34;&#34;Returns the index of an operation based on its name.&#34;&#34;&#34;
        if &#39;_operations&#39; in self.__dict__:
            for i, op in enumerate(self._operations):
                if op.name == name:
                    return i
        return None

    def disp(self, name):
        &#34;&#34;&#34; display the content of an operation &#34;&#34;&#34;
        idx = self.find(name)
        if idx is not None:
            return self._operations[idx].__repr__()
        else:
            return &#34;Operation not found&#34;

    def clearall(self):
        &#34;&#34;&#34; clear all operations &#34;&#34;&#34;
        self._operations = []

    def delete(self, name):
        &#34;&#34;&#34;
        Deletes one or more stored operations based on their names.

        Parameters:
        -----------
        name : str, list, or tuple
            The name(s) of the operation(s) to delete. If a list or tuple is provided,
            all specified operations will be deleted.

        Usage:
        ------
        G.delete(&#39;operation_name&#39;)
        G.delete([&#39;operation1&#39;, &#39;operation2&#39;])
        G.delete((&#39;operation1&#39;, &#39;operation2&#39;))

        Raises:
        -------
        ValueError
            If any of the specified operations are not found.
        &#34;&#34;&#34;
        # Handle a single string, list, or tuple
        if isinstance(name, (list, tuple)):
            not_found = []
            for n in name:
                idx = self.find(n)
                if idx is not None:
                    del self._operations[idx]
                else:
                    not_found.append(n)
            # If any names were not found, raise an exception
            if not_found:
                raise ValueError(f&#34;Operation(s) {&#39;, &#39;.join(not_found)} not found.&#34;)
        elif isinstance(name, str):
            idx = self.find(name)
            if idx is not None:
                del self._operations[idx]
            else:
                raise ValueError(f&#34;Operation {name} not found.&#34;)
        else:
            raise TypeError(&#34;The &#39;name&#39; parameter must be a string, list, or tuple.&#34;)

    def copy(self, source_name, new_name):
        &#34;&#34;&#34;
        Copies a stored operation to a new operation with a different name.

        Parameters:
        source_name: str
            Name of the source operation to copy
        new_name: str
            Name of the new operation

        Usage:
        G.copy(&#39;source_operation&#39;, &#39;new_operation&#39;)
        &#34;&#34;&#34;
        idx = self.find(source_name)
        if idx is not None:
            copied_operation = self._operations[idx].clone()
            copied_operation.name = new_name
            self.add_operation(copied_operation)
        else:
            raise ValueError(f&#34;Operation {source_name} not found.&#34;)

    def rename(self, old_name, new_name):
        &#34;&#34;&#34;
        Rename a stored operation.

        Parameters:
        old_name: str
            Current name of the operation
        new_name: str
            New name to assign to the operation

        Usage:
        G.rename(&#39;old_operation&#39;, &#39;new_operation&#39;)
        &#34;&#34;&#34;
        idx = self.find(old_name)
        if idx is not None:
            if new_name == old_name:
                raise ValueError(&#34;The new name should be different from the previous one.&#34;)
            elif new_name in self.list():
                raise ValueError(&#34;Operation name must be unique.&#34;)
            self._operations[idx].name = new_name
        else:
            raise ValueError(f&#34;Operation &#39;{old_name}&#39; not found.&#34;)

    def reindex(self, name, new_idx):
        &#34;&#34;&#34;
        Change the index of a stored operation.

        Parameters:
        name: str
            Name of the operation to reindex
        new_idx: int
            New index for the operation

        Usage:
        G.reindex(&#39;operation_name&#39;, 2)
        &#34;&#34;&#34;
        idx = self.find(name)
        if idx is not None and 0 &lt;= new_idx &lt; len(self._operations):
            op = self._operations.pop(idx)
            self._operations.insert(new_idx, op)
        else:
            raise ValueError(f&#34;Operation &#39;{name}&#39; not found or new index {new_idx} out of range.&#34;)

    # ------------- indexing and attribute overloading

    def __getitem__(self, key):
        &#34;&#34;&#34;
            Enable shorthand for G.operations[G.find(operation_name)] using G[operation_name],
            or accessing operation by index using G[index].
        &#34;&#34;&#34;
        if isinstance(key, str):
            idx = self.find(key)
            if idx is not None:
                return self._operations[idx]
            else:
                raise KeyError(f&#34;Operation &#39;{key}&#39; not found.&#34;)
        elif isinstance(key, int):
            if -len(self._operations) &lt;= key &lt; len(self._operations):
                return self._operations[key]
            else:
                raise IndexError(&#34;Operation index out of range.&#34;)
        else:
            raise TypeError(&#34;Key must be an operation name (string) or index (integer).&#34;)


    def __getattr__(self, name):
        &#34;&#34;&#34;
        Allows accessing operations via attribute-style notation.
        If the attribute is one of the core attributes, returns it directly.
        For other attributes, searches for an operation with a matching name
        in the _operations list.

        Parameters:
        -----------
        name : str
            The name of the attribute or operation to access.

        Returns:
        --------
        The value of the attribute if it&#39;s a core attribute, or the operation
        associated with the specified name if found in _operations.

        Raises:
        -------
        AttributeError
            If the attribute or operation is not found.
        &#34;&#34;&#34;
        # Handle core attributes directly
        if name in {&#39;_name&#39;, &#39;_operations&#39;, &#39;printflag&#39;, &#39;verbose&#39;}:
            # Use object.__getattribute__ to avoid recursion
            return object.__getattribute__(self, name)
        # Search for the operation in _operations
        elif &#39;_operations&#39; in self.__dict__:
            for op in self._operations:
                if op.name == name:
                    return op
        # If not found, raise an AttributeError
        raise AttributeError(f&#34;Attribute or operation &#39;{name}&#39; not found.&#34;)


    def __setattr__(self, name, value):
        &#34;&#34;&#34;
        Allows deletion of an operation via &#39;G.operation_name = []&#39; after construction.
        During construction, attributes are set normally.
        &#34;&#34;&#34;
        if getattr(self, &#39;_in_construction&#39;, True):
            # During construction, set attributes normally
            super().__setattr__(name, value)
        else:
            # After construction
            if isinstance(value, list) and len(value) == 0:
                # Handle deletion syntax
                idx = self.find(name)
                if idx is not None:
                    del self._operations[idx]
                else:
                    raise AttributeError(f&#34;Operation &#39;{name}&#39; not found for deletion.&#34;)
            else:
                # Set attribute normally
                super().__setattr__(name, value)


    def _get_subobject(self, key):
        &#34;&#34;&#34;
        Retrieves a subobject based on the provided key.

        Parameters:
        -----------
        key : str or int
            The key used to retrieve the subobject.

        Returns:
        --------
        Operation
            The operation corresponding to the key.

        Raises:
        -------
        KeyError
            If the key is not found.
        IndexError
            If the index is out of range.
        TypeError
            If the key is not a string or integer.
        &#34;&#34;&#34;
        if isinstance(key, str):
            # If key is a string, treat it as a group name
            for operation in self._operations:
                if operation.name == key:
                    return operation
            raise KeyError(f&#34;No operation found with name &#39;{key}&#39;.&#34;)
        elif isinstance(key, int):
            # If key is an integer, treat it as an index (0-based)
            if 0 &lt;= key &lt; len(self._operations):
                return self._operations[key]
            else:
                raise IndexError(f&#34;Index {key} is out of range.&#34;)
        else:
            raise TypeError(&#34;Key must be a string or integer.&#34;)


    def __call__(self, *keys):
        &#34;&#34;&#34;
        Allows subindexing of the group object using callable syntax with multiple keys.

        Parameters:
        -----------
        *keys : str or int
            One or more keys used to retrieve subobjects or perform subindexing.

        Returns:
        --------
        group
            A new group instance containing the specified operations.

        Example:
        --------
        subG = G(&#39;a&#39;, 1, &#39;c&#39;)  # Retrieves operations &#39;a&#39;, second operation, and &#39;c&#39;
        &#34;&#34;&#34;
        selected_operations = []
        for key in keys:
            operation = self._get_subobject(key)
            selected_operations.append(operation)

        # Create a new group instance with the selected operations
        new_group = group(name=f&#34;{self._name}_subgroup&#34;, printflag=self.printflag, verbose=self.verbose)
        new_group._operations = selected_operations
        return new_group


    def operation_exists(self,operation_name):
        &#34;&#34;&#34;
            Returns true if &#34;operation_name&#34; exists
            To be used by Operation, not by end-user, which should prefer find()
        &#34;&#34;&#34;
        return any(op.name == operation_name for op in self._operations)

    def get_by_name(self,operation_name):
        &#34;&#34;&#34;
            Returns the operation matching &#34;operation_name&#34;
            Usage: group.get_by_name(&#34;operation_name&#34;)
            To be used by Operation, not by end-user, which should prefer getattr()
        &#34;&#34;&#34;
        for op in self._operations:
            if op.name == operation_name:
                return op
        raise AttributeError(f&#34;Operation with name &#39;{operation_name}&#39; not found.&#34;)

    def add_operation(self,operation):
        &#34;&#34;&#34; add an operation &#34;&#34;&#34;
        if operation.name in self.list():
            raise ValueError(f&#34;The operation &#39;{operation.name}&#39; already exists.&#34;)
        else:
            self._operations.append(operation)

    # --------- LAMMPS methods

    def variable(self, variable_name, expression, style=&#34;atom&#34;):
        &#34;&#34;&#34;
        Assigns an expression to a LAMMPS variable.

        Parameters:
        - variable_name (str): The name of the variable to be assigned.
        - expression (str): The expression to assign to the variable.
        - style (str): The type of variable (default is &#34;atom&#34;).
        &#34;&#34;&#34;
        if not isinstance(variable_name, str):
            raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)
        if not isinstance(expression, str):
            raise TypeError(f&#34;Expression must be a string, got {type(expression)}&#34;)
        if not isinstance(style, str):
            raise TypeError(f&#34;Style must be a string, got {type(style)}&#34;)

        lammps_code = f&#34;variable {variable_name} {style} \&#34;{expression}\&#34;&#34;
        op = Operation(&#34;variable&#34;, [variable_name, expression], code=lammps_code)
        self.add_operation(op)


    def byvariable(self, group_name, variable_name):
        &#34;&#34;&#34;
        Sets a group of atoms based on a variable.

        Parameters:
        - group_name: str, the name of the group.
        - variable_name: str, the name of the variable to define the group.
        &#34;&#34;&#34;
        if not isinstance(group_name, str):
            raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
        if not isinstance(variable_name, str):
            raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)

        lammps_code = f&#34;group {group_name} variable {variable_name}&#34;
        op = Operation(&#34;byvariable&#34;, [variable_name], name=group_name, code=lammps_code)
        self.add_operation(op)


    def byregion(self, group_name, region_name):
        &#34;&#34;&#34;
            set a group of atoms based on a regionID
            G.region(group_name,regionID)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} region {region_name}&#34;
        criteria = {&#34;region&#34;: region_name}
        op = Operation(&#34;byregion&#34;, [region_name], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def bytype(self,  group_name, type_values):
        &#34;&#34;&#34;
            select atoms by type and store them in group
            G.type(group_name,type_values)
        &#34;&#34;&#34;
        if not isinstance(type_values, (list, tuple)):
            type_values = [type_values]
        lammps_code = f&#34;group {group_name} type {span(type_values)}&#34;
        criteria = {&#34;type&#34;: type_values}
        op = Operation(&#34;bytype&#34;, type_values, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def byid(self, group_name, id_values):
        &#34;&#34;&#34;
            select atoms by id and store them in group
            G.id(group_name,id_values)
        &#34;&#34;&#34;
        if not isinstance(id_values, (list, tuple)):
            id_values = [id_values]
        lammps_code = f&#34;group {group_name} id {span(id_values)}&#34;
        criteria = {&#34;id&#34;: id_values}
        op = Operation(&#34;byid&#34;, id_values, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def create(self, group_name):
        &#34;&#34;&#34;
            create group
            G.create(group_name)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} clear&#34;
        criteria = {&#34;clear&#34;: True}
        op = Operation(&#34;create&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)

    def clear(self, group_name):
        &#34;&#34;&#34;
            clear group
            G.clear(group_name)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group} clear&#34;
        criteria = {&#34;clear&#34;: True}
        op = Operation(&#34;clear&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def union(self,group_name, *groups):
        &#34;&#34;&#34;
        Union group1, group2, group3 and store the result in group_name.
        Example usage:
        group.union(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} union {span(groups)}&#34;
        criteria = {&#34;union&#34;: groups}
        op = Operation(&#34;union&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def intersect(self,group_name, *groups):
        &#34;&#34;&#34;
        Intersect group1, group2, group3 and store the result in group_name.
        Example usage:
        group.intersect(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} intersect {span(groups)}&#34;
        criteria = {&#34;intersect&#34;: groups}
        op = Operation(&#34;intersect&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def subtract(self,group_name, *groups):
        &#34;&#34;&#34;
        Subtract group2, group3 from group1 and store the result in group_name.
        Example usage:
        group.subtract(group_name, group1, group2, group3,...)
        &#34;&#34;&#34;
        lammps_code = f&#34;group {group_name} subtract {span(groups)}&#34;
        criteria = {&#34;subtract&#34;: groups}
        op = Operation(&#34;subtract&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
        self.add_operation(op)


    def evaluate(self, group_name, group_op):
        &#34;&#34;&#34;
        Evaluates the operation and stores the result in a new group.
        Expressions could combine +, - and * like o1+o2+o3-o4+o5+o6

        Parameters:
        -----------
        groupname : str
            The name of the group that will store the result.
        group_op : Operation
            The operation to evaluate.
        &#34;&#34;&#34;
        if not isinstance(group_op, Operation):
            raise TypeError(&#34;Expected an instance of Operation.&#34;)

        if group_name in self.list():
            raise ValueError(f&#34;The operation &#39;{group_name}&#39; already exists.&#34;)

        # If the operation is already finalized, no need to evaluate
        if group_op.isfinalized():
            if group_op.name != group_name:
                # If names differ, create a copy with the new name
                self.copy(group_op.name, group_name)
            return

        # Recursively evaluate operands
        operand_names = []
        for op in group_op.operands:
            if isinstance(op, Operation):
                if op.isfinalized():
                    # Use existing finalized operation name
                    operand_names.append(op.name)
                else:
                    # Generate a unique name if the operation doesn&#39;t have one
                    if not op.name:
                        op.name = op.generate_hashname()
                    # Recursively evaluate the operand operation
                    self.evaluate(op.name, op)
                    operand_names.append(op.name)
            else:
                operand_names.append(str(op))

        # Call the appropriate method based on the operator
        if group_op.operator == &#39;+&#39;:
            self.union(group_name, *operand_names)
            group_op.operator = &#39;union&#39;
        elif group_op.operator == &#39;-&#39;:
            self.subtract(group_name, *operand_names)
            group_op.operator = &#39;subtract&#39;
        elif group_op.operator == &#39;*&#39;:
            self.intersect(group_name, *operand_names)
            group_op.operator = &#39;intersect&#39;
        else:
            raise ValueError(f&#34;Unknown operator: {group_op.operator}&#34;)

        # Update the operation
        group_op.name = group_name
        # Get the last added operation
        finalized_op = self._operations[-1]
        group_op.code = finalized_op.code
        group_op.operands = operand_names

        # Add the operation to the group&#39;s _operations if not already added
        if group_op.name not in self.list():
            self._operations.append(group_op)


    def add_group_criteria(self, *args, **kwargs):
        &#34;&#34;&#34;
        Adds group(s) using existing methods based on key-value pairs.

        Supports two usages:
        1. add_group_criteria(group_name, **criteria)
        2. add_group_criteria(group_definitions)

        Parameters:
        - group_name (str): The name of the group.
        - **criteria: Criteria for group creation.

        OR

        - group_definitions (dict): A dictionary where keys are group names and values are criteria dictionaries.

        Raises:
        - TypeError: If arguments are invalid.

        Usage:
        - G.add_group_criteria(&#39;group_name&#39;, type=[1,2])
        - G.add_group_criteria({&#39;group1&#39;: {&#39;type&#39;: [1]}, &#39;group2&#39;: {&#39;region&#39;: &#39;regionID&#39;}})
        &#34;&#34;&#34;
        if len(args) == 1 and isinstance(args[0], dict):
            # Called with group_definitions dict
            group_definitions = args[0]
            for group_name, criteria in group_definitions.items():
                self.add_group_criteria_single(group_name, **criteria)
        elif len(args) == 1 and isinstance(args[0], str):
            # Called with group_name and criteria
            group_name = args[0]
            if not kwargs:
                raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)
            self.add_group_criteria_single(group_name, **kwargs)
        else:
            raise TypeError(&#34;Invalid arguments. Use add_group_criteria(group_name, **criteria) or add_group_criteria(group_definitions).&#34;)


    def add_group_criteria_single(self, group_name, **criteria):
        &#34;&#34;&#34;
        Adds a single group based on criteria.

        Parameters:
        - group_name (str): The name of the group.
        - **criteria: Criteria for group creation.

        Raises:
        - TypeError: If group_name is not a string.
        - ValueError: If no valid criteria are provided or if criteria are invalid.


        Example (advanced):
            G = group()
            group_definitions = {
                &#39;myGroup&#39;: {
                    &#39;variable&#39;: {
                        &#39;name&#39;: &#39;myVar&#39;,
                        &#39;expression&#39;: &#39;x &gt; 5&#39;,
                        &#39;style&#39;: &#39;atom&#39;
                    }
                }
            }
            G.add_group_criteria(group_definitions)
            print(G.code())

        Expected output
            variable myVar atom &#34;x &gt; 5&#34;
            group myGroup variable myVar
        &#34;&#34;&#34;
        if not isinstance(group_name, str):
            raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)

        if not criteria:
            raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)

        if &#34;type&#34; in criteria:
            type_values = criteria[&#34;type&#34;]
            if not isinstance(type_values, (list, tuple, int)):
                raise TypeError(&#34;Type values must be an integer or a list/tuple of integers.&#34;)
            self.bytype(group_name, type_values)

        elif &#34;region&#34; in criteria:
            region_name = criteria[&#34;region&#34;]
            if not isinstance(region_name, str):
                raise TypeError(&#34;Region name must be a string.&#34;)
            self.byregion(group_name, region_name)

        elif &#34;id&#34; in criteria:
            id_values = criteria[&#34;id&#34;]
            if not isinstance(id_values, (list, tuple, int)):
                raise TypeError(&#34;ID values must be an integer or a list/tuple of integers.&#34;)
            self.byid(group_name, id_values)

        elif &#34;variable&#34; in criteria:
            var_info = criteria[&#34;variable&#34;]
            if not isinstance(var_info, dict):
                raise TypeError(&#34;Variable criteria must be a dictionary.&#34;)
            required_keys = {&#39;name&#39;, &#39;expression&#39;}
            if not required_keys.issubset(var_info.keys()):
                missing = required_keys - var_info.keys()
                raise ValueError(f&#34;Variable criteria missing keys: {missing}&#34;)
            var_name = var_info[&#39;name&#39;]
            expression = var_info[&#39;expression&#39;]
            style = var_info.get(&#39;style&#39;, &#39;atom&#39;)

            # First, assign the variable
            self.variable(var_name, expression, style)

            # Then, create the group based on the variable
            self.byvariable(group_name, var_name)

        elif &#34;union&#34; in criteria:
            groups = criteria[&#34;union&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Union groups must be a list or tuple of group names.&#34;)
            self.union(group_name, *groups)

        elif &#34;intersect&#34; in criteria:
            groups = criteria[&#34;intersect&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Intersect groups must be a list or tuple of group names.&#34;)
            self.intersect(group_name, *groups)

        elif &#34;subtract&#34; in criteria:
            groups = criteria[&#34;subtract&#34;]
            if not isinstance(groups, (list, tuple)):
                raise TypeError(&#34;Subtract groups must be a list or tuple of group names.&#34;)
            self.subtract(group_name, *groups)

        elif &#34;create&#34; in criteria and criteria[&#34;create&#34;]:
            self.create(group_name)

        elif &#34;clear&#34; in criteria and criteria[&#34;clear&#34;]:
            self.clear(group_name)

        else:
            raise ValueError(f&#34;No valid criterion provided for group &#39;{group_name}&#39;.&#34;)




    def get_group_criteria(self, group_name):
        &#34;&#34;&#34;
        Retrieve the criteria that define a group. Handles group_name as a string or number.

        Parameters:
        - group_name: str or int, the name or number of the group.

        Returns:
        - dict or str: The criteria used to define the group, or a message if defined by multiple criteria.

        Raises:
        - ValueError: If the group does not exist.
        &#34;&#34;&#34;
        # Check if group_name exists in _operations
        if group_name not in self._operations:
            raise ValueError(f&#34;Group &#39;{group_name}&#39; does not exist.&#34;)

        # Retrieve all operations related to the group directly from _operations
        operations = self._operations[group_name]

        if not operations:
            raise ValueError(f&#34;No operations found for group &#39;{group_name}&#39;.&#34;)

        criteria = {}
        for op in operations:
            if op.criteria:
                criteria.update(op.criteria)

        # If multiple criteria, return a message
        if len(criteria) &gt; 1:
            return f&#34;Group &#39;{group_name}&#39; is defined by multiple criteria: {criteria}&#34;

        return criteria


    def generate_group_definitions_from_collection(self,collection):
        &#34;&#34;&#34;
        Generates group definitions based on the collection of groupobject instances.

        This method populates the groups based on beadtypes and associated group names.
        &#34;&#34;&#34;
        group_defs = {}
        for obj in collection:
            for group_name in obj.group:
                if group_name not in group_defs:
                    group_defs[group_name] = {&#39;type&#39;: []}
                if obj.beadtype not in group_defs[group_name][&#39;type&#39;]:
                    group_defs[group_name][&#39;type&#39;].append(obj.beadtype)
        # Now, add these group definitions
        self.add_group_criteria(group_defs)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a dscript object containing the group&#39;s LAMMPS commands.

        Parameters:
        - name (str): Optional name for the script object.
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - dscript: A dscript object containing the group&#39;s code.
        &#34;&#34;&#34;
        if name is None:
            name = self._name
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        # Create a new dscript object
        dscript_obj = dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity)
        # Add each line of the group&#39;s code to the script object
        for idx, op in enumerate(self._operations):
            # Use the index as the key for the script line
           dscript_obj[idx] = op.code
        return dscript_obj


    def script(self, name=None, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a script object containing the group&#39;s LAMMPS commands.

        Parameters:
        - name (str): Optional name for the script object.
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - script: A script object containing the group&#39;s code.
        &#34;&#34;&#34;
        if name is None:
            name = self._name
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        script_obj = self.dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity).script(printflag=printflag, verbose=verbose, verbosity=verbosity)
        return script_obj


    def pipescript(self, printflag=None, verbose=None, verbosity=None):
        &#34;&#34;&#34;
        Generates a pipescript object containing the group&#39;s LAMMPS commands.

        Parameters:
        - printflag (bool, default=False): print on the current console if True
        - verbose (bool, default=True): keep comments if True

        Returns:
        - pipescript: A pipescript object containing the group&#39;s code lines as individual scripts in the pipeline.
        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        # Create a list to hold script objects
        script_list = []

        # For each operation, create a script object and add it to the list
        for op in self._operations:
            # Create a dscript object with the code line
            dscript_obj = dscript(printflag=printflag, verbose=verbose, verbosity=verbosity)
            dscript_obj[&#34;dummy&#34;] = op.code

            # Convert the dscript to a script object
            script_obj = dscript_obj.script(printflag=printflag, verbose=verbose, verbosity=verbosity)

            # Add the script object to the list
            script_list.append(script_obj)

        # Use the static method &#39;join&#39; to create a pipescript from the list
        if script_list:
            pipe_obj = pipescript.join(script_list)
        else:
            pipe_obj = pipescript()

        return pipe_obj

    # Note that it was not the original intent to copy scripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, copy.deepcopy(v, memo))
        return copie


    def count(self,name=None, selection: Optional[List[str]] = None) -&gt; &#39;dscript&#39;:
        &#34;&#34;&#34;
        Generates DSCRIPT counters for specified groups with LAMMPS variable definitions and print commands.

        The method retrieves the list of group names using `self.list()`. If `selection` is provided, it
        filters the groups to include only those specified. It then creates a variable for each selected
        group that counts the number of atoms in that group and generates corresponding print commands.
        The commands are encapsulated within a `dscript` object for execution.

        ### Parameters:
            selection (list of str, optional):
                - List of group names to be numbered.
                - If `None`, all groups in the collection are numbered.

        ### Returns:
            dscript: A `dscript` object containing the variable definitions and print commands, formatted as follows:
                     ```
                     variable n_lower equal &#34;count(lower)&#34;
                     variable n_middle equal &#34;count(middle)&#34;
                     variable n_upper equal &#34;count(upper)&#34;

                     print &#34;Number of atoms in lower: ${n_lower}&#34;
                     print &#34;Number of atoms in middle: ${n_middle}&#34;
                     print &#34;Number of atoms in upper: ${n_upper}&#34;
                     ```
                     The `variables` attribute holds the variable definitions, and the `printvariables` attribute
                     holds the print commands, each separated by a newline.

        ### Raises:
            ValueError:
                - If any group specified in `selection` does not exist in the collection.
                - If `selection` contains duplicate group names.
            TypeError:
                - If `selection` is not a list of strings.

        ### Example:
            ```python
            # Create groupobject instances
            g1 = groupobject(beadtype=1,group = &#39;lower&#39;)
            g2 = groupobject(beadtype=2,group = &#39;middle&#39;)
            g3 = groupobject(beadtype=3,group = &#39;upper&#39;)

            # Initialize a group with the groupobjects
            G = group(name=&#34;1+2+3&#34;,collection=(g1,g2,g3)) or collection=g1+g2+g3

            # add other groups
            G.evaluate(&#34;all&#34;, G.lower + G.middle + G.upper)
            G.evaluate(&#34;external&#34;, G.all - G.middle)

            # Generate number commands for all groups
            N = G.count(selection=[&#34;all&#34;,&#34;lower&#34;,&#34;middle&#34;,&#34;lower&#34;])
            print(N.do())
            ```

            **Output:**
            ```
            variable n_all equal &#34;count(all)&#34;
            variable n_lower equal &#34;count(lower)&#34;
            variable n_middle equal &#34;count(middle)&#34;
            variable n_upper equal &#34;count(upper)&#34;
            print &#34;Number of atoms in all: ${n_all}&#34;
            print &#34;Number of atoms in lower: ${n_lower}&#34;
            print &#34;Number of atoms in middle: ${n_middle}&#34;
            print &#34;Number of atoms in upper: ${n_upper}&#34;
            ```
        &#34;&#34;&#34;
        # Retrieve the list of all group names
        all_group_names = self.list()

        # If selection is provided, validate it
        if selection is not None:
            if not isinstance(selection, (list, tuple)):
                raise TypeError(&#34;Parameter &#39;selection&#39; must be a list of group names.&#34;)
            if not all(isinstance(gitem, str) for gitem in selection):
                raise TypeError(&#34;All items in &#39;selection&#39; must be strings representing group names.&#34;)
            if len(selection) != len(set(selection)):
                raise ValueError(&#34;Duplicate group names found in &#39;selection&#39;. Each group should be unique.&#34;)
            # Check that all selected groups exist
            missing_groups = set(selection) - set(all_group_names)
            if missing_groups:
                raise ValueError(f&#34;The following groups are not present in the collection: {&#39;, &#39;.join(missing_groups)}&#34;)
            # Use the selected groups
            target_groups = selection
        else:
            # If no selection, target all groups
            target_groups = all_group_names

        # Initialize lists to hold variable definitions and print commands
        variable_definitions = []
        print_commands = []
        for gitem in target_groups:
            # Validate group name
            if not gitem:
                raise ValueError(&#34;Group names must be non-empty strings.&#34;)
            # Create a valid variable name by replacing any non-alphanumeric characters with underscores
            variable_name = f&#34;n_{gitem}&#34;.replace(&#34; &#34;, &#34;_&#34;).replace(&#34;-&#34;, &#34;_&#34;)
            # Define the variable to count the number of atoms in the group
            variable_definitions.append(f&#39;variable {variable_name} equal &#34;count({gitem})&#34;&#39;)
            # Define the corresponding print command
            print_commands.append(f&#39;print &#34;Number of atoms in {gitem}: ${{{variable_name}}}&#34;&#39;)
        # Create a dscript object with the generated commands
        idD = f&#34;&lt;dscript:group:{self._name}:count&gt;&#34;
        D = dscript(
            name=idD if name is None else name,
            description=f&#34;{idD} for group counts&#34;
        )
        D.variables = &#34;\n&#34;.join(variable_definitions)
        D.printvariables = &#34;\n&#34;.join(print_commands)
        D.set_all_variables()
        return D</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="group.group.add_group_criteria"><code class="name flex">
<span>def <span class="ident">add_group_criteria</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds group(s) using existing methods based on key-value pairs.</p>
<p>Supports two usages:
1. add_group_criteria(group_name, **criteria)
2. add_group_criteria(group_definitions)</p>
<p>Parameters:
- group_name (str): The name of the group.
- **criteria: Criteria for group creation.</p>
<p>OR</p>
<ul>
<li>group_definitions (dict): A dictionary where keys are group names and values are criteria dictionaries.</li>
</ul>
<p>Raises:
- TypeError: If arguments are invalid.</p>
<p>Usage:
- G.add_group_criteria('group_name', type=[1,2])
- G.add_group_criteria({'group1': {'type': [1]}, 'group2': {'region': 'regionID'}})</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_group_criteria(self, *args, **kwargs):
    &#34;&#34;&#34;
    Adds group(s) using existing methods based on key-value pairs.

    Supports two usages:
    1. add_group_criteria(group_name, **criteria)
    2. add_group_criteria(group_definitions)

    Parameters:
    - group_name (str): The name of the group.
    - **criteria: Criteria for group creation.

    OR

    - group_definitions (dict): A dictionary where keys are group names and values are criteria dictionaries.

    Raises:
    - TypeError: If arguments are invalid.

    Usage:
    - G.add_group_criteria(&#39;group_name&#39;, type=[1,2])
    - G.add_group_criteria({&#39;group1&#39;: {&#39;type&#39;: [1]}, &#39;group2&#39;: {&#39;region&#39;: &#39;regionID&#39;}})
    &#34;&#34;&#34;
    if len(args) == 1 and isinstance(args[0], dict):
        # Called with group_definitions dict
        group_definitions = args[0]
        for group_name, criteria in group_definitions.items():
            self.add_group_criteria_single(group_name, **criteria)
    elif len(args) == 1 and isinstance(args[0], str):
        # Called with group_name and criteria
        group_name = args[0]
        if not kwargs:
            raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)
        self.add_group_criteria_single(group_name, **kwargs)
    else:
        raise TypeError(&#34;Invalid arguments. Use add_group_criteria(group_name, **criteria) or add_group_criteria(group_definitions).&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.add_group_criteria_single"><code class="name flex">
<span>def <span class="ident">add_group_criteria_single</span></span>(<span>self, group_name, **criteria)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a single group based on criteria.</p>
<p>Parameters:
- group_name (str): The name of the group.
- **criteria: Criteria for group creation.</p>
<p>Raises:
- TypeError: If group_name is not a string.
- ValueError: If no valid criteria are provided or if criteria are invalid.</p>
<p>Example (advanced):
G = group()
group_definitions = {
'myGroup': {
'variable': {
'name': 'myVar',
'expression': 'x &gt; 5',
'style': 'atom'
}
}
}
G.add_group_criteria(group_definitions)
print(G.code())</p>
<p>Expected output
variable myVar atom "x &gt; 5"
group myGroup variable myVar</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_group_criteria_single(self, group_name, **criteria):
    &#34;&#34;&#34;
    Adds a single group based on criteria.

    Parameters:
    - group_name (str): The name of the group.
    - **criteria: Criteria for group creation.

    Raises:
    - TypeError: If group_name is not a string.
    - ValueError: If no valid criteria are provided or if criteria are invalid.


    Example (advanced):
        G = group()
        group_definitions = {
            &#39;myGroup&#39;: {
                &#39;variable&#39;: {
                    &#39;name&#39;: &#39;myVar&#39;,
                    &#39;expression&#39;: &#39;x &gt; 5&#39;,
                    &#39;style&#39;: &#39;atom&#39;
                }
            }
        }
        G.add_group_criteria(group_definitions)
        print(G.code())

    Expected output
        variable myVar atom &#34;x &gt; 5&#34;
        group myGroup variable myVar
    &#34;&#34;&#34;
    if not isinstance(group_name, str):
        raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)

    if not criteria:
        raise ValueError(f&#34;No criteria provided for group &#39;{group_name}&#39;.&#34;)

    if &#34;type&#34; in criteria:
        type_values = criteria[&#34;type&#34;]
        if not isinstance(type_values, (list, tuple, int)):
            raise TypeError(&#34;Type values must be an integer or a list/tuple of integers.&#34;)
        self.bytype(group_name, type_values)

    elif &#34;region&#34; in criteria:
        region_name = criteria[&#34;region&#34;]
        if not isinstance(region_name, str):
            raise TypeError(&#34;Region name must be a string.&#34;)
        self.byregion(group_name, region_name)

    elif &#34;id&#34; in criteria:
        id_values = criteria[&#34;id&#34;]
        if not isinstance(id_values, (list, tuple, int)):
            raise TypeError(&#34;ID values must be an integer or a list/tuple of integers.&#34;)
        self.byid(group_name, id_values)

    elif &#34;variable&#34; in criteria:
        var_info = criteria[&#34;variable&#34;]
        if not isinstance(var_info, dict):
            raise TypeError(&#34;Variable criteria must be a dictionary.&#34;)
        required_keys = {&#39;name&#39;, &#39;expression&#39;}
        if not required_keys.issubset(var_info.keys()):
            missing = required_keys - var_info.keys()
            raise ValueError(f&#34;Variable criteria missing keys: {missing}&#34;)
        var_name = var_info[&#39;name&#39;]
        expression = var_info[&#39;expression&#39;]
        style = var_info.get(&#39;style&#39;, &#39;atom&#39;)

        # First, assign the variable
        self.variable(var_name, expression, style)

        # Then, create the group based on the variable
        self.byvariable(group_name, var_name)

    elif &#34;union&#34; in criteria:
        groups = criteria[&#34;union&#34;]
        if not isinstance(groups, (list, tuple)):
            raise TypeError(&#34;Union groups must be a list or tuple of group names.&#34;)
        self.union(group_name, *groups)

    elif &#34;intersect&#34; in criteria:
        groups = criteria[&#34;intersect&#34;]
        if not isinstance(groups, (list, tuple)):
            raise TypeError(&#34;Intersect groups must be a list or tuple of group names.&#34;)
        self.intersect(group_name, *groups)

    elif &#34;subtract&#34; in criteria:
        groups = criteria[&#34;subtract&#34;]
        if not isinstance(groups, (list, tuple)):
            raise TypeError(&#34;Subtract groups must be a list or tuple of group names.&#34;)
        self.subtract(group_name, *groups)

    elif &#34;create&#34; in criteria and criteria[&#34;create&#34;]:
        self.create(group_name)

    elif &#34;clear&#34; in criteria and criteria[&#34;clear&#34;]:
        self.clear(group_name)

    else:
        raise ValueError(f&#34;No valid criterion provided for group &#39;{group_name}&#39;.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.add_operation"><code class="name flex">
<span>def <span class="ident">add_operation</span></span>(<span>self, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>add an operation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_operation(self,operation):
    &#34;&#34;&#34; add an operation &#34;&#34;&#34;
    if operation.name in self.list():
        raise ValueError(f&#34;The operation &#39;{operation.name}&#39; already exists.&#34;)
    else:
        self._operations.append(operation)</code></pre>
</details>
</dd>
<dt id="group.group.byid"><code class="name flex">
<span>def <span class="ident">byid</span></span>(<span>self, group_name, id_values)</span>
</code></dt>
<dd>
<div class="desc"><p>select atoms by id and store them in group
G.id(group_name,id_values)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byid(self, group_name, id_values):
    &#34;&#34;&#34;
        select atoms by id and store them in group
        G.id(group_name,id_values)
    &#34;&#34;&#34;
    if not isinstance(id_values, (list, tuple)):
        id_values = [id_values]
    lammps_code = f&#34;group {group_name} id {span(id_values)}&#34;
    criteria = {&#34;id&#34;: id_values}
    op = Operation(&#34;byid&#34;, id_values, name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.byregion"><code class="name flex">
<span>def <span class="ident">byregion</span></span>(<span>self, group_name, region_name)</span>
</code></dt>
<dd>
<div class="desc"><p>set a group of atoms based on a regionID
G.region(group_name,regionID)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byregion(self, group_name, region_name):
    &#34;&#34;&#34;
        set a group of atoms based on a regionID
        G.region(group_name,regionID)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group_name} region {region_name}&#34;
    criteria = {&#34;region&#34;: region_name}
    op = Operation(&#34;byregion&#34;, [region_name], name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.bytype"><code class="name flex">
<span>def <span class="ident">bytype</span></span>(<span>self, group_name, type_values)</span>
</code></dt>
<dd>
<div class="desc"><p>select atoms by type and store them in group
G.type(group_name,type_values)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bytype(self,  group_name, type_values):
    &#34;&#34;&#34;
        select atoms by type and store them in group
        G.type(group_name,type_values)
    &#34;&#34;&#34;
    if not isinstance(type_values, (list, tuple)):
        type_values = [type_values]
    lammps_code = f&#34;group {group_name} type {span(type_values)}&#34;
    criteria = {&#34;type&#34;: type_values}
    op = Operation(&#34;bytype&#34;, type_values, name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.byvariable"><code class="name flex">
<span>def <span class="ident">byvariable</span></span>(<span>self, group_name, variable_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a group of atoms based on a variable.</p>
<p>Parameters:
- group_name: str, the name of the group.
- variable_name: str, the name of the variable to define the group.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byvariable(self, group_name, variable_name):
    &#34;&#34;&#34;
    Sets a group of atoms based on a variable.

    Parameters:
    - group_name: str, the name of the group.
    - variable_name: str, the name of the variable to define the group.
    &#34;&#34;&#34;
    if not isinstance(group_name, str):
        raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
    if not isinstance(variable_name, str):
        raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)

    lammps_code = f&#34;group {group_name} variable {variable_name}&#34;
    op = Operation(&#34;byvariable&#34;, [variable_name], name=group_name, code=lammps_code)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, group_name)</span>
</code></dt>
<dd>
<div class="desc"><p>clear group
G.clear(group_name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self, group_name):
    &#34;&#34;&#34;
        clear group
        G.clear(group_name)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group} clear&#34;
    criteria = {&#34;clear&#34;: True}
    op = Operation(&#34;clear&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.clearall"><code class="name flex">
<span>def <span class="ident">clearall</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear all operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearall(self):
    &#34;&#34;&#34; clear all operations &#34;&#34;&#34;
    self._operations = []</code></pre>
</details>
</dd>
<dt id="group.group.code"><code class="name flex">
<span>def <span class="ident">code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Joins the <code>code</code> attributes of all stored <code>operation</code> objects with '
'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code(self):
    &#34;&#34;&#34;
        Joins the `code` attributes of all stored `operation` objects with &#39;\n&#39;.
    &#34;&#34;&#34;
    return &#39;\n&#39;.join([op.code for op in self._operations])</code></pre>
</details>
</dd>
<dt id="group.group.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, source_name, new_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Copies a stored operation to a new operation with a different name.</p>
<p>Parameters:
source_name: str
Name of the source operation to copy
new_name: str
Name of the new operation</p>
<p>Usage:
G.copy('source_operation', 'new_operation')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, source_name, new_name):
    &#34;&#34;&#34;
    Copies a stored operation to a new operation with a different name.

    Parameters:
    source_name: str
        Name of the source operation to copy
    new_name: str
        Name of the new operation

    Usage:
    G.copy(&#39;source_operation&#39;, &#39;new_operation&#39;)
    &#34;&#34;&#34;
    idx = self.find(source_name)
    if idx is not None:
        copied_operation = self._operations[idx].clone()
        copied_operation.name = new_name
        self.add_operation(copied_operation)
    else:
        raise ValueError(f&#34;Operation {source_name} not found.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, name=None, selection:Optional[List[str]]=None) >pizza.dscript.dscript</span>
</code></dt>
<dd>
<div class="desc"><p>Generates DSCRIPT counters for specified groups with LAMMPS variable definitions and print commands.</p>
<p>The method retrieves the list of group names using <code>self.list()</code>. If <code>selection</code> is provided, it
filters the groups to include only those specified. It then creates a variable for each selected
group that counts the number of atoms in that group and generates corresponding print commands.
The commands are encapsulated within a <code><a title="group.dscript" href="#group.dscript">dscript</a></code> object for execution.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>selection (list of str, optional):
    - List of group names to be numbered.
    - If &lt;code&gt;None&lt;/code&gt;, all groups in the collection are numbered.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dscript: A &lt;code&gt;&lt;a title="group.dscript" href="#group.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; object containing the variable definitions and print commands, formatted as follows:
         ```
         variable n_lower equal "count(lower)"
         variable n_middle equal "count(middle)"
         variable n_upper equal "count(upper)"

         print "Number of atoms in lower: ${n_lower}"
         print "Number of atoms in middle: ${n_middle}"
         print "Number of atoms in upper: ${n_upper}"
         ```
         The &lt;code&gt;variables&lt;/code&gt; attribute holds the variable definitions, and the &lt;code&gt;printvariables&lt;/code&gt; attribute
         holds the print commands, each separated by a newline.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError:
    - If any group specified in &lt;code&gt;selection&lt;/code&gt; does not exist in the collection.
    - If &lt;code&gt;selection&lt;/code&gt; contains duplicate group names.
TypeError:
    - If &lt;code&gt;selection&lt;/code&gt; is not a list of strings.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>```python
# Create groupobject instances
g1 = groupobject(beadtype=1,group = 'lower')
g2 = groupobject(beadtype=2,group = 'middle')
g3 = groupobject(beadtype=3,group = 'upper')

# Initialize a group with the groupobjects
G = group(name="1+2+3",collection=(g1,g2,g3)) or collection=g1+g2+g3

# add other groups
G.evaluate("all", G.lower + G.middle + G.upper)
G.evaluate("external", G.all - G.middle)

# Generate number commands for all groups
N = G.count(selection=["all","lower","middle","lower"])
print(N.do())
```

**Output:**
```
variable n_all equal "count(all)"
variable n_lower equal "count(lower)"
variable n_middle equal "count(middle)"
variable n_upper equal "count(upper)"
print "Number of atoms in all: ${n_all}"
print "Number of atoms in lower: ${n_lower}"
print "Number of atoms in middle: ${n_middle}"
print "Number of atoms in upper: ${n_upper}"
```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self,name=None, selection: Optional[List[str]] = None) -&gt; &#39;dscript&#39;:
    &#34;&#34;&#34;
    Generates DSCRIPT counters for specified groups with LAMMPS variable definitions and print commands.

    The method retrieves the list of group names using `self.list()`. If `selection` is provided, it
    filters the groups to include only those specified. It then creates a variable for each selected
    group that counts the number of atoms in that group and generates corresponding print commands.
    The commands are encapsulated within a `dscript` object for execution.

    ### Parameters:
        selection (list of str, optional):
            - List of group names to be numbered.
            - If `None`, all groups in the collection are numbered.

    ### Returns:
        dscript: A `dscript` object containing the variable definitions and print commands, formatted as follows:
                 ```
                 variable n_lower equal &#34;count(lower)&#34;
                 variable n_middle equal &#34;count(middle)&#34;
                 variable n_upper equal &#34;count(upper)&#34;

                 print &#34;Number of atoms in lower: ${n_lower}&#34;
                 print &#34;Number of atoms in middle: ${n_middle}&#34;
                 print &#34;Number of atoms in upper: ${n_upper}&#34;
                 ```
                 The `variables` attribute holds the variable definitions, and the `printvariables` attribute
                 holds the print commands, each separated by a newline.

    ### Raises:
        ValueError:
            - If any group specified in `selection` does not exist in the collection.
            - If `selection` contains duplicate group names.
        TypeError:
            - If `selection` is not a list of strings.

    ### Example:
        ```python
        # Create groupobject instances
        g1 = groupobject(beadtype=1,group = &#39;lower&#39;)
        g2 = groupobject(beadtype=2,group = &#39;middle&#39;)
        g3 = groupobject(beadtype=3,group = &#39;upper&#39;)

        # Initialize a group with the groupobjects
        G = group(name=&#34;1+2+3&#34;,collection=(g1,g2,g3)) or collection=g1+g2+g3

        # add other groups
        G.evaluate(&#34;all&#34;, G.lower + G.middle + G.upper)
        G.evaluate(&#34;external&#34;, G.all - G.middle)

        # Generate number commands for all groups
        N = G.count(selection=[&#34;all&#34;,&#34;lower&#34;,&#34;middle&#34;,&#34;lower&#34;])
        print(N.do())
        ```

        **Output:**
        ```
        variable n_all equal &#34;count(all)&#34;
        variable n_lower equal &#34;count(lower)&#34;
        variable n_middle equal &#34;count(middle)&#34;
        variable n_upper equal &#34;count(upper)&#34;
        print &#34;Number of atoms in all: ${n_all}&#34;
        print &#34;Number of atoms in lower: ${n_lower}&#34;
        print &#34;Number of atoms in middle: ${n_middle}&#34;
        print &#34;Number of atoms in upper: ${n_upper}&#34;
        ```
    &#34;&#34;&#34;
    # Retrieve the list of all group names
    all_group_names = self.list()

    # If selection is provided, validate it
    if selection is not None:
        if not isinstance(selection, (list, tuple)):
            raise TypeError(&#34;Parameter &#39;selection&#39; must be a list of group names.&#34;)
        if not all(isinstance(gitem, str) for gitem in selection):
            raise TypeError(&#34;All items in &#39;selection&#39; must be strings representing group names.&#34;)
        if len(selection) != len(set(selection)):
            raise ValueError(&#34;Duplicate group names found in &#39;selection&#39;. Each group should be unique.&#34;)
        # Check that all selected groups exist
        missing_groups = set(selection) - set(all_group_names)
        if missing_groups:
            raise ValueError(f&#34;The following groups are not present in the collection: {&#39;, &#39;.join(missing_groups)}&#34;)
        # Use the selected groups
        target_groups = selection
    else:
        # If no selection, target all groups
        target_groups = all_group_names

    # Initialize lists to hold variable definitions and print commands
    variable_definitions = []
    print_commands = []
    for gitem in target_groups:
        # Validate group name
        if not gitem:
            raise ValueError(&#34;Group names must be non-empty strings.&#34;)
        # Create a valid variable name by replacing any non-alphanumeric characters with underscores
        variable_name = f&#34;n_{gitem}&#34;.replace(&#34; &#34;, &#34;_&#34;).replace(&#34;-&#34;, &#34;_&#34;)
        # Define the variable to count the number of atoms in the group
        variable_definitions.append(f&#39;variable {variable_name} equal &#34;count({gitem})&#34;&#39;)
        # Define the corresponding print command
        print_commands.append(f&#39;print &#34;Number of atoms in {gitem}: ${{{variable_name}}}&#34;&#39;)
    # Create a dscript object with the generated commands
    idD = f&#34;&lt;dscript:group:{self._name}:count&gt;&#34;
    D = dscript(
        name=idD if name is None else name,
        description=f&#34;{idD} for group counts&#34;
    )
    D.variables = &#34;\n&#34;.join(variable_definitions)
    D.printvariables = &#34;\n&#34;.join(print_commands)
    D.set_all_variables()
    return D</code></pre>
</details>
</dd>
<dt id="group.group.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>self, group_name)</span>
</code></dt>
<dd>
<div class="desc"><p>create group
G.create(group_name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create(self, group_name):
    &#34;&#34;&#34;
        create group
        G.create(group_name)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group_name} clear&#34;
    criteria = {&#34;clear&#34;: True}
    op = Operation(&#34;create&#34;, [], name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.create_groups"><code class="name flex">
<span>def <span class="ident">create_groups</span></span>(<span>self, *group_names)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_groups(self, *group_names):
    for group_name in group_names:
        if not isinstance(group_name, str):
            raise TypeError(f&#34;Group name must be a string, got {type(group_name)}&#34;)
        self.create(group_name)</code></pre>
</details>
</dd>
<dt id="group.group.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes one or more stored operations based on their names.</p>
<h2 id="parameters">Parameters:</h2>
<p>name : str, list, or tuple
The name(s) of the operation(s) to delete. If a list or tuple is provided,
all specified operations will be deleted.</p>
<h2 id="usage">Usage:</h2>
<p>G.delete('operation_name')
G.delete(['operation1', 'operation2'])
G.delete(('operation1', 'operation2'))</p>
<h2 id="raises">Raises:</h2>
<p>ValueError
If any of the specified operations are not found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, name):
    &#34;&#34;&#34;
    Deletes one or more stored operations based on their names.

    Parameters:
    -----------
    name : str, list, or tuple
        The name(s) of the operation(s) to delete. If a list or tuple is provided,
        all specified operations will be deleted.

    Usage:
    ------
    G.delete(&#39;operation_name&#39;)
    G.delete([&#39;operation1&#39;, &#39;operation2&#39;])
    G.delete((&#39;operation1&#39;, &#39;operation2&#39;))

    Raises:
    -------
    ValueError
        If any of the specified operations are not found.
    &#34;&#34;&#34;
    # Handle a single string, list, or tuple
    if isinstance(name, (list, tuple)):
        not_found = []
        for n in name:
            idx = self.find(n)
            if idx is not None:
                del self._operations[idx]
            else:
                not_found.append(n)
        # If any names were not found, raise an exception
        if not_found:
            raise ValueError(f&#34;Operation(s) {&#39;, &#39;.join(not_found)} not found.&#34;)
    elif isinstance(name, str):
        idx = self.find(name)
        if idx is not None:
            del self._operations[idx]
        else:
            raise ValueError(f&#34;Operation {name} not found.&#34;)
    else:
        raise TypeError(&#34;The &#39;name&#39; parameter must be a string, list, or tuple.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.disp"><code class="name flex">
<span>def <span class="ident">disp</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>display the content of an operation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disp(self, name):
    &#34;&#34;&#34; display the content of an operation &#34;&#34;&#34;
    idx = self.find(name)
    if idx is not None:
        return self._operations[idx].__repr__()
    else:
        return &#34;Operation not found&#34;</code></pre>
</details>
</dd>
<dt id="group.group.dscript"><code class="name flex">
<span>def <span class="ident">dscript</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a dscript object containing the group's LAMMPS commands.</p>
<p>Parameters:
- name (str): Optional name for the script object.
- printflag (bool, default=False): print on the current console if True
- verbose (bool, default=True): keep comments if True</p>
<p>Returns:
- dscript: A dscript object containing the group's code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dscript(self, name=None, printflag=None, verbose=None, verbosity=None):
    &#34;&#34;&#34;
    Generates a dscript object containing the group&#39;s LAMMPS commands.

    Parameters:
    - name (str): Optional name for the script object.
    - printflag (bool, default=False): print on the current console if True
    - verbose (bool, default=True): keep comments if True

    Returns:
    - dscript: A dscript object containing the group&#39;s code.
    &#34;&#34;&#34;
    if name is None:
        name = self._name
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    # Create a new dscript object
    dscript_obj = dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity)
    # Add each line of the group&#39;s code to the script object
    for idx, op in enumerate(self._operations):
        # Use the index as the key for the script line
       dscript_obj[idx] = op.code
    return dscript_obj</code></pre>
</details>
</dd>
<dt id="group.group.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, group_name, group_op)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the operation and stores the result in a new group.
Expressions could combine +, - and * like o1+o2+o3-o4+o5+o6</p>
<h2 id="parameters">Parameters:</h2>
<p>groupname : str
The name of the group that will store the result.
group_op : Operation
The operation to evaluate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, group_name, group_op):
    &#34;&#34;&#34;
    Evaluates the operation and stores the result in a new group.
    Expressions could combine +, - and * like o1+o2+o3-o4+o5+o6

    Parameters:
    -----------
    groupname : str
        The name of the group that will store the result.
    group_op : Operation
        The operation to evaluate.
    &#34;&#34;&#34;
    if not isinstance(group_op, Operation):
        raise TypeError(&#34;Expected an instance of Operation.&#34;)

    if group_name in self.list():
        raise ValueError(f&#34;The operation &#39;{group_name}&#39; already exists.&#34;)

    # If the operation is already finalized, no need to evaluate
    if group_op.isfinalized():
        if group_op.name != group_name:
            # If names differ, create a copy with the new name
            self.copy(group_op.name, group_name)
        return

    # Recursively evaluate operands
    operand_names = []
    for op in group_op.operands:
        if isinstance(op, Operation):
            if op.isfinalized():
                # Use existing finalized operation name
                operand_names.append(op.name)
            else:
                # Generate a unique name if the operation doesn&#39;t have one
                if not op.name:
                    op.name = op.generate_hashname()
                # Recursively evaluate the operand operation
                self.evaluate(op.name, op)
                operand_names.append(op.name)
        else:
            operand_names.append(str(op))

    # Call the appropriate method based on the operator
    if group_op.operator == &#39;+&#39;:
        self.union(group_name, *operand_names)
        group_op.operator = &#39;union&#39;
    elif group_op.operator == &#39;-&#39;:
        self.subtract(group_name, *operand_names)
        group_op.operator = &#39;subtract&#39;
    elif group_op.operator == &#39;*&#39;:
        self.intersect(group_name, *operand_names)
        group_op.operator = &#39;intersect&#39;
    else:
        raise ValueError(f&#34;Unknown operator: {group_op.operator}&#34;)

    # Update the operation
    group_op.name = group_name
    # Get the last added operation
    finalized_op = self._operations[-1]
    group_op.code = finalized_op.code
    group_op.operands = operand_names

    # Add the operation to the group&#39;s _operations if not already added
    if group_op.name not in self.list():
        self._operations.append(group_op)</code></pre>
</details>
</dd>
<dt id="group.group.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the index of an operation based on its name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, name):
    &#34;&#34;&#34;Returns the index of an operation based on its name.&#34;&#34;&#34;
    if &#39;_operations&#39; in self.__dict__:
        for i, op in enumerate(self._operations):
            if op.name == name:
                return i
    return None</code></pre>
</details>
</dd>
<dt id="group.group.format_cell_content"><code class="name flex">
<span>def <span class="ident">format_cell_content</span></span>(<span>self, content, max_width)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_cell_content(self, content, max_width):
    content = str(content) if content is not None else &#39;&#39;
    if len(content) &gt; max_width:
        start = content[: (max_width - 5) // 2]
        end = content[-((max_width - 5) // 2):]
        content = f&#34;{start} ... {end}&#34;
    return content</code></pre>
</details>
</dd>
<dt id="group.group.generate_group_definitions_from_collection"><code class="name flex">
<span>def <span class="ident">generate_group_definitions_from_collection</span></span>(<span>self, collection)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates group definitions based on the collection of groupobject instances.</p>
<p>This method populates the groups based on beadtypes and associated group names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_group_definitions_from_collection(self,collection):
    &#34;&#34;&#34;
    Generates group definitions based on the collection of groupobject instances.

    This method populates the groups based on beadtypes and associated group names.
    &#34;&#34;&#34;
    group_defs = {}
    for obj in collection:
        for group_name in obj.group:
            if group_name not in group_defs:
                group_defs[group_name] = {&#39;type&#39;: []}
            if obj.beadtype not in group_defs[group_name][&#39;type&#39;]:
                group_defs[group_name][&#39;type&#39;].append(obj.beadtype)
    # Now, add these group definitions
    self.add_group_criteria(group_defs)</code></pre>
</details>
</dd>
<dt id="group.group.get_by_name"><code class="name flex">
<span>def <span class="ident">get_by_name</span></span>(<span>self, operation_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the operation matching "operation_name"
Usage: group.get_by_name("operation_name")
To be used by Operation, not by end-user, which should prefer getattr()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_name(self,operation_name):
    &#34;&#34;&#34;
        Returns the operation matching &#34;operation_name&#34;
        Usage: group.get_by_name(&#34;operation_name&#34;)
        To be used by Operation, not by end-user, which should prefer getattr()
    &#34;&#34;&#34;
    for op in self._operations:
        if op.name == operation_name:
            return op
    raise AttributeError(f&#34;Operation with name &#39;{operation_name}&#39; not found.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.get_group_criteria"><code class="name flex">
<span>def <span class="ident">get_group_criteria</span></span>(<span>self, group_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the criteria that define a group. Handles group_name as a string or number.</p>
<p>Parameters:
- group_name: str or int, the name or number of the group.</p>
<p>Returns:
- dict or str: The criteria used to define the group, or a message if defined by multiple criteria.</p>
<p>Raises:
- ValueError: If the group does not exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_criteria(self, group_name):
    &#34;&#34;&#34;
    Retrieve the criteria that define a group. Handles group_name as a string or number.

    Parameters:
    - group_name: str or int, the name or number of the group.

    Returns:
    - dict or str: The criteria used to define the group, or a message if defined by multiple criteria.

    Raises:
    - ValueError: If the group does not exist.
    &#34;&#34;&#34;
    # Check if group_name exists in _operations
    if group_name not in self._operations:
        raise ValueError(f&#34;Group &#39;{group_name}&#39; does not exist.&#34;)

    # Retrieve all operations related to the group directly from _operations
    operations = self._operations[group_name]

    if not operations:
        raise ValueError(f&#34;No operations found for group &#39;{group_name}&#39;.&#34;)

    criteria = {}
    for op in operations:
        if op.criteria:
            criteria.update(op.criteria)

    # If multiple criteria, return a message
    if len(criteria) &gt; 1:
        return f&#34;Group &#39;{group_name}&#39; is defined by multiple criteria: {criteria}&#34;

    return criteria</code></pre>
</details>
</dd>
<dt id="group.group.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>self, group_name, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>Intersect group1, group2, group3 and store the result in group_name.
Example usage:
group.intersect(group_name, group1, group2, group3,&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect(self,group_name, *groups):
    &#34;&#34;&#34;
    Intersect group1, group2, group3 and store the result in group_name.
    Example usage:
    group.intersect(group_name, group1, group2, group3,...)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group_name} intersect {span(groups)}&#34;
    criteria = {&#34;intersect&#34;: groups}
    op = Operation(&#34;intersect&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the list of all operations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34; return the list of all operations &#34;&#34;&#34;
    return [op.name for op in self._operations]</code></pre>
</details>
</dd>
<dt id="group.group.operation_exists"><code class="name flex">
<span>def <span class="ident">operation_exists</span></span>(<span>self, operation_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns true if "operation_name" exists
To be used by Operation, not by end-user, which should prefer find()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operation_exists(self,operation_name):
    &#34;&#34;&#34;
        Returns true if &#34;operation_name&#34; exists
        To be used by Operation, not by end-user, which should prefer find()
    &#34;&#34;&#34;
    return any(op.name == operation_name for op in self._operations)</code></pre>
</details>
</dd>
<dt id="group.group.pipescript"><code class="name flex">
<span>def <span class="ident">pipescript</span></span>(<span>self, printflag=None, verbose=None, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a pipescript object containing the group's LAMMPS commands.</p>
<p>Parameters:
- printflag (bool, default=False): print on the current console if True
- verbose (bool, default=True): keep comments if True</p>
<p>Returns:
- pipescript: A pipescript object containing the group's code lines as individual scripts in the pipeline.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipescript(self, printflag=None, verbose=None, verbosity=None):
    &#34;&#34;&#34;
    Generates a pipescript object containing the group&#39;s LAMMPS commands.

    Parameters:
    - printflag (bool, default=False): print on the current console if True
    - verbose (bool, default=True): keep comments if True

    Returns:
    - pipescript: A pipescript object containing the group&#39;s code lines as individual scripts in the pipeline.
    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    # Create a list to hold script objects
    script_list = []

    # For each operation, create a script object and add it to the list
    for op in self._operations:
        # Create a dscript object with the code line
        dscript_obj = dscript(printflag=printflag, verbose=verbose, verbosity=verbosity)
        dscript_obj[&#34;dummy&#34;] = op.code

        # Convert the dscript to a script object
        script_obj = dscript_obj.script(printflag=printflag, verbose=verbose, verbosity=verbosity)

        # Add the script object to the list
        script_list.append(script_obj)

    # Use the static method &#39;join&#39; to create a pipescript from the list
    if script_list:
        pipe_obj = pipescript.join(script_list)
    else:
        pipe_obj = pipescript()

    return pipe_obj</code></pre>
</details>
</dd>
<dt id="group.group.reindex"><code class="name flex">
<span>def <span class="ident">reindex</span></span>(<span>self, name, new_idx)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the index of a stored operation.</p>
<p>Parameters:
name: str
Name of the operation to reindex
new_idx: int
New index for the operation</p>
<p>Usage:
G.reindex('operation_name', 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reindex(self, name, new_idx):
    &#34;&#34;&#34;
    Change the index of a stored operation.

    Parameters:
    name: str
        Name of the operation to reindex
    new_idx: int
        New index for the operation

    Usage:
    G.reindex(&#39;operation_name&#39;, 2)
    &#34;&#34;&#34;
    idx = self.find(name)
    if idx is not None and 0 &lt;= new_idx &lt; len(self._operations):
        op = self._operations.pop(idx)
        self._operations.insert(new_idx, op)
    else:
        raise ValueError(f&#34;Operation &#39;{name}&#39; not found or new index {new_idx} out of range.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, old_name, new_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename a stored operation.</p>
<p>Parameters:
old_name: str
Current name of the operation
new_name: str
New name to assign to the operation</p>
<p>Usage:
G.rename('old_operation', 'new_operation')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self, old_name, new_name):
    &#34;&#34;&#34;
    Rename a stored operation.

    Parameters:
    old_name: str
        Current name of the operation
    new_name: str
        New name to assign to the operation

    Usage:
    G.rename(&#39;old_operation&#39;, &#39;new_operation&#39;)
    &#34;&#34;&#34;
    idx = self.find(old_name)
    if idx is not None:
        if new_name == old_name:
            raise ValueError(&#34;The new name should be different from the previous one.&#34;)
        elif new_name in self.list():
            raise ValueError(&#34;Operation name must be unique.&#34;)
        self._operations[idx].name = new_name
    else:
        raise ValueError(f&#34;Operation &#39;{old_name}&#39; not found.&#34;)</code></pre>
</details>
</dd>
<dt id="group.group.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a script object containing the group's LAMMPS commands.</p>
<p>Parameters:
- name (str): Optional name for the script object.
- printflag (bool, default=False): print on the current console if True
- verbose (bool, default=True): keep comments if True</p>
<p>Returns:
- script: A script object containing the group's code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self, name=None, printflag=None, verbose=None, verbosity=None):
    &#34;&#34;&#34;
    Generates a script object containing the group&#39;s LAMMPS commands.

    Parameters:
    - name (str): Optional name for the script object.
    - printflag (bool, default=False): print on the current console if True
    - verbose (bool, default=True): keep comments if True

    Returns:
    - script: A script object containing the group&#39;s code.
    &#34;&#34;&#34;
    if name is None:
        name = self._name
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    script_obj = self.dscript(name=name,printflag=printflag, verbose=verbose, verbosity=verbosity).script(printflag=printflag, verbose=verbose, verbosity=verbosity)
    return script_obj</code></pre>
</details>
</dd>
<dt id="group.group.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, group_name, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>Subtract group2, group3 from group1 and store the result in group_name.
Example usage:
group.subtract(group_name, group1, group2, group3,&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self,group_name, *groups):
    &#34;&#34;&#34;
    Subtract group2, group3 from group1 and store the result in group_name.
    Example usage:
    group.subtract(group_name, group1, group2, group3,...)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group_name} subtract {span(groups)}&#34;
    criteria = {&#34;subtract&#34;: groups}
    op = Operation(&#34;subtract&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, group_name, *groups)</span>
</code></dt>
<dd>
<div class="desc"><p>Union group1, group2, group3 and store the result in group_name.
Example usage:
group.union(group_name, group1, group2, group3,&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def union(self,group_name, *groups):
    &#34;&#34;&#34;
    Union group1, group2, group3 and store the result in group_name.
    Example usage:
    group.union(group_name, group1, group2, group3,...)
    &#34;&#34;&#34;
    lammps_code = f&#34;group {group_name} union {span(groups)}&#34;
    criteria = {&#34;union&#34;: groups}
    op = Operation(&#34;union&#34;, groups, name=group_name, code=lammps_code, criteria=criteria)
    self.add_operation(op)</code></pre>
</details>
</dd>
<dt id="group.group.variable"><code class="name flex">
<span>def <span class="ident">variable</span></span>(<span>self, variable_name, expression, style='atom')</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns an expression to a LAMMPS variable.</p>
<p>Parameters:
- variable_name (str): The name of the variable to be assigned.
- expression (str): The expression to assign to the variable.
- style (str): The type of variable (default is "atom").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def variable(self, variable_name, expression, style=&#34;atom&#34;):
    &#34;&#34;&#34;
    Assigns an expression to a LAMMPS variable.

    Parameters:
    - variable_name (str): The name of the variable to be assigned.
    - expression (str): The expression to assign to the variable.
    - style (str): The type of variable (default is &#34;atom&#34;).
    &#34;&#34;&#34;
    if not isinstance(variable_name, str):
        raise TypeError(f&#34;Variable name must be a string, got {type(variable_name)}&#34;)
    if not isinstance(expression, str):
        raise TypeError(f&#34;Expression must be a string, got {type(expression)}&#34;)
    if not isinstance(style, str):
        raise TypeError(f&#34;Style must be a string, got {type(style)}&#34;)

    lammps_code = f&#34;variable {variable_name} {style} \&#34;{expression}\&#34;&#34;
    op = Operation(&#34;variable&#34;, [variable_name, expression], code=lammps_code)
    self.add_operation(op)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="group.groupcollection"><code class="flex name class">
<span>class <span class="ident">groupcollection</span></span>
<span>(</span><span>collection:List[ForwardRef('<a title="group.groupobject" href="#group.groupobject">groupobject</a>')], name:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a collection of <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> instances, typically formed by combining them.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>collection (List[groupobject]): The list of &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instances in the collection.
name (str): The name of the collection, generated automatically if not provided.
</code></pre>
<h3 id="examples">Examples:</h3>
<pre><code>&gt;&gt;&gt; o1 = groupobject(beadtype=1, group=["all", "A"], mass=1.0)
&gt;&gt;&gt; o2 = groupobject(beadtype=2, group=["all", "B", "C"])
&gt;&gt;&gt; G = groupcollection([o1, o2])
&gt;&gt;&gt; print(G.name)
beadtype=1,2
</code></pre>
<p>Initializes a new instance of the groupcollection class.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>collection (List[groupobject]): A list of &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instances to include in the collection.
name (str, optional): The name of the collection. If not provided, a default name is generated.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If the &lt;code&gt;collection&lt;/code&gt; is empty or contains invalid elements.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class groupcollection:
    &#34;&#34;&#34;
    Represents a collection of `groupobject` instances, typically formed by combining them.

    ### Attributes:
        collection (List[groupobject]): The list of `groupobject` instances in the collection.
        name (str): The name of the collection, generated automatically if not provided.

    ### Examples:
        &gt;&gt;&gt; o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        &gt;&gt;&gt; o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        &gt;&gt;&gt; G = groupcollection([o1, o2])
        &gt;&gt;&gt; print(G.name)
        beadtype=1,2
    &#34;&#34;&#34;
    def __init__(self, collection: List[&#39;groupobject&#39;], name: Optional[str] = None):
        &#34;&#34;&#34;
        Initializes a new instance of the groupcollection class.

        ### Parameters:
            collection (List[groupobject]): A list of `groupobject` instances to include in the collection.
            name (str, optional): The name of the collection. If not provided, a default name is generated.

        ### Raises:
            ValueError: If the `collection` is empty or contains invalid elements.
        &#34;&#34;&#34;
        if not isinstance(collection, list) or not all(isinstance(obj, groupobject) for obj in collection):
            raise ValueError(&#34;`collection` must be a list of `groupobject` instances.&#34;)
        if not collection:
            raise ValueError(&#34;`collection` cannot be empty.&#34;)

        self.collection = collection

        # Automatically assign a name if not provided
        if name is None:
            # Extract names or &#34;beadtype=X&#34; patterns
            beadtype_names = [
                obj.name if obj.name.startswith(&#34;beadtype=&#34;) else None for obj in collection
            ]

            # If all objects have beadtype names, use &#34;beadtype=1,2,3&#34; pattern
            if all(beadtype_names):
                beadtypes = [obj.beadtype for obj in collection]
                self.name = &#34;beadtype={}&#34;.format(&#34;,&#34;.join(map(str, sorted(beadtypes))))
            else:
                # Fall back to concatenating names
                self.name = &#34;,&#34;.join(obj.name for obj in collection)
        else:
            self.name = name


    def __add__(self, other: Union[groupobject, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds a `groupobject` or another `groupcollection` to this collection.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new `groupcollection` instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection(self.collection + [other])
        elif isinstance(other, groupcollection):
            return groupcollection(self.collection + other.collection)
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)

    def __iadd__(self, other: Union[groupobject, List[groupobject], Tuple[groupobject, ...]]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        In-place addition of a `groupobject` or a list/tuple of `groupobject` instances.

        ### Parameters:
            other (groupobject or list/tuple of groupobject): The object(s) to add.

        ### Returns:
            groupcollection: The updated `groupcollection` instance.

        ### Raises:
            TypeError: If `other` is not a `groupobject` or a list/tuple of `groupobject` instances.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            self.collection.append(other)
        elif isinstance(other, (list, tuple)):
            for obj in other:
                if not isinstance(obj, groupobject):
                    raise TypeError(&#34;All items to add must be `groupobject` instances.&#34;)
            self.collection.extend(other)
        else:
            raise TypeError(&#34;In-place addition only supported with `groupobject` instances or lists/tuples of `groupobject` instances.&#34;)
        return self

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a neatly formatted string representation of the groupcollection.

        The representation includes a table of `beadtype`, `group` (max width 50 characters), and `mass`.
        It also provides a summary of the total number of `groupobject` instances.

        ### Returns:
            str: Formatted string representation of the collection.
        &#34;&#34;&#34;
        headers = [&#34;Beadtype&#34;, &#39;Name&#39;, &#34;Group&#34;, &#34;Mass&#34;]
        col_max_widths = [10, 20, 30, 10]
        # Prepare rows
        rows = []
        for obj in self.collection:
            beadtype_str = str(obj.beadtype)
            group_str = &#34;, &#34;.join(obj.group)
            mass_str = f&#34;{obj.mass}&#34; if obj.mass is not None else &#34;None&#34;
            rows.append([beadtype_str, obj.name, group_str, mass_str])
        # Generate the table
        table = format_table(headers, rows, col_max_widths)
        # Add summary
        summary = f&#34;Total groupobjects: {len(self)}&#34;
        return f&#34;{table}\n{summary}&#34;

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the same representation as `__repr__`.

        ### Returns:
            str: Formatted string representation of the collection.
        &#34;&#34;&#34;
        return f&#34;groupcollection including {len(self)} groupobjects&#34;

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of `groupobject` instances in the collection.

        ### Returns:
            int: Number of objects in the collection.
        &#34;&#34;&#34;
        return len(self.collection)

    def __getitem__(self, index: int) -&gt; groupobject:
        &#34;&#34;&#34;
        Retrieves a `groupobject` by its index.

        ### Parameters:
            index (int): The index of the `groupobject` to retrieve.

        ### Returns:
            groupobject: The `groupobject` at the specified index.

        ### Raises:
            IndexError: If the index is out of range.
        &#34;&#34;&#34;
        return self.collection[index]

    def __iter__(self):
        &#34;&#34;&#34;
        Returns an iterator over the `groupobject` instances in the collection.

        ### Returns:
            Iterator[groupobject]: An iterator over the collection.
        &#34;&#34;&#34;
        return iter(self.collection)

    def append(self, obj: groupobject):
        &#34;&#34;&#34;
        Appends a `groupobject` to the collection.

        ### Parameters:
            obj (groupobject): The object to append.

        ### Raises:
            TypeError: If `obj` is not a `groupobject` instance.
        &#34;&#34;&#34;
        if not isinstance(obj, groupobject):
            raise TypeError(&#34;Only `groupobject` instances can be appended.&#34;)
        self.collection.append(obj)

    def extend(self, objs: Union[List[groupobject], Tuple[groupobject, ...]]):
        &#34;&#34;&#34;
        Extends the collection with a list or tuple of `groupobject` instances.

        ### Parameters:
            objs (list or tuple of groupobject): The objects to extend the collection with.

        ### Raises:
            TypeError: If `objs` is not a list or tuple.
            TypeError: If any item in `objs` is not a `groupobject` instance.
        &#34;&#34;&#34;
        if not isinstance(objs, (list, tuple)):
            raise TypeError(&#34;`objs` must be a list or tuple of `groupobject` instances.&#34;)
        for obj in objs:
            if not isinstance(obj, groupobject):
                raise TypeError(&#34;All items to extend must be `groupobject` instances.&#34;)
        self.collection.extend(objs)

    def remove(self, obj: groupobject):
        &#34;&#34;&#34;
        Removes a `groupobject` from the collection.

        ### Parameters:
            obj (groupobject): The object to remove.

        ### Raises:
            ValueError: If `obj` is not found in the collection.
        &#34;&#34;&#34;
        self.collection.remove(obj)

    def clear(self):
        &#34;&#34;&#34;
        Clears all `groupobject` instances from the collection.
        &#34;&#34;&#34;
        self.collection.clear()


    def mass(self, name: Optional[str] = None, default_mass: Optional[Union[str, int, float]] = &#34;${mass}&#34;, verbose: Optional[bool] = True) -&gt; &#39;dscript&#39;:
        &#34;&#34;&#34;
        Generates LAMMPS mass commands for each unique beadtype in the collection.

        The method iterates through all `groupobject` instances in the collection,
        collects unique beadtypes, and ensures that each beadtype has a consistent mass.
        If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

        ### Parameters:
            name (str, optional): The name to assign to the resulting `dscript` object. Defaults to a generated name.
            default_mass (str, optional): The default mass value to assign when a beadtype&#39;s mass is `None`.
                                          Defaults to `&#34;${mass}&#34;`.
            verbose (bool, optional): If `True`, includes a comment header in the output. Defaults to `True`.

        ### Returns:
            dscript: A `dscript` object containing the mass commands for each beadtype, formatted as follows:
                     ```
                     mass 1 1.0
                     mass 2 1.0
                     mass 3 2.5
                     ```
                     The `collection` attribute of the `dscript` object holds the formatted mass commands as a single string.

        ### Raises:
            ValueError: If a beadtype has inconsistent mass values across different `groupobject` instances.

        ### Example:
            ```python
            # Create groupobject instances
            o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
            o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
            o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)

            # Initialize a groupcollection with the groupobjects
            G = groupcollection([o1, o2, o3])

            # Generate mass commands
            M = G.mass()
            print(M.do())
            ```
            **Output:**
            ```
            mass 1 1.0
            mass 2 ${mass}
            mass 3 2.5
            ```
        &#34;&#34;&#34;
        beadtype_mass = {}
        for obj in self.collection:
            bt = obj.beadtype
            mass = obj.mass if obj.mass is not None else &#34;${mass}&#34;
            if bt in beadtype_mass:
                if beadtype_mass[bt] != mass:
                    raise ValueError(
                        f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                    )
            else:
                beadtype_mass[bt] = mass
        # Sort beadtypes for consistent ordering
        sorted_beadtypes = sorted(beadtype_mass.keys())
        # Generate mass commands
        lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
        # return a dscript object
        idD = f&#34;&lt;dscript:group:{self.name}:mass&gt;&#34;
        description = f&#34;{idD} definitions for {len(self)} beads&#34;
        if verbose:
            lines.insert(0, &#34;# &#34;+description)
        D = dscript(name=idD if name is None else name, description=f&#34;{idD} with {len(self)} beads&#34;)
        D.collection = &#34;\n&#34;.join(lines)
        D.DEFINITIONS.mass = default_mass
        return D</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="group.groupcollection.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, obj:<a title="group.groupobject" href="#group.groupobject">groupobject</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> to the collection.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>obj (groupobject): The object to append.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>TypeError: If &lt;code&gt;obj&lt;/code&gt; is not a &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instance.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, obj: groupobject):
    &#34;&#34;&#34;
    Appends a `groupobject` to the collection.

    ### Parameters:
        obj (groupobject): The object to append.

    ### Raises:
        TypeError: If `obj` is not a `groupobject` instance.
    &#34;&#34;&#34;
    if not isinstance(obj, groupobject):
        raise TypeError(&#34;Only `groupobject` instances can be appended.&#34;)
    self.collection.append(obj)</code></pre>
</details>
</dd>
<dt id="group.groupcollection.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears all <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> instances from the collection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    &#34;&#34;&#34;
    Clears all `groupobject` instances from the collection.
    &#34;&#34;&#34;
    self.collection.clear()</code></pre>
</details>
</dd>
<dt id="group.groupcollection.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, objs:Union[List[<a title="group.groupobject" href="#group.groupobject">groupobject</a>],Tuple[<a title="group.groupobject" href="#group.groupobject">groupobject</a>,...]])</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the collection with a list or tuple of <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> instances.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>objs (list or tuple of groupobject): The objects to extend the collection with.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>TypeError: If &lt;code&gt;objs&lt;/code&gt; is not a list or tuple.
TypeError: If any item in &lt;code&gt;objs&lt;/code&gt; is not a &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instance.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, objs: Union[List[groupobject], Tuple[groupobject, ...]]):
    &#34;&#34;&#34;
    Extends the collection with a list or tuple of `groupobject` instances.

    ### Parameters:
        objs (list or tuple of groupobject): The objects to extend the collection with.

    ### Raises:
        TypeError: If `objs` is not a list or tuple.
        TypeError: If any item in `objs` is not a `groupobject` instance.
    &#34;&#34;&#34;
    if not isinstance(objs, (list, tuple)):
        raise TypeError(&#34;`objs` must be a list or tuple of `groupobject` instances.&#34;)
    for obj in objs:
        if not isinstance(obj, groupobject):
            raise TypeError(&#34;All items to extend must be `groupobject` instances.&#34;)
    self.collection.extend(objs)</code></pre>
</details>
</dd>
<dt id="group.groupcollection.mass"><code class="name flex">
<span>def <span class="ident">mass</span></span>(<span>self, name:Optional[str]=None, default_mass:Union[str,int,float,NoneType]='${mass}', verbose:Optional[bool]=True) >pizza.dscript.dscript</span>
</code></dt>
<dd>
<div class="desc"><p>Generates LAMMPS mass commands for each unique beadtype in the collection.</p>
<p>The method iterates through all <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> instances in the collection,
collects unique beadtypes, and ensures that each beadtype has a consistent mass.
If a beadtype has <code>mass=None</code>, it assigns a default mass as specified by <code>default_mass</code>.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>name (str, optional): The name to assign to the resulting &lt;code&gt;&lt;a title="group.dscript" href="#group.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; object. Defaults to a generated name.
default_mass (str, optional): The default mass value to assign when a beadtype's mass is &lt;code&gt;None&lt;/code&gt;.
                              Defaults to `"${mass}"`.
verbose (bool, optional): If &lt;code&gt;True&lt;/code&gt;, includes a comment header in the output. Defaults to &lt;code&gt;True&lt;/code&gt;.
</code></pre>
<h3 id="returns">Returns:</h3>
<pre><code>dscript: A &lt;code&gt;&lt;a title="group.dscript" href="#group.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; object containing the mass commands for each beadtype, formatted as follows:
         ```
         mass 1 1.0
         mass 2 1.0
         mass 3 2.5
         ```
         The &lt;code&gt;collection&lt;/code&gt; attribute of the &lt;code&gt;&lt;a title="group.dscript" href="#group.dscript"&gt;dscript&lt;/a&gt;&lt;/code&gt; object holds the formatted mass commands as a single string.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If a beadtype has inconsistent mass values across different &lt;code&gt;&lt;a title="group.groupobject" href="#group.groupobject"&gt;groupobject&lt;/a&gt;&lt;/code&gt; instances.
</code></pre>
<h3 id="example">Example:</h3>
<pre><code>```python
# Create groupobject instances
o1 = groupobject(beadtype=1, group=["all", "A"], mass=1.0)
o2 = groupobject(beadtype=2, group=["all", "B", "C"])
o3 = groupobject(beadtype=3, group="C", mass=2.5)

# Initialize a groupcollection with the groupobjects
G = groupcollection([o1, o2, o3])

# Generate mass commands
M = G.mass()
print(M.do())
```
**Output:**
```
mass 1 1.0
mass 2 ${mass}
mass 3 2.5
```
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass(self, name: Optional[str] = None, default_mass: Optional[Union[str, int, float]] = &#34;${mass}&#34;, verbose: Optional[bool] = True) -&gt; &#39;dscript&#39;:
    &#34;&#34;&#34;
    Generates LAMMPS mass commands for each unique beadtype in the collection.

    The method iterates through all `groupobject` instances in the collection,
    collects unique beadtypes, and ensures that each beadtype has a consistent mass.
    If a beadtype has `mass=None`, it assigns a default mass as specified by `default_mass`.

    ### Parameters:
        name (str, optional): The name to assign to the resulting `dscript` object. Defaults to a generated name.
        default_mass (str, optional): The default mass value to assign when a beadtype&#39;s mass is `None`.
                                      Defaults to `&#34;${mass}&#34;`.
        verbose (bool, optional): If `True`, includes a comment header in the output. Defaults to `True`.

    ### Returns:
        dscript: A `dscript` object containing the mass commands for each beadtype, formatted as follows:
                 ```
                 mass 1 1.0
                 mass 2 1.0
                 mass 3 2.5
                 ```
                 The `collection` attribute of the `dscript` object holds the formatted mass commands as a single string.

    ### Raises:
        ValueError: If a beadtype has inconsistent mass values across different `groupobject` instances.

    ### Example:
        ```python
        # Create groupobject instances
        o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)

        # Initialize a groupcollection with the groupobjects
        G = groupcollection([o1, o2, o3])

        # Generate mass commands
        M = G.mass()
        print(M.do())
        ```
        **Output:**
        ```
        mass 1 1.0
        mass 2 ${mass}
        mass 3 2.5
        ```
    &#34;&#34;&#34;
    beadtype_mass = {}
    for obj in self.collection:
        bt = obj.beadtype
        mass = obj.mass if obj.mass is not None else &#34;${mass}&#34;
        if bt in beadtype_mass:
            if beadtype_mass[bt] != mass:
                raise ValueError(
                    f&#34;Inconsistent masses for beadtype {bt}: {beadtype_mass[bt]} vs {mass}&#34;
                )
        else:
            beadtype_mass[bt] = mass
    # Sort beadtypes for consistent ordering
    sorted_beadtypes = sorted(beadtype_mass.keys())
    # Generate mass commands
    lines = [f&#34;mass {bt} {beadtype_mass[bt]}&#34; for bt in sorted_beadtypes]
    # return a dscript object
    idD = f&#34;&lt;dscript:group:{self.name}:mass&gt;&#34;
    description = f&#34;{idD} definitions for {len(self)} beads&#34;
    if verbose:
        lines.insert(0, &#34;# &#34;+description)
    D = dscript(name=idD if name is None else name, description=f&#34;{idD} with {len(self)} beads&#34;)
    D.collection = &#34;\n&#34;.join(lines)
    D.DEFINITIONS.mass = default_mass
    return D</code></pre>
</details>
</dd>
<dt id="group.groupcollection.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, obj:<a title="group.groupobject" href="#group.groupobject">groupobject</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a <code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code> from the collection.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>obj (groupobject): The object to remove.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>ValueError: If &lt;code&gt;obj&lt;/code&gt; is not found in the collection.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, obj: groupobject):
    &#34;&#34;&#34;
    Removes a `groupobject` from the collection.

    ### Parameters:
        obj (groupobject): The object to remove.

    ### Raises:
        ValueError: If `obj` is not found in the collection.
    &#34;&#34;&#34;
    self.collection.remove(obj)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="group.groupobject"><code class="flex name class">
<span>class <span class="ident">groupobject</span></span>
<span>(</span><span>beadtype:Union[int,float], group:Union[str,List[str],Tuple[str,...]], mass:Union[int,float,NoneType]=None, name:Optional[str]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an object with a bead type, associated groups, and an optional mass.</p>
<h3 id="attributes">Attributes:</h3>
<pre><code>beadtype (int or float): The bead type identifier. Must be an integer or a real scalar.
group (List[str]): List of group names the object belongs to.
mass (Optional[float]): The mass of the bead. Must be a real scalar or None.
name (Optional[str]): Name of the object
</code></pre>
<h3 id="examples">Examples:</h3>
<pre><code>&gt;&gt;&gt; o1 = groupobject(beadtype=1, group=["all", "A"], mass=1.0)
&gt;&gt;&gt; o2 = groupobject(beadtype=2, group=["all", "B", "C"])
&gt;&gt;&gt; o3 = groupobject(beadtype=3, group="C", mass=2.5)
</code></pre>
<p>Initializes a new instance of the groupobject class.</p>
<h3 id="parameters">Parameters:</h3>
<pre><code>beadtype (int or float): The bead type identifier.
group (str, list of str, or tuple of str): Group names the object belongs to.
mass (float or int, optional): The mass of the bead.
</code></pre>
<h3 id="raises">Raises:</h3>
<pre><code>TypeError: If &lt;code&gt;beadtype&lt;/code&gt; is not an int or float.
TypeError: If &lt;code&gt;&lt;a title="group.group" href="#group.group"&gt;group&lt;/a&gt;&lt;/code&gt; is not a str, list of str, or tuple of str.
TypeError: If &lt;code&gt;mass&lt;/code&gt; is not a float, int, or None.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class groupobject:
    &#34;&#34;&#34;
    Represents an object with a bead type, associated groups, and an optional mass.

    ### Attributes:
        beadtype (int or float): The bead type identifier. Must be an integer or a real scalar.
        group (List[str]): List of group names the object belongs to.
        mass (Optional[float]): The mass of the bead. Must be a real scalar or None.
        name (Optional[str]): Name of the object

    ### Examples:
        &gt;&gt;&gt; o1 = groupobject(beadtype=1, group=[&#34;all&#34;, &#34;A&#34;], mass=1.0)
        &gt;&gt;&gt; o2 = groupobject(beadtype=2, group=[&#34;all&#34;, &#34;B&#34;, &#34;C&#34;])
        &gt;&gt;&gt; o3 = groupobject(beadtype=3, group=&#34;C&#34;, mass=2.5)
    &#34;&#34;&#34;

    def __init__(self, beadtype: Union[int, float], group: Union[str, List[str], Tuple[str, ...]], \
                 mass: Optional[Union[int, float]] = None, name: Optional[str]=None, ):
        &#34;&#34;&#34;
        Initializes a new instance of the groupobject class.

        ### Parameters:
            beadtype (int or float): The bead type identifier.
            group (str, list of str, or tuple of str): Group names the object belongs to.
            mass (float or int, optional): The mass of the bead.

        ### Raises:
            TypeError: If `beadtype` is not an int or float.
            TypeError: If `group` is not a str, list of str, or tuple of str.
            TypeError: If `mass` is not a float, int, or None.
        &#34;&#34;&#34;
        # Validate beadtype
        if not isinstance(beadtype, (int, float)):
            raise TypeError(f&#34;&#39;beadtype&#39; must be an integer or float, got {type(beadtype).__name__} instead.&#34;)
        self.beadtype = beadtype
        # Validate group
        if isinstance(group, str):
            self.group = [group]
        elif isinstance(group, (list, tuple)):
            if not all(isinstance(g, str) for g in group):
                raise TypeError(&#34;All elements in &#39;group&#39; must be strings.&#34;)
            self.group = list(group)
        else:
            raise TypeError(f&#34;&#39;group&#39; must be a string, list of strings, or tuple of strings, got {type(group).__name__} instead.&#34;)
        # Validate mass
        if mass is not None and not isinstance(mass, (int, float)):
            raise TypeError(f&#34;&#39;mass&#39; must be a real scalar (int or float) or None, got {type(mass).__name__} instead.&#34;)
        self.mass = mass
        # Validate name
        self.name = f&#34;beadtype={beadtype}&#34; if name is None else name

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a readable string representation of the groupobject.
        &#34;&#34;&#34;
        return f&#34;groupobject | type={self.beadtype} | name={self.group} | mass={self.mass}&#34;

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
        Returns an unambiguous string representation of the groupobject.

        ### Returns:
            str: String representation including beadtype, group, and mass (if not None).
        &#34;&#34;&#34;
        return f&#34;groupobject(beadtype={self.beadtype}, group={span(self.group,&#39;,&#39;,&#39;[&#39;,&#39;]&#39;)}, name={self.name}, mass={self.mass})&#34;


    def __add__(self, other: Union[&#39;groupobject&#39;, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds this groupobject to another groupobject or a groupcollection.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new groupcollection instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection([self, other])
        elif isinstance(other, groupcollection):
            return groupcollection([self] + other.collection)
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)

    def __radd__(self, other: Union[&#39;groupobject&#39;, &#39;groupcollection&#39;]) -&gt; &#39;groupcollection&#39;:
        &#34;&#34;&#34;
        Adds this groupobject to another groupobject or a groupcollection from the right.

        ### Parameters:
            other (groupobject or groupcollection): The object to add.

        ### Returns:
            groupcollection: A new groupcollection instance containing the combined objects.

        ### Raises:
            TypeError: If `other` is neither a `groupobject` nor a `groupcollection`.
        &#34;&#34;&#34;
        if isinstance(other, groupobject):
            return groupcollection([other, self])
        elif isinstance(other, groupcollection):
            return groupcollection(other.collection + [self])
        else:
            raise TypeError(&#34;Addition only supported between `groupobject` or `groupcollection` instances.&#34;)</code></pre>
</details>
</dd>
<dt id="group.pipescript"><code class="flex name class">
<span>class <span class="ident">pipescript</span></span>
<span>(</span><span>s=None, name=None, printflag=False, verbose=True, verbosity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pipescript: A Class for Managing Script Pipelines</p>
<p>The <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> class stores scripts in a pipeline where multiple scripts,
script objects, or script object groups can be combined and executed
sequentially. Scripts in the pipeline are executed using the pipe (<code>|</code>) operator,
allowing for dynamic control over execution order, script concatenation, and
variable management.</p>
<h2 id="key-features">Key Features:</h2>
<ul>
<li><strong>Pipeline Construction</strong>: Create pipelines of scripts, combining multiple
script objects, <code>script</code>, <code>scriptobject</code>, or <code>scriptobjectgroup</code> instances.
The pipe operator (<code>|</code>) is overloaded to concatenate scripts.</li>
<li><strong>Sequential Execution</strong>: Execute all scripts in the pipeline in the order
they were added, with support for reordering, selective execution, and
clearing of individual steps.</li>
<li><strong>User and Definition Spaces</strong>: Manage local and global user-defined variables
(<code>USER</code> space) and static definitions for each script in the pipeline.
Global definitions apply to all scripts in the pipeline, while local variables
apply to specific steps.</li>
<li><strong>Flexible Script Handling</strong>: Indexing, slicing, reordering, and renaming
scripts in the pipeline are supported. Scripts can be accessed, replaced,
and modified like array elements.</li>
</ul>
<h2 id="practical-use-cases">Practical Use Cases:</h2>
<ul>
<li><strong>LAMMPS Script Automation</strong>: Automate the generation of multi-step simulation
scripts for LAMMPS, combining different simulation setups into a single pipeline.</li>
<li><strong>Script Management</strong>: Combine and manage multiple scripts, tracking user
variables and ensuring that execution order can be adjusted easily.</li>
<li><strong>Advanced Script Execution</strong>: Perform partial pipeline execution, reorder
steps, or clear completed steps while maintaining the original pipeline structure.</li>
</ul>
<h2 id="methods">Methods:</h2>
<p><strong>init</strong>(self, s=None):
Initializes a new <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> object, optionally starting with a script
or script-like object (<code>script</code>, <code>scriptobject</code>, <code>scriptobjectgroup</code>).</p>
<p>setUSER(self, idx, key, value):
Set a user-defined variable (<code>USER</code>) for the script at the specified index.</p>
<p>getUSER(self, idx, key):
Get the value of a user-defined variable (<code>USER</code>) for the script at the
specified index.</p>
<p>clear(self, idx=None):
Clear the execution status of scripts in the pipeline, allowing them to
be executed again.</p>
<p>do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Execute the pipeline or a subset of the pipeline, generating a combined
LAMMPS-compatible script.</p>
<p>script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
Generate the final LAMMPS script from the pipeline or a subset of the pipeline.</p>
<p>rename(self, name="", idx=None):
Rename the scripts in the pipeline, assigning new names to specific
indices or all scripts.</p>
<p>write(self, file, printflag=True, verbosity=2, verbose=None):
Write the generated script to a file.</p>
<p>dscript(self, verbose=None, **USER)
Convert the current pipescript into a dscript object</p>
<p>header(self, verbose=True,verbosity=None, style=4):
Generate a formatted header for the pipescript file.</p>
<p>list_values(self, varname, what="all"):
List all occurrences and values of a variable across the pipeline scripts.</p>
<p>list_multiple_values(self, varnames, what="all"):
List all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>plot_value_distribution(self, varname, what="all"):
Plot the distribution of values for a given variable across specified scopes.</p>
<p>generate_report(self, filename, varnames=None, scopes="all"):
Generate a comprehensive report for specified variables and writes it to a file.</p>
<h2 id="static-methods">Static Methods:</h2>
<p>join(liste):
Combine a list of <code>script</code> and <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> objects into a single pipeline.</p>
<h2 id="additional-features">Additional Features:</h2>
<ul>
<li><strong>Indexing and Slicing</strong>: Use array-like indexing (<code>p[0]</code>, <code>p[1:3]</code>) to access
and manipulate scripts in the pipeline.</li>
<li><strong>Deep Copy Support</strong>: The pipeline supports deep copying, preserving the
entire pipeline structure and its scripts.</li>
<li><strong>Verbose and Print Options</strong>: Control verbosity and printing behavior for
generated scripts, allowing for detailed output or minimal script generation.</li>
</ul>
<h2 id="original-content">Original Content:</h2>
<p>The <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> class supports a variety of pipeline operations, including:
- Sequential execution with <code>cmd = p.do()</code>.
- Reordering pipelines with <code>p[[2, 0, 1]]</code>.
- Deleting steps with <code>p[[0, 1]] = []</code>.
- Accessing local and global user space variables via <code>p.USER[idx].var</code> and
<code>p.scripts[idx].USER.var</code>.
- Managing static definitions for each script in the pipeline.
- Example usage:
<code>p = pipescript()
p | i
p = G | c | g | d | b | i | t | d | s | r
p.rename(["G", "c", "g", "d", "b", "i", "t", "d", "s", "r"])
cmd = p.do([0, 1, 4, 7])
sp = p.script([0, 1, 4, 7])</code>
- Scripts in the pipeline are executed sequentially, and definitions propagate
from left to right. The <code>USER</code> space and <code>DEFINITIONS</code> are managed separately
for each script in the pipeline.</p>
<h2 id="overview">Overview</h2>
<pre><code>Pipescript class stores scripts in pipelines
    By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
    p = s0 | s1 | s2 generates a pipe script

    Example of pipeline:
  ------------:----------------------------------------
  [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
  [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
  [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
  [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
  [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
  [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
  [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
  [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
  ------------:----------------------------------------
Out[35]: pipescript containing 11 scripts with 8 executed[*]

note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
     and the direction of propagation (inheritance from left)
     XX: number of definitions in the pipeline USER space
     YY: number of definitions in the script instance (frozen in the pipeline)
     ZZ: number of definitions in the script (frozen space)

    pipelines are executed sequentially (i.e. parameters can be multivalued)
        cmd = p.do()
        fullscript = p.script()

    pipelines are indexed
        cmd = p[[0,2]].do()
        cmd = p[0:2].do()
        cmd = p.do([0,2])

    pipelines can be reordered
        q = p[[2,0,1]]

    steps can be deleted
        p[[0,1]] = []

    clear all executions with
        p.clear()
        p.clear(idx=1,2)

    local USER space can be accessed via
    (affects only the considered step)
        p.USER[0].a = 1
        p.USER[0].b = [1 2]
        p.USER[0].c = "$ hello world"

    global USER space can accessed via
    (affects all steps onward)
        p.scripts[0].USER.a = 10
        p.scripts[0].USER.b = [10 20]
        p.scripts[0].USER.c = "$ bye bye"

    static definitions
        p.scripts[0].DEFINITIONS

    steps can be renamed with the method rename()

    syntaxes are  la Matlab:
        p = pipescript()
        p | i
        p = collection | G
        p[0]
        q = p | p
        q[0] = []
        p[0:1] = q[0:1]
        p = G | c | g | d | b | i | t | d | s | r
        p.rename(["G","c","g","d","b","i","t","d","s","r"])
        cmd = p.do([0,1,4,7])
        sp = p.script([0,1,4,7])
        r = collection | p

    join joins a list (static method)
        p = pipescript.join([p1,p2,s3,s4])


    Pending: mechanism to store LAMMPS results (dump3) in the pipeline
</code></pre>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pipescript:
    &#34;&#34;&#34;
    pipescript: A Class for Managing Script Pipelines

    The `pipescript` class stores scripts in a pipeline where multiple scripts,
    script objects, or script object groups can be combined and executed
    sequentially. Scripts in the pipeline are executed using the pipe (`|`) operator,
    allowing for dynamic control over execution order, script concatenation, and
    variable management.

    Key Features:
    -------------
    - **Pipeline Construction**: Create pipelines of scripts, combining multiple
      script objects, `script`, `scriptobject`, or `scriptobjectgroup` instances.
      The pipe operator (`|`) is overloaded to concatenate scripts.
    - **Sequential Execution**: Execute all scripts in the pipeline in the order
      they were added, with support for reordering, selective execution, and
      clearing of individual steps.
    - **User and Definition Spaces**: Manage local and global user-defined variables
      (`USER` space) and static definitions for each script in the pipeline.
      Global definitions apply to all scripts in the pipeline, while local variables
      apply to specific steps.
    - **Flexible Script Handling**: Indexing, slicing, reordering, and renaming
      scripts in the pipeline are supported. Scripts can be accessed, replaced,
      and modified like array elements.

    Practical Use Cases:
    --------------------
    - **LAMMPS Script Automation**: Automate the generation of multi-step simulation
      scripts for LAMMPS, combining different simulation setups into a single pipeline.
    - **Script Management**: Combine and manage multiple scripts, tracking user
      variables and ensuring that execution order can be adjusted easily.
    - **Advanced Script Execution**: Perform partial pipeline execution, reorder
      steps, or clear completed steps while maintaining the original pipeline structure.

    Methods:
    --------
    __init__(self, s=None):
        Initializes a new `pipescript` object, optionally starting with a script
        or script-like object (`script`, `scriptobject`, `scriptobjectgroup`).

    setUSER(self, idx, key, value):
        Set a user-defined variable (`USER`) for the script at the specified index.

    getUSER(self, idx, key):
        Get the value of a user-defined variable (`USER`) for the script at the
        specified index.

    clear(self, idx=None):
        Clear the execution status of scripts in the pipeline, allowing them to
        be executed again.

    do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Execute the pipeline or a subset of the pipeline, generating a combined
        LAMMPS-compatible script.

    script(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        Generate the final LAMMPS script from the pipeline or a subset of the pipeline.

    rename(self, name=&#34;&#34;, idx=None):
        Rename the scripts in the pipeline, assigning new names to specific
        indices or all scripts.

    write(self, file, printflag=True, verbosity=2, verbose=None):
        Write the generated script to a file.

    dscript(self, verbose=None, **USER)
        Convert the current pipescript into a dscript object

    header(self, verbose=True,verbosity=None, style=4):
        Generate a formatted header for the pipescript file.

    list_values(self, varname, what=&#34;all&#34;):
        List all occurrences and values of a variable across the pipeline scripts.

    list_multiple_values(self, varnames, what=&#34;all&#34;):
        List all occurrences and values of multiple variables across the pipeline scripts.

    plot_value_distribution(self, varname, what=&#34;all&#34;):
        Plot the distribution of values for a given variable across specified scopes.

    generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        Generate a comprehensive report for specified variables and writes it to a file.


    Static Methods:
    ---------------
    join(liste):
        Combine a list of `script` and `pipescript` objects into a single pipeline.

    Additional Features:
    --------------------
    - **Indexing and Slicing**: Use array-like indexing (`p[0]`, `p[1:3]`) to access
      and manipulate scripts in the pipeline.
    - **Deep Copy Support**: The pipeline supports deep copying, preserving the
      entire pipeline structure and its scripts.
    - **Verbose and Print Options**: Control verbosity and printing behavior for
      generated scripts, allowing for detailed output or minimal script generation.

    Original Content:
    -----------------
    The `pipescript` class supports a variety of pipeline operations, including:
    - Sequential execution with `cmd = p.do()`.
    - Reordering pipelines with `p[[2, 0, 1]]`.
    - Deleting steps with `p[[0, 1]] = []`.
    - Accessing local and global user space variables via `p.USER[idx].var` and
      `p.scripts[idx].USER.var`.
    - Managing static definitions for each script in the pipeline.
    - Example usage:
      ```
      p = pipescript()
      p | i
      p = G | c | g | d | b | i | t | d | s | r
      p.rename([&#34;G&#34;, &#34;c&#34;, &#34;g&#34;, &#34;d&#34;, &#34;b&#34;, &#34;i&#34;, &#34;t&#34;, &#34;d&#34;, &#34;s&#34;, &#34;r&#34;])
      cmd = p.do([0, 1, 4, 7])
      sp = p.script([0, 1, 4, 7])
      ```
    - Scripts in the pipeline are executed sequentially, and definitions propagate
      from left to right. The `USER` space and `DEFINITIONS` are managed separately
      for each script in the pipeline.

    OVERVIEW
    -----------------
        Pipescript class stores scripts in pipelines
            By assuming: s0, s1, s2... scripts, scriptobject or scriptobjectgroup
            p = s0 | s1 | s2 generates a pipe script

            Example of pipeline:
          ------------:----------------------------------------
          [-]  00: G with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  01: c with (0&gt;&gt;0&gt;&gt;10) DEFINITIONS
          [-]  02: g with (0&gt;&gt;0&gt;&gt;26) DEFINITIONS
          [-]  03: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  04: b with (0&gt;&gt;0&gt;&gt;28) DEFINITIONS
          [-]  05: i with (0&gt;&gt;0&gt;&gt;49) DEFINITIONS
          [-]  06: t with (0&gt;&gt;0&gt;&gt;2) DEFINITIONS
          [-]  07: d with (0&gt;&gt;0&gt;&gt;19) DEFINITIONS
          [-]  08: s with (0&gt;&gt;0&gt;&gt;1) DEFINITIONS
          [-]  09: r with (0&gt;&gt;0&gt;&gt;20) DEFINITIONS
          ------------:----------------------------------------
        Out[35]: pipescript containing 11 scripts with 8 executed[*]

        note: XX&gt;&gt;YY&gt;&gt;ZZ represents the number of stored variables
             and the direction of propagation (inheritance from left)
             XX: number of definitions in the pipeline USER space
             YY: number of definitions in the script instance (frozen in the pipeline)
             ZZ: number of definitions in the script (frozen space)

            pipelines are executed sequentially (i.e. parameters can be multivalued)
                cmd = p.do()
                fullscript = p.script()

            pipelines are indexed
                cmd = p[[0,2]].do()
                cmd = p[0:2].do()
                cmd = p.do([0,2])

            pipelines can be reordered
                q = p[[2,0,1]]

            steps can be deleted
                p[[0,1]] = []

            clear all executions with
                p.clear()
                p.clear(idx=1,2)

            local USER space can be accessed via
            (affects only the considered step)
                p.USER[0].a = 1
                p.USER[0].b = [1 2]
                p.USER[0].c = &#34;$ hello world&#34;

            global USER space can accessed via
            (affects all steps onward)
                p.scripts[0].USER.a = 10
                p.scripts[0].USER.b = [10 20]
                p.scripts[0].USER.c = &#34;$ bye bye&#34;

            static definitions
                p.scripts[0].DEFINITIONS

            steps can be renamed with the method rename()

            syntaxes are  la Matlab:
                p = pipescript()
                p | i
                p = collection | G
                p[0]
                q = p | p
                q[0] = []
                p[0:1] = q[0:1]
                p = G | c | g | d | b | i | t | d | s | r
                p.rename([&#34;G&#34;,&#34;c&#34;,&#34;g&#34;,&#34;d&#34;,&#34;b&#34;,&#34;i&#34;,&#34;t&#34;,&#34;d&#34;,&#34;s&#34;,&#34;r&#34;])
                cmd = p.do([0,1,4,7])
                sp = p.script([0,1,4,7])
                r = collection | p

            join joins a list (static method)
                p = pipescript.join([p1,p2,s3,s4])


            Pending: mechanism to store LAMMPS results (dump3) in the pipeline
    &#34;&#34;&#34;

    def __init__(self,s=None, name=None, printflag=False, verbose=True, verbosity = None):
        &#34;&#34;&#34; constructor &#34;&#34;&#34;
        self.globalscript = None
        self.listscript = []
        self.listUSER = []
        self.printflag = printflag
        self.verbose = verbose if verbosity is None else verbosity&gt;0
        self.verbosity = 0 if not verbose else verbosity
        self.cmd = &#34;&#34;
        if isinstance(s,script):
            self.listscript = [duplicate(s)]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobject):
            self.listscript = [scriptobjectgroup(s).script]
            self.listUSER = [scriptdata()]
        elif isinstance(s,scriptobjectgroup):
            self.listscript = [s.script]
            self.listUSER = [scriptdata()]
        else:
            ValueError(&#34;the argument should be a scriptobject or scriptobjectgroup&#34;)
        if s != None:
            self.name = [str(s)]
            self.executed = [False]
        else:
            self.name = []
            self.executed = []

    def setUSER(self,idx,key,value):
        &#34;&#34;&#34;
            setUSER sets USER variables
            setUSER(idx,varname,varvalue)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].setattr(key,value)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    def getUSER(self,idx,key):
        &#34;&#34;&#34;
            getUSER get USER variable
            getUSER(idx,varname)
        &#34;&#34;&#34;
        if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
            self.listUSER[idx].getattr(key)
        else:
            raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)

    @property
    def USER(self):
        &#34;&#34;&#34;
            p.USER[idx].var returns the value of the USER variable var
            p.USER[idx].var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listUSER  # override listuser

    @property
    def scripts(self):
        &#34;&#34;&#34;
            p.scripts[idx].USER.var returns the value of the USER variable var
            p.scripts[idx].USER.var = val assigns the value val to the USER variable var
        &#34;&#34;&#34;
        return self.listscript # override listuser

    def __add__(self,s):
        &#34;&#34;&#34; overload + as pipe with copy &#34;&#34;&#34;
        from pizza.dscript import dscript
        if isinstance(s,(pipescript,script)):
            dup = deepduplicate(self)
            return dup | s      # + or | are synonyms
        elif isinstance(s,scriptobject):
            return self + s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
        elif isinstance(s,dscript):
            return self + s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
        else:
            raise TypeError(f&#34;The operand should be a pipescript/script/dscript/scriptobjectgroup and not &#39;{type(s).__name__}&#39;&#34;)

    def __iadd__(self,s):
        &#34;&#34;&#34; overload += as pipe without copy &#34;&#34;&#34;
        if isinstance(s,pipescript):
            return self | s      # + or | are synonyms
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)

    def __mul__(self,ntimes):
        &#34;&#34;&#34; overload * as multiple pipes with copy &#34;&#34;&#34;
        if isinstance(self,pipescript):
            res = deepduplicate(self)
            if ntimes&gt;1:
                for n in range(1,ntimes): res += self
            return res
        else:
            raise TypeError(f&#34;The operand should be a pipescript and not &#39;{type(s).__name__}&#39;&#34;)



    def __or__(self, s):
        &#34;&#34;&#34; Overload | pipe operator in pipescript &#34;&#34;&#34;
        leftarg = deepduplicate(self)  # Make a deep copy of the current object
        # Local import only when dscript type needs to be checked
        from pizza.dscript import dscript
        from pizza.group import group, groupcollection
        from pizza.region import region
        # Convert rightarg to pipescript if needed
        if isinstance(s, dscript):
            rightarg = s.pipescript(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the dscript object to a pipescript
            native = False
        elif isinstance(s,script):
            rightarg = pipescript(s,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,(scriptobject,scriptobjectgroup)):
            rightarg = pipescript(s,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, group):
            stmp = s.script(printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)
            rightarg = pipescript(stmp,printflag=s.printflag,verbose=s.verbose,verbosity=s.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, groupcollection):
            stmp = s.script(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)
            rightarg = pipescript(stmp,printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s, region):
            rightarg = s.pipescript(printflag=self.printflag,verbose=self.verbose,verbosity=self.verbosity)  # Convert the script-like object into a pipescript
            native = False
        elif isinstance(s,pipescript):
            rightarg = s
            native = True
        else:
            raise TypeError(f&#34;The operand should be a pipescript, dscript, script, scriptobject, scriptobjectgroup, group or groupcollection not {type(s)}&#34;)
        # Native piping
        if native:
            leftarg.listscript = leftarg.listscript + rightarg.listscript
            leftarg.listUSER = leftarg.listUSER + rightarg.listUSER
            leftarg.name = leftarg.name + rightarg.name
            for i in range(len(rightarg)):
                rightarg.executed[i] = False
            leftarg.executed = leftarg.executed + rightarg.executed
            return leftarg
        # Piping for non-native objects (dscript or script-like objects)
        else:
            # Loop through all items in rightarg and concatenate them
            for i in range(rightarg.n):
                leftarg.listscript.append(rightarg.listscript[i])
                leftarg.listUSER.append(rightarg.listUSER[i])
                leftarg.name.append(rightarg.name[i])
                leftarg.executed.append(False)
            return leftarg



    def __str__(self):
        &#34;&#34;&#34; string representation &#34;&#34;&#34;
        return f&#34;pipescript containing {self.n} scripts with {self.nrun} executed[*]&#34;


    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        line = &#34;  &#34;+&#34;-&#34;*12+&#34;:&#34;+&#34;-&#34;*40
        if self.verbose:
            print(&#34;&#34;,&#34;Pipeline with %d scripts and&#34; % self.n,
                  &#34;D(STATIC:GLOBAL:LOCAL) DEFINITIONS&#34;,line,sep=&#34;\n&#34;)
        else:
            print(line)
        for i in range(len(self)):
            if self.executed[i]:
                state = &#34;*&#34;
            else:
                state = &#34;-&#34;
            print(&#34;%10s&#34; % (&#34;[%s]  %02d:&#34; % (state,i)),
                  self.name[i],&#34;with D(%2d:%2d:%2d)&#34; % (
                       len(self.listscript[i].DEFINITIONS),
                       len(self.listscript[i].USER),
                       len(self.listUSER[i])                 )
                  )
        if self.verbose:
            print(line,&#34;::: notes :::&#34;,&#34;p[i], p[i:j], p[[i,j]] copy pipeline segments&#34;,
                  &#34;LOCAL: p.USER[i],p.USER[i].variable modify the user space of only p[i]&#34;,
                  &#34;GLOBAL: p.scripts[i].USER.var to modify the user space from p[i] and onwards&#34;,
                  &#34;STATIC: p.scripts[i].DEFINITIONS&#34;,
                  &#39;p.rename(idx=range(2),name=[&#34;A&#34;,&#34;B&#34;]), p.clear(idx=[0,3,4])&#39;,
                  &#34;p.script(), p.script(idx=range(5)), p[0:5].script()&#34;,&#34;&#34;,sep=&#34;\n&#34;)
        else:
             print(line)
        return str(self)

    def __len__(self):
        &#34;&#34;&#34; len() method &#34;&#34;&#34;
        return len(self.listscript)

    @property
    def n(self):
        &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
        return len(self)

    @property
    def nrun(self):
        &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
        n, nmax  = 0, len(self)
        while n&lt;nmax and self.executed[n]: n+=1
        return n

    def __getitem__(self,idx):
        &#34;&#34;&#34; return the ith or slice element(s) of the pipe  &#34;&#34;&#34;
        dup = deepduplicate(self)
        if isinstance(idx,slice):
            dup.listscript = dup.listscript[idx]
            dup.listUSER = dup.listUSER[idx]
            dup.name = dup.name[idx]
            dup.executed = dup.executed[idx]
        elif isinstance(idx,int):
            if idx&lt;len(self):
                dup.listscript = dup.listscript[idx:idx+1]
                dup.listUSER = dup.listUSER[idx:idx+1]
                dup.name = dup.name[idx:idx+1]
                dup.executed = dup.executed[idx:idx+1]
            else:
                raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)
        elif isinstance(idx,list):
            dup.listscript = picker(dup.listscript,idx)
            dup.listUSER = picker(dup.listUSER,idx)
            dup.name = picker(dup.name,idx)
            dup.executed = picker(dup.executed,idx)
        else:
            raise IndexError(&#34;the index needs to be a slice or an integer&#34;)
        return dup

    def __setitem__(self,idx,s):
        &#34;&#34;&#34;
            modify the ith element of the pipe
                p[4] = [] removes the 4th element
                p[4:7] = [] removes the elements from position 4 to 6
                p[2:4] = p[0:2] copy the elements 0 and 1 in positions 2 and 3
                p[[3,4]]=p[0]
        &#34;&#34;&#34;
        if isinstance(s,(script,scriptobject,scriptobjectgroup)):
            dup = pipescript(s)
        elif isinstance(s,pipescript):
            dup = s
        elif s==[]:
            dup = []
        else:
            raise ValueError(&#34;the value must be a pipescript, script, scriptobject, scriptobjectgroup&#34;)
        if len(s)&lt;1: # remove (delete)
            if isinstance(idx,slice) or idx&lt;len(self):
                del self.listscript[idx]
                del self.listUSER[idx]
                del self.name[idx]
                del self.executed[idx]
            else:
                raise IndexError(&#34;the index must be a slice or an integer&#34;)
        elif len(s)==1: # scalar
            if isinstance(idx,int):
                if idx&lt;len(self):
                    self.listscript[idx] = dup.listscript[0]
                    self.listUSER[idx] = dup.listUSER[0]
                    self.name[idx] = dup.name[0]
                    self.executed[idx] = False
                elif idx==len(self):
                    self.listscript.append(dup.listscript[0])
                    self.listUSER.append(dup.listUSER[0])
                    self.name.append(dup.name[0])
                    self.executed.append(False)
                else:
                    raise IndexError(f&#34;the index must be ranged between 0 and {self.n}&#34;)
            elif isinstance(idx,list):
                for i in range(len(idx)):
                    self.__setitem__(idx[i], s) # call as a scalar
            elif isinstance(idx,slice):
                for i in range(*idx.indices(len(self)+1)):
                    self.__setitem__(i, s)
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)
        else: # many values
            if isinstance(idx,list): # list call  la Matlab
                if len(idx)==len(s):
                    for i in range(len(s)):
                        self.__setitem__(idx[i], s[i]) # call as a scalar
                else:
                    raise IndexError(f&#34;the number of indices {len(list)} does not match the number of values {len(s)}&#34;)
            elif isinstance(idx,slice):
                ilist = list(range(*idx.indices(len(self)+len(s))))
                self.__setitem__(ilist, s) # call as a list
            else:
                raise IndexError(&#34;unrocognized index value, the index should be an integer or a slice&#34;)

    def rename(self,name=&#34;&#34;,idx=None):
        &#34;&#34;&#34;
            rename scripts in the pipe
                p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
        &#34;&#34;&#34;
        if isinstance(name,list):
            if len(name)==len(self) and idx==None:
                self.name = name
            elif len(name) == len(idx):
                for i in range(len(idx)):
                    self.rename(name[i],idx[i])
            else:
                IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
        elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
            self.name[idx] = name
        else:
            raise ValueError(&#34;provide a non empty name and valid index&#34;)

    def clear(self,idx=None):
        if len(self)&gt;0:
            if idx==None:
                for i in range(len(self)):
                    self.clear(i)
            else:
                if isinstance(idx,(range,list)):
                    for i in idx:
                        self.clear(idx=i)
                elif isinstance(idx,int) and idx&lt;len(self):
                    self.executed[idx] = False
                else:
                    raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
            if not self.executed[0]:
                self.globalscript = None
                self.cmd = &#34;&#34;



    def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        Parameters:
            idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
            printflag (bool, optional): Whether to print the script for each step. Default is True.
            verbosity (int, optional): Level of verbosity for the output.
            verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
            forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

        Returns:
            str: Combined LAMMPS script for the specified pipeline steps.

            Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

            This method processes the pipeline of script objects, executing each step to generate
            a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
            or for a specified range of indices. The generated script can include comments and
            metadata based on the verbosity level.


        Method Workflow:
            - The method first checks if there are any script objects in the pipeline.
              If the pipeline is empty, it returns a message indicating that there is nothing to execute.
            - It determines the start and stop indices for the range of steps to execute.
              If idx is not provided, it defaults to executing all steps from the last executed position.
            - If a specific index or list of indices is provided, it executes only those steps.
            - The pipeline steps are executed in order, combining the scripts using the
              &gt;&gt; operator for sequential execution.
            - The generated script includes comments indicating the current run step and pipeline range,
              based on the specified verbosity level.
            - The final combined script is returned as a string.

        Example Usage:
        --------------
            &gt;&gt;&gt; p = pipescript()
            &gt;&gt;&gt; # Execute the entire pipeline
            &gt;&gt;&gt; full_script = p.do()
            &gt;&gt;&gt; # Execute steps 0 and 2 only
            &gt;&gt;&gt; partial_script = p.do([0, 2])
            &gt;&gt;&gt; # Execute step 1 with minimal verbosity
            &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

            Notes:
            - The method uses modular arithmetic to handle index wrapping, allowing
              for cyclic execution of pipeline steps.
            - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
            - The globalscript is initialized or updated with each step&#39;s script,
              and the USER definitions are accumulated across the steps.
            - The command string self.cmd is updated with the generated script for
              each step in the specified range.

            Raises:
            - None: The method does not raise exceptions directly, but an empty pipeline will
                    result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;
        verbosity = 0 if verbose is False else verbosity
        if len(self) == 0:
            return &#34;# empty pipe - nothing to do&#34;

        # Check if not all steps are executed or if there are gaps
        not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

        # Determine pipeline range
        total_steps = len(self)
        if self.globalscript is None or forced or not_all_executed:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
            self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

        if idx is None:
            idx = range(start, total_steps)
        if isinstance(idx, int):
            idx = [idx]
        if isinstance(idx, range):
            idx = list(idx)

        idx = [i % total_steps for i in idx]
        start, stop = min(idx), max(idx)

        # Prevent re-executing already completed steps
        if not forced:
            idx = [step for step in idx if not self.executed[step]]

        # Execute pipeline steps
        for step in idx:
            step_wrapped = step % total_steps

            # Combine scripts
            if step_wrapped == 0:
                self.globalscript = self.listscript[step_wrapped]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

            # Step label
            step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
            step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

            # Get script content for the step
            step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

            # Add comments and content
            if step_output.strip():
                self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
            elif verbosity &gt; 0:
                self.cmd += f&#34;{step_label} :: no content\n\n&#34;

            # Update USER definitions
            self.globalscript.USER += self.listUSER[step]
            self.executed[step] = True

        # Clean up and finalize script
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
        self.cmd += &#34;\n&#34;  # Ensure trailing newline
        return remove_comments(self.cmd) if verbosity == 0 else self.cmd


    def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
        &#34;&#34;&#34;
        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated

        Returns:
        - str: The combined LAMMPS script generated from the specified steps of the pipeline.

        Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

        Example Usage:
        --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
        &#34;&#34;&#34;

        verbosity = 0 if verbose is False else verbosity
        if len(self)&gt;0:
            # ranges
            ntot = len(self)
            stop = ntot-1
            if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
                start = 0
                self.cmd = &#34;&#34;
            else:
                start = self.nrun
            if start&gt;stop: return self.cmd
            if idx is None: idx = range(start,stop+1)
            if isinstance(idx,range): idx = list(idx)
            if isinstance(idx,int): idx = [idx]
            start,stop = min(idx),max(idx)
            # do
            for i in idx:
                j = i % ntot
                if j==0:
                    self.globalscript = self.listscript[j]
                else:
                    self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
                name = &#34;  &#34;+self.name[i]+&#34;  &#34;
                if verbosity&gt;0:
                    self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                            (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
                else:
                    self.cmd +=&#34;\n&#34;
                self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
                self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
                self.executed[i] = True
            self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
            return remove_comments(self.cmd) if verbosity==0 else self.cmd
        else:
            return &#34;# empty pipe - nothing to do&#34;


    def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
        &#34;&#34;&#34;
            script the pipeline or parts of the pipeline
                s = p.script()
                s = p.script([0,2])

        Parameters:
        - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                               If None, all steps from the current position to
                                               the end are executed. A list of indices can be
                                               provided to execute specific steps, or a single
                                               integer can be passed to execute a specific step.
                                               Default is None.
        - printflag (bool, optional): If True, the generated script for each step is printed
                                      to the console. Default is True.
        - verbosity (int, optional): Controls the level of detail in the generated script.
                                     - 0: Minimal output, no comments.
                                     - 1: Basic comments for run steps.
                                     - 2: Detailed comments with additional information.
                                     Default is 2.
        - forced (bool, optional): If True, all scripts are regenerated
        - style (int, optional):
            Defines the ASCII frame style for the header.
            Valid values are integers from 1 to 6, corresponding to predefined styles:
                1. Basic box with `+`, `-`, and `|`
                2. Double-line frame with ``, ``, and ``
                3. Rounded corners with `.`, `&#39;`, `-`, and `|`
                4. Thick outer frame with `#`, `=`, and `#`
                5. Box drawing characters with ``, ``, and ``
                6. Minimalist dotted frame with `.`, `:`, and `.`
            Default is `4` (thick outer frame).

        &#34;&#34;&#34;
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity=0 if verbose is False else verbosity
        s = script(printflag=printflag, verbose=verbosity&gt;0)
        s.name = &#34;pipescript&#34;
        s.description = &#34;pipeline with %d scripts&#34; % len(self)
        if len(self)&gt;1:
            s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
        elif len(self)==1:
            s.userid = self.name[0]
        else:
            s.userid = &#34;empty pipeline&#34;
        s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
            self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
        s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
        s.USER = duplicate(self.globalscript.USER)
        return s

    @staticmethod
    def join(liste):
        &#34;&#34;&#34;
            join a combination scripts and pipescripts within a pipescript
                p = pipescript.join([s1,s2,p3,p4,p5...])
        &#34;&#34;&#34;
        if not isinstance(liste,list):
            raise ValueError(&#34;the argument should be a list&#34;)
        ok = True
        for i in range(len(liste)):
            ok = ok and isinstance(liste[i],(script,pipescript))
            if not ok:
                raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
        if len(liste)&lt;1:
            return liste
        out = liste[0]
        for i in range(1,len(liste)):
            out = out | liste[i]
        return out

    # Note that it was not the original intent to copy pipescripts
    def __copy__(self):
        &#34;&#34;&#34; copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        copie.__dict__.update(self.__dict__)
        return copie

    def __deepcopy__(self, memo):
        &#34;&#34;&#34; deep copy method &#34;&#34;&#34;
        cls = self.__class__
        copie = cls.__new__(cls)
        memo[id(self)] = copie
        for k, v in self.__dict__.items():
            setattr(copie, k, deepduplicate(v, memo))
        return copie

    # write file
    def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
       &#34;&#34;&#34;
       Write the combined script to a file.

       Parameters:
           file (str): The file path where the script will be saved.
           printflag (bool): Flag to enable/disable printing of details.
           verbosity (int): Level of verbosity for the script generation.
           verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
           overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

        Returns:
            str: The full absolute path of the file written.

       Raises:
           FileExistsError: If the file already exists and overwrite is False.

       Notes:
           - This method combines the individual scripts within the `pipescript` object
             and saves the resulting script to the specified file.
           - If `overwrite` is False and the file exists, an error is raised.
           - If `verbose` is True and the file is overwritten, a warning is displayed.
       &#34;&#34;&#34;
       # Generate the combined script
       myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
       # Call the script&#39;s write method with the overwrite parameter
       return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)


    def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
        &#34;&#34;&#34;
        Convert the current pipescript object to a dscript object.

        This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
        in the pipescript into a single dynamic script per step in the dscript.
        Each step in the pipescript is transformed into a dynamic script in the dscript,
        where variable spaces are combined using the following order:

        1. STATIC: Definitions specific to each script in the pipescript.
        2. GLOBAL: User variables shared across steps from a specific point onwards.
        3. LOCAL: User variables for each individual step.

        Parameters:
        -----------
        verbose : bool, optional
            Controls verbosity of the dynamic scripts in the resulting dscript object.
            If None, the verbosity setting of the pipescript will be used.

        clean : &#34;fixing&#34; or &#34;removing&#34;
            - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
            - &#39;fixing&#39;: Replace the content of the empty step with a comment.

        **USER : scriptobjectdata(), optional
            Additional user-defined variables that can override existing static variables
            in the dscript object or be added to it.

        Returns:
        --------
        outd : dscript
            A dscript object that contains all steps of the pipescript as dynamic scripts.
            Each step from the pipescript is added as a dynamic script with the same content
            and combined variable spaces.
        &#34;&#34;&#34;
        # Local imports
        from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

        # verbosity
        printflag = self.printflag if printflag is None else printflag
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity

        # Adjust name
        if name is None:
            if isinstance(self.name, str):
                name = self.name
            elif isinstance(self.name, list):
                name = (
                    self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
                )

        # Create the dscript container with the pipescript name as the userid
        outd = dscript(userid=name, verbose=self.verbose, **USER)

        # Initialize static merged definitions
        staticmerged_definitions = lambdaScriptdata()

        # Track used variables per step
        step_used_variables = []

        # Loop over each step in the pipescript
        for i, script in enumerate(self.listscript):
            # Merge STATIC, GLOBAL, and LOCAL variables for the current step
            static_vars = self.listUSER[i] # script.DEFINITIONS
            global_vars = script.DEFINITIONS # self.scripts[i].USER
            local_vars = script.USER # self.USER[i]
            refreshed_globalvars = static_vars + global_vars

            # Detect variables used in the current template
            used_variables = set(script.detect_variables())
            step_used_variables.append(used_variables)  # Track used variables for this step

            # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
            local_static_updates = lambdaScriptdata(**local_vars)

            for var, value in refreshed_globalvars.items():
                if var in staticmerged_definitions:
                    if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                        setattr(local_static_updates, var, value)
                else:
                    setattr(staticmerged_definitions, var, value)

           # Create the dynamic script for this step using the method in dscript
            key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
            content = script.TEMPLATE

            # Use the helper method in dscript to add this dynamic script
            outd.add_dynamic_script(
                key=key_name,
                content=content,
                definitions = lambdaScriptdata(**local_static_updates),
                verbose=self.verbose if verbose is None else verbose,
                userid=self.name[i],
                autorefresh=False # prevent the replacement by default values ${}
            )

            # Set eval=True only if variables are detected in the template
            if outd.TEMPLATE[key_name].detect_variables():
                outd.TEMPLATE[key_name].eval = True

        # Compute the union of all used variables across all steps
        global_used_variables = set().union(*step_used_variables)

        # Filter staticmerged_definitions to keep only variables that are used
        filtered_definitions = {
            var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
        }

        # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
        outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

        # Clean the entries for empty templates
        outd.clean(verbose=verbose,behavior=clean)

        return outd



    def header(self, verbose=True,verbosity=None, style=4):
        &#34;&#34;&#34;
        Generate a formatted header for the pipescript file.

        Parameters:
            verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                        Defaults to the instance&#39;s `verbose`.
            style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

        Returns:
            str: A formatted string representing the pipescript object.
                 Returns an empty string if verbosity is False.

        The header includes:
            - Total number of scripts in the pipeline.
            - The verbosity setting.
            - The range of scripts from the first to the last script.
            - All enclosed within an ASCII frame that adjusts to the content.
        &#34;&#34;&#34;
        verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
        verbosity = 0 if not verbose else verbosity
        if not verbosity:
            return &#34;&#34;

        # Prepare the header content
        lines = [
            f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
            &#34;&#34;,
            f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
        ]

        # Use the shared method to format the header
        return frame_header(lines,style=style)



    def list_values(self, varname=None, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

        Parameters:
        - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
        - what (str or list/tuple, optional): Specifies the scopes to search in.
                                             Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                             or a list/tuple of any combination of these.

        Returns:
        - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
        - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
        &#34;&#34;&#34;
        # Normalize &#39;what&#39; to a list for uniform processing
        if isinstance(what, str):
            if what.lower() == &#34;all&#34;:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = [what.lower()]
        elif isinstance(what, (list, tuple)):
            scopes_lower = [s.lower() for s in what]
            if &#39;all&#39; in scopes_lower:
                scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
            else:
                scopes = scopes_lower
        else:
            raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

        # Initialize data structures
        if varname:
            # Single variable case
            if len(scopes) == 1:
                data = []
            else:
                data = {}
                for scope in scopes:
                    data[scope] = []

            # Iterate over each script in the pipeline
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                # Check each requested scope
                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    if varname in vars_dict.keys():
                        value = getattr(vars_dict,varname)
                        if len(scopes) == 1:
                            data.append((i, value))
                        else:
                            data[scope].append((i, value))

            # Return a VariableOccurrences instance for the specified variable
            return VariableOccurrences(data, variables=varname)

        else:
            # All variables case
            all_vars = set()

            # First, collect all variable names across specified scopes and scripts
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    all_vars.update(vars_dict.keys())

            # Initialize a dictionary to hold VariableOccurrences for each variable
            variables_data = {}
            for var in all_vars:
                var_data = {}
                for scope in scopes:
                    var_data[scope] = []
                variables_data[var] = var_data

            # Iterate again to populate the data for each variable
            for i, script in enumerate(self.listscript):
                # Retrieve variables for each scope
                static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
                global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
                local_vars = getattr(script, &#39;USER&#39;, {})

                scope_vars = {
                    &#34;static&#34;: static_vars,
                    &#34;global&#34;: global_vars,
                    &#34;local&#34;: local_vars
                }

                for scope in scopes:
                    vars_dict = scope_vars.get(scope, {})
                    for var, value in vars_dict.items():
                        variables_data[var][scope].append((i, value))

            # Convert each variable&#39;s data into a VariableOccurrences instance
            variables_occurrences = {}
            for var, data in variables_data.items():
                variables_occurrences[var] = VariableOccurrences(data, variables=var)

            return variables_occurrences



    def list_multiple_values(self, varnames, what=&#34;all&#34;):
        &#34;&#34;&#34;
        Lists all occurrences and values of multiple variables across the pipeline scripts.

        Parameters:
        - varnames (list): A list of variable names to search for.
        - what (str or list/tuple): Specifies the scopes to search in.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.

        Returns:
        - dict: A dictionary mapping each variable name to its VariableOccurrences object.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        return self.list_values(varname=varnames, what=what)



    def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
        &#34;&#34;&#34;
        Plots the distribution of elements for multiple variables across specified scopes.

        Parameters:
        - varnames (list): A list of variable names to plot.
        - what (str or list/tuple): Specifies the scopes to include in the plot.
                                     Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                     or a list/tuple of any combination of these.
        - separate_plots (bool): If True, plots each variable in a separate subplot.
                                 If False, combines all variables in a single plot for comparison.
        &#34;&#34;&#34;
        if not isinstance(varnames, (list, tuple)):
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

        # Retrieve VariableOccurrences instances
        multiple_vars = self.list_multiple_values(varnames, what=what)

        if separate_plots:
            num_vars = len(multiple_vars)
            fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
            if num_vars == 1:
                axes = [axes]  # Make it iterable

            for ax, (var, vo) in zip(axes, multiple_vars.items()):
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    ax.bar(elements, counts, label=scope)
                ax.set_xlabel(&#39;Element&#39;)
                ax.set_ylabel(&#39;Count&#39;)
                ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
                ax.legend()

            plt.tight_layout()
            plt.show()

        else:
            plt.figure(figsize=(12, 8))
            for var, vo in multiple_vars.items():
                summary = vo.summarize()[var]
                for scope, details in summary.items():
                    elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                    counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                    plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

            plt.xlabel(&#39;Element&#39;)
            plt.ylabel(&#39;Count&#39;)
            plt.title(&#34;Distribution of elements in multiple variables&#34;)
            plt.legend()
            plt.xticks(rotation=45, ha=&#39;right&#39;)
            plt.tight_layout()
            plt.show()


    def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
        &#34;&#34;&#34;
        Generates a comprehensive report for specified variables and writes it to a file.

        Parameters:
        - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
        - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
        - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

        Raises:
        - ValueError: If &#39;filename&#39; has an unsupported extension.
        - Exception: For other unforeseen errors.
        &#34;&#34;&#34;
        # Validate filename extension
        _, ext = os.path.splitext(filename)
        ext = ext.lower()

        if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
            raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

        # Determine format based on extension
        if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
            export_format = &#39;markdown&#39;
        elif ext == &#39;.html&#39;:
            export_format = &#39;html&#39;

        # Determine variables to include
        if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
            variables = &#39;all&#39;
        else:
            variables = varnames  # Can be a string or a list/tuple

        # Retrieve VariableOccurrences instances
        if variables == &#39;all&#39;:
            variables_occurrences = self.list_values(varname=None, what=scopes)
        else:
            # Normalize varnames to a list
            if isinstance(variables, str):
                variables = [variables]
            elif isinstance(variables, (list, tuple)):
                variables = list(variables)
            else:
                raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

            variables_occurrences = {}
            for var in variables:
                vo = self.list_values(varname=var, what=scopes)
                if vo and var in vo.variables:
                    variables_occurrences[var] = vo
                else:
                    print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

        # Initialize report content
        report_content = &#34;&#34;
        timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
        caller = &#34;generate_report&#34;

        # Add report header
        if export_format == &#39;markdown&#39;:
            report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
            report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
        elif export_format == &#39;html&#39;:
            # Define CSS for HTML
            css = &#34;&#34;&#34;
            &lt;style&gt;
                body {
                    font-family: Arial, sans-serif;
                    margin: 20px;
                }
                h1, h2, h3, h4, h5 {
                    color: #333;
                }
                table {
                    border-collapse: collapse;
                    width: 100%;
                    margin-bottom: 40px;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #4CAF50;
                    color: white;
                }
                tr:nth-child(even){background-color: #f2f2f2;}
                tr:hover {background-color: #ddd;}
            &lt;/style&gt;
            &#34;&#34;&#34;
            report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
            report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
            report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

        # Assemble report content using VariableOccurrences.export()
        for var, vo in variables_occurrences.items():
            # Export content without headers and get as string
            var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                    scopes=scopes,
                                    variables=var,
                                    include_headers=False,
                                    return_content=True)

            if export_format == &#39;markdown&#39;:
                # Add variable header
                report_content += f&#34;## Variable: `{var}`\n\n&#34;
                report_content += var_content + &#34;\n\n&#34;
                report_content += &#34;---\n\n&#34;  # Horizontal line between variables
            elif export_format == &#39;html&#39;:
                # Add variable header
                report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
                report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

        # Finalize HTML content
        if export_format == &#39;html&#39;:
            report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

        # Write report to file
        try:
            with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
                file.write(report_content)
            print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
        except Exception as e:
            raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="group.pipescript.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>liste)</span>
</code></dt>
<dd>
<div class="desc"><p>join a combination scripts and pipescripts within a pipescript
p = pipescript.join([s1,s2,p3,p4,p5&hellip;])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def join(liste):
    &#34;&#34;&#34;
        join a combination scripts and pipescripts within a pipescript
            p = pipescript.join([s1,s2,p3,p4,p5...])
    &#34;&#34;&#34;
    if not isinstance(liste,list):
        raise ValueError(&#34;the argument should be a list&#34;)
    ok = True
    for i in range(len(liste)):
        ok = ok and isinstance(liste[i],(script,pipescript))
        if not ok:
            raise ValueError(f&#34;the entry [{i}] should be a script or pipescript&#34;)
    if len(liste)&lt;1:
        return liste
    out = liste[0]
    for i in range(1,len(liste)):
        out = out | liste[i]
    return out</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="group.pipescript.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"><p>p.USER[idx].var returns the value of the USER variable var
p.USER[idx].var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def USER(self):
    &#34;&#34;&#34;
        p.USER[idx].var returns the value of the USER variable var
        p.USER[idx].var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listUSER  # override listuser</code></pre>
</details>
</dd>
<dt id="group.pipescript.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>number of scripts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34; number of scripts &#34;&#34;&#34;
    return len(self)</code></pre>
</details>
</dd>
<dt id="group.pipescript.nrun"><code class="name">var <span class="ident">nrun</span></code></dt>
<dd>
<div class="desc"><p>number of scripts executed continuously from origin</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nrun(self):
    &#34;&#34;&#34; number of scripts executed continuously from origin &#34;&#34;&#34;
    n, nmax  = 0, len(self)
    while n&lt;nmax and self.executed[n]: n+=1
    return n</code></pre>
</details>
</dd>
<dt id="group.pipescript.scripts"><code class="name">var <span class="ident">scripts</span></code></dt>
<dd>
<div class="desc"><p>p.scripts[idx].USER.var returns the value of the USER variable var
p.scripts[idx].USER.var = val assigns the value val to the USER variable var</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scripts(self):
    &#34;&#34;&#34;
        p.scripts[idx].USER.var returns the value of the USER variable var
        p.scripts[idx].USER.var = val assigns the value val to the USER variable var
    &#34;&#34;&#34;
    return self.listscript # override listuser</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="group.pipescript.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, idx=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,idx=None):
    if len(self)&gt;0:
        if idx==None:
            for i in range(len(self)):
                self.clear(i)
        else:
            if isinstance(idx,(range,list)):
                for i in idx:
                    self.clear(idx=i)
            elif isinstance(idx,int) and idx&lt;len(self):
                self.executed[idx] = False
            else:
                raise IndexError(f&#34;the index should be ranged between 0 and {self.n-1}&#34;)
        if not self.executed[0]:
            self.globalscript = None
            self.cmd = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="group.pipescript.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<h2 id="parameters">Parameters</h2>
<p>idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
printflag (bool, optional): Whether to print the script for each step. Default is True.
verbosity (int, optional): Level of verbosity for the output.
verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
forced (bool, optional): If True, forces the pipeline to regenerate all scripts.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Combined LAMMPS script for the specified pipeline steps.</dd>
</dl>
<p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.
Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the
&gt;&gt; operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
<h2 id="example-usage">Example Usage:</h2>
<pre><code>&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
  for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
  and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
  each step in the specified range.

Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
        result in the return of "# empty pipe - nothing to do".
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    Parameters:
        idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
        printflag (bool, optional): Whether to print the script for each step. Default is True.
        verbosity (int, optional): Level of verbosity for the output.
        verbose (bool, optional): Override for verbosity. If False, sets verbosity to 0.
        forced (bool, optional): If True, forces the pipeline to regenerate all scripts.

    Returns:
        str: Combined LAMMPS script for the specified pipeline steps.

        Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

        This method processes the pipeline of script objects, executing each step to generate
        a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
        or for a specified range of indices. The generated script can include comments and
        metadata based on the verbosity level.


    Method Workflow:
        - The method first checks if there are any script objects in the pipeline.
          If the pipeline is empty, it returns a message indicating that there is nothing to execute.
        - It determines the start and stop indices for the range of steps to execute.
          If idx is not provided, it defaults to executing all steps from the last executed position.
        - If a specific index or list of indices is provided, it executes only those steps.
        - The pipeline steps are executed in order, combining the scripts using the
          &gt;&gt; operator for sequential execution.
        - The generated script includes comments indicating the current run step and pipeline range,
          based on the specified verbosity level.
        - The final combined script is returned as a string.

    Example Usage:
    --------------
        &gt;&gt;&gt; p = pipescript()
        &gt;&gt;&gt; # Execute the entire pipeline
        &gt;&gt;&gt; full_script = p.do()
        &gt;&gt;&gt; # Execute steps 0 and 2 only
        &gt;&gt;&gt; partial_script = p.do([0, 2])
        &gt;&gt;&gt; # Execute step 1 with minimal verbosity
        &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

        Notes:
        - The method uses modular arithmetic to handle index wrapping, allowing
          for cyclic execution of pipeline steps.
        - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
        - The globalscript is initialized or updated with each step&#39;s script,
          and the USER definitions are accumulated across the steps.
        - The command string self.cmd is updated with the generated script for
          each step in the specified range.

        Raises:
        - None: The method does not raise exceptions directly, but an empty pipeline will
                result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;
    verbosity = 0 if verbose is False else verbosity
    if len(self) == 0:
        return &#34;# empty pipe - nothing to do&#34;

    # Check if not all steps are executed or if there are gaps
    not_all_executed = not all(self.executed[:self.nrun])  # Check up to the last executed step

    # Determine pipeline range
    total_steps = len(self)
    if self.globalscript is None or forced or not_all_executed:
        start = 0
        self.cmd = &#34;&#34;
    else:
        start = self.nrun
        self.cmd = self.cmd.rstrip(&#34;\n&#34;) + &#34;\n\n&#34;

    if idx is None:
        idx = range(start, total_steps)
    if isinstance(idx, int):
        idx = [idx]
    if isinstance(idx, range):
        idx = list(idx)

    idx = [i % total_steps for i in idx]
    start, stop = min(idx), max(idx)

    # Prevent re-executing already completed steps
    if not forced:
        idx = [step for step in idx if not self.executed[step]]

    # Execute pipeline steps
    for step in idx:
        step_wrapped = step % total_steps

        # Combine scripts
        if step_wrapped == 0:
            self.globalscript = self.listscript[step_wrapped]
        else:
            self.globalscript = self.globalscript &gt;&gt; self.listscript[step_wrapped]

        # Step label
        step_name = f&#34;&lt;{self.name[step]}&gt;&#34;
        step_label = f&#34;# [{step+1} of {total_steps} from {start}:{stop}] {step_name}&#34;

        # Get script content for the step
        step_output = self.globalscript.do(printflag=printflag, verbose=verbosity &gt; 1)

        # Add comments and content
        if step_output.strip():
            self.cmd += f&#34;{step_label}\n{step_output.strip()}\n\n&#34;
        elif verbosity &gt; 0:
            self.cmd += f&#34;{step_label} :: no content\n\n&#34;

        # Update USER definitions
        self.globalscript.USER += self.listUSER[step]
        self.executed[step] = True

    # Clean up and finalize script
    self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;).strip()  # Remove literal \\n and extra spaces
    self.cmd += &#34;\n&#34;  # Ensure trailing newline
    return remove_comments(self.cmd) if verbosity == 0 else self.cmd</code></pre>
</details>
</dd>
<dt id="group.pipescript.do_legacy"><code class="name flex">
<span>def <span class="ident">do_legacy</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the pipeline or a part of the pipeline and generate the LAMMPS script.</p>
<p>This method processes the pipeline of script objects, executing each step to generate
a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
or for a specified range of indices. The generated script can include comments and
metadata based on the verbosity level.</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated</p>
<p>Returns:
- str: The combined LAMMPS script generated from the specified steps of the pipeline.</p>
<p>Method Workflow:
- The method first checks if there are any script objects in the pipeline.
If the pipeline is empty, it returns a message indicating that there is nothing to execute.
- It determines the start and stop indices for the range of steps to execute.
If idx is not provided, it defaults to executing all steps from the last executed position.
- If a specific index or list of indices is provided, it executes only those steps.
- The pipeline steps are executed in order, combining the scripts using the</p>
<blockquote>
<blockquote>
<p>operator for sequential execution.
- The generated script includes comments indicating the current run step and pipeline range,
based on the specified verbosity level.
- The final combined script is returned as a string.</p>
</blockquote>
</blockquote>
<h2 id="example-usage">Example Usage:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; p = pipescript()
&gt;&gt;&gt; # Execute the entire pipeline
&gt;&gt;&gt; full_script = p.do()
&gt;&gt;&gt; # Execute steps 0 and 2 only
&gt;&gt;&gt; partial_script = p.do([0, 2])
&gt;&gt;&gt; # Execute step 1 with minimal verbosity
&gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)
</code></pre>
<p>Notes:
- The method uses modular arithmetic to handle index wrapping, allowing
for cyclic execution of pipeline steps.
- If the pipeline is empty, the method returns the string "# empty pipe - nothing to do".
- The globalscript is initialized or updated with each step's script,
and the USER definitions are accumulated across the steps.
- The command string self.cmd is updated with the generated script for
each step in the specified range.</p>
<p>Raises:
- None: The method does not raise exceptions directly, but an empty pipeline will
result in the return of "# empty pipe - nothing to do".</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_legacy(self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False):
    &#34;&#34;&#34;
    Execute the pipeline or a part of the pipeline and generate the LAMMPS script.

    This method processes the pipeline of script objects, executing each step to generate
    a combined LAMMPS-compatible script. The execution can be done for the entire pipeline
    or for a specified range of indices. The generated script can include comments and
    metadata based on the verbosity level.

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated

    Returns:
    - str: The combined LAMMPS script generated from the specified steps of the pipeline.

    Method Workflow:
    - The method first checks if there are any script objects in the pipeline.
      If the pipeline is empty, it returns a message indicating that there is nothing to execute.
    - It determines the start and stop indices for the range of steps to execute.
      If idx is not provided, it defaults to executing all steps from the last executed position.
    - If a specific index or list of indices is provided, it executes only those steps.
    - The pipeline steps are executed in order, combining the scripts using the
      &gt;&gt; operator for sequential execution.
    - The generated script includes comments indicating the current run step and pipeline range,
      based on the specified verbosity level.
    - The final combined script is returned as a string.

    Example Usage:
    --------------
    &gt;&gt;&gt; p = pipescript()
    &gt;&gt;&gt; # Execute the entire pipeline
    &gt;&gt;&gt; full_script = p.do()
    &gt;&gt;&gt; # Execute steps 0 and 2 only
    &gt;&gt;&gt; partial_script = p.do([0, 2])
    &gt;&gt;&gt; # Execute step 1 with minimal verbosity
    &gt;&gt;&gt; minimal_script = p.do(idx=1, verbosity=0)

    Notes:
    - The method uses modular arithmetic to handle index wrapping, allowing
      for cyclic execution of pipeline steps.
    - If the pipeline is empty, the method returns the string &#34;# empty pipe - nothing to do&#34;.
    - The globalscript is initialized or updated with each step&#39;s script,
      and the USER definitions are accumulated across the steps.
    - The command string self.cmd is updated with the generated script for
      each step in the specified range.

    Raises:
    - None: The method does not raise exceptions directly, but an empty pipeline will
            result in the return of &#34;# empty pipe - nothing to do&#34;.
    &#34;&#34;&#34;

    verbosity = 0 if verbose is False else verbosity
    if len(self)&gt;0:
        # ranges
        ntot = len(self)
        stop = ntot-1
        if (self.globalscript == None) or (self.globalscript == []) or not self.executed[0] or forced:
            start = 0
            self.cmd = &#34;&#34;
        else:
            start = self.nrun
        if start&gt;stop: return self.cmd
        if idx is None: idx = range(start,stop+1)
        if isinstance(idx,range): idx = list(idx)
        if isinstance(idx,int): idx = [idx]
        start,stop = min(idx),max(idx)
        # do
        for i in idx:
            j = i % ntot
            if j==0:
                self.globalscript = self.listscript[j]
            else:
                self.globalscript = self.globalscript &gt;&gt; self.listscript[j]
            name = &#34;  &#34;+self.name[i]+&#34;  &#34;
            if verbosity&gt;0:
                self.cmd += &#34;\n\n#\t --- run step [%d/%d] --- [%s]  %20s\n&#34; % \
                        (j,ntot-1,name.center(50,&#34;=&#34;),&#34;pipeline [%d]--&gt;[%d]&#34; %(start,stop))
            else:
                self.cmd +=&#34;\n&#34;
            self.globalscript.USER = self.globalscript.USER + self.listUSER[j]
            self.cmd += self.globalscript.do(printflag=printflag,verbose=verbosity&gt;1)
            self.executed[i] = True
        self.cmd = self.cmd.replace(&#34;\\n&#34;, &#34;\n&#34;) # remove literal \\n if any (dscript.save add \\n)
        return remove_comments(self.cmd) if verbosity==0 else self.cmd
    else:
        return &#34;# empty pipe - nothing to do&#34;</code></pre>
</details>
</dd>
<dt id="group.pipescript.dscript"><code class="name flex">
<span>def <span class="ident">dscript</span></span>(<span>self, name=None, printflag=None, verbose=None, verbosity=None, clean='fixing', **USER)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the current pipescript object to a dscript object.</p>
<p>This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
in the pipescript into a single dynamic script per step in the dscript.
Each step in the pipescript is transformed into a dynamic script in the dscript,
where variable spaces are combined using the following order:</p>
<ol>
<li>STATIC: Definitions specific to each script in the pipescript.</li>
<li>GLOBAL: User variables shared across steps from a specific point onwards.</li>
<li>LOCAL: User variables for each individual step.</li>
</ol>
<h2 id="parameters">Parameters:</h2>
<p>verbose : bool, optional
Controls verbosity of the dynamic scripts in the resulting dscript object.
If None, the verbosity setting of the pipescript will be used.</p>
<p>clean : "fixing" or "removing"
- 'removing': Completely remove the empty step from TEMPLATE.
- 'fixing': Replace the content of the empty step with a comment.</p>
<p>**USER : scriptobjectdata(), optional
Additional user-defined variables that can override existing static variables
in the dscript object or be added to it.</p>
<h2 id="returns">Returns:</h2>
<p>outd : dscript
A dscript object that contains all steps of the pipescript as dynamic scripts.
Each step from the pipescript is added as a dynamic script with the same content
and combined variable spaces.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dscript(self, name=None, printflag=None, verbose=None, verbosity=None, clean=&#34;fixing&#34;, **USER):
    &#34;&#34;&#34;
    Convert the current pipescript object to a dscript object.

    This method merges the STATIC, GLOBAL, and LOCAL variable spaces from each step
    in the pipescript into a single dynamic script per step in the dscript.
    Each step in the pipescript is transformed into a dynamic script in the dscript,
    where variable spaces are combined using the following order:

    1. STATIC: Definitions specific to each script in the pipescript.
    2. GLOBAL: User variables shared across steps from a specific point onwards.
    3. LOCAL: User variables for each individual step.

    Parameters:
    -----------
    verbose : bool, optional
        Controls verbosity of the dynamic scripts in the resulting dscript object.
        If None, the verbosity setting of the pipescript will be used.

    clean : &#34;fixing&#34; or &#34;removing&#34;
        - &#39;removing&#39;: Completely remove the empty step from TEMPLATE.
        - &#39;fixing&#39;: Replace the content of the empty step with a comment.

    **USER : scriptobjectdata(), optional
        Additional user-defined variables that can override existing static variables
        in the dscript object or be added to it.

    Returns:
    --------
    outd : dscript
        A dscript object that contains all steps of the pipescript as dynamic scripts.
        Each step from the pipescript is added as a dynamic script with the same content
        and combined variable spaces.
    &#34;&#34;&#34;
    # Local imports
    from pizza.dscript import dscript, ScriptTemplate, lambdaScriptdata

    # verbosity
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity

    # Adjust name
    if name is None:
        if isinstance(self.name, str):
            name = self.name
        elif isinstance(self.name, list):
            name = (
                self.name[0] if len(self.name) == 1 else self.name[0] + &#34;...&#34; + self.name[-1]
            )

    # Create the dscript container with the pipescript name as the userid
    outd = dscript(userid=name, verbose=self.verbose, **USER)

    # Initialize static merged definitions
    staticmerged_definitions = lambdaScriptdata()

    # Track used variables per step
    step_used_variables = []

    # Loop over each step in the pipescript
    for i, script in enumerate(self.listscript):
        # Merge STATIC, GLOBAL, and LOCAL variables for the current step
        static_vars = self.listUSER[i] # script.DEFINITIONS
        global_vars = script.DEFINITIONS # self.scripts[i].USER
        local_vars = script.USER # self.USER[i]
        refreshed_globalvars = static_vars + global_vars

        # Detect variables used in the current template
        used_variables = set(script.detect_variables())
        step_used_variables.append(used_variables)  # Track used variables for this step

        # Copy all current variables to local_static_updates and remove matching variables from staticmerged_definitions
        local_static_updates = lambdaScriptdata(**local_vars)

        for var, value in refreshed_globalvars.items():
            if var in staticmerged_definitions:
                if (getattr(staticmerged_definitions, var) != value) and (var not in local_vars):
                    setattr(local_static_updates, var, value)
            else:
                setattr(staticmerged_definitions, var, value)

       # Create the dynamic script for this step using the method in dscript
        key_name = i  # Use the index &#39;i&#39; as the key in TEMPLATE
        content = script.TEMPLATE

        # Use the helper method in dscript to add this dynamic script
        outd.add_dynamic_script(
            key=key_name,
            content=content,
            definitions = lambdaScriptdata(**local_static_updates),
            verbose=self.verbose if verbose is None else verbose,
            userid=self.name[i],
            autorefresh=False # prevent the replacement by default values ${}
        )

        # Set eval=True only if variables are detected in the template
        if outd.TEMPLATE[key_name].detect_variables():
            outd.TEMPLATE[key_name].eval = True

    # Compute the union of all used variables across all steps
    global_used_variables = set().union(*step_used_variables)

    # Filter staticmerged_definitions to keep only variables that are used
    filtered_definitions = {
        var: value for var, value in staticmerged_definitions.items() if var in global_used_variables
    }

    # Assign the filtered definitions along with USER variables to outd.DEFINITIONS
    outd.DEFINITIONS = lambdaScriptdata(**filtered_definitions)

    # Clean the entries for empty templates
    outd.clean(verbose=verbose,behavior=clean)

    return outd</code></pre>
</details>
</dd>
<dt id="group.pipescript.generate_report"><code class="name flex">
<span>def <span class="ident">generate_report</span></span>(<span>self, filename, varnames=None, scopes='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a comprehensive report for specified variables and writes it to a file.</p>
<p>Parameters:
- filename (str): Path to the output report file. Must end with .md, .txt, or .html.
- varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to 'all'.
- scopes (str or list/tuple, optional): 'all', a single scope string, or a list of scope strings. Defaults to 'all'.</p>
<p>Raises:
- ValueError: If 'filename' has an unsupported extension.
- Exception: For other unforeseen errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_report(self, filename, varnames=None, scopes=&#34;all&#34;):
    &#34;&#34;&#34;
    Generates a comprehensive report for specified variables and writes it to a file.

    Parameters:
    - filename (str): Path to the output report file. Must end with .md, .txt, or .html.
    - varnames (str or list/tuple, optional): Variable name(s) to include in the report. Defaults to &#39;all&#39;.
    - scopes (str or list/tuple, optional): &#39;all&#39;, a single scope string, or a list of scope strings. Defaults to &#39;all&#39;.

    Raises:
    - ValueError: If &#39;filename&#39; has an unsupported extension.
    - Exception: For other unforeseen errors.
    &#34;&#34;&#34;
    # Validate filename extension
    _, ext = os.path.splitext(filename)
    ext = ext.lower()

    if ext not in [&#39;.md&#39;, &#39;.txt&#39;, &#39;.html&#39;]:
        raise ValueError(&#34;Unsupported file extension. Supported extensions are .md, .txt, and .html.&#34;)

    # Determine format based on extension
    if ext in [&#39;.md&#39;, &#39;.txt&#39;]:
        export_format = &#39;markdown&#39;
    elif ext == &#39;.html&#39;:
        export_format = &#39;html&#39;

    # Determine variables to include
    if varnames is None or (isinstance(varnames, (list, tuple)) and len(varnames) == 0):
        variables = &#39;all&#39;
    else:
        variables = varnames  # Can be a string or a list/tuple

    # Retrieve VariableOccurrences instances
    if variables == &#39;all&#39;:
        variables_occurrences = self.list_values(varname=None, what=scopes)
    else:
        # Normalize varnames to a list
        if isinstance(variables, str):
            variables = [variables]
        elif isinstance(variables, (list, tuple)):
            variables = list(variables)
        else:
            raise ValueError(&#34;Parameter &#39;varnames&#39; must be a string or a list/tuple of strings.&#34;)

        variables_occurrences = {}
        for var in variables:
            vo = self.list_values(varname=var, what=scopes)
            if vo and var in vo.variables:
                variables_occurrences[var] = vo
            else:
                print(f&#34;Warning: Variable &#39;{var}&#39; not found in the specified scopes.&#34;)

    # Initialize report content
    report_content = &#34;&#34;
    timestamp = datetime.datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)
    caller = &#34;generate_report&#34;

    # Add report header
    if export_format == &#39;markdown&#39;:
        report_content += f&#34;# Comprehensive Variable Report\n\n&#34;
        report_content += f&#34;**Generated on {timestamp} by {caller}**\n\n&#34;
    elif export_format == &#39;html&#39;:
        # Define CSS for HTML
        css = &#34;&#34;&#34;
        &lt;style&gt;
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
            }
            h1, h2, h3, h4, h5 {
                color: #333;
            }
            table {
                border-collapse: collapse;
                width: 100%;
                margin-bottom: 40px;
            }
            th, td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            th {
                background-color: #4CAF50;
                color: white;
            }
            tr:nth-child(even){background-color: #f2f2f2;}
            tr:hover {background-color: #ddd;}
        &lt;/style&gt;
        &#34;&#34;&#34;
        report_content += f&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#39;UTF-8&#39;&gt;\n&lt;title&gt;Comprehensive Variable Report&lt;/title&gt;\n{css}\n&lt;/head&gt;\n&lt;body&gt;\n&#34;
        report_content += f&#34;&lt;h1&gt;Comprehensive Variable Report&lt;/h1&gt;\n&#34;
        report_content += f&#34;&lt;h2&gt;Generated on {timestamp} by {caller}&lt;/h2&gt;\n&#34;

    # Assemble report content using VariableOccurrences.export()
    for var, vo in variables_occurrences.items():
        # Export content without headers and get as string
        var_content = vo.export(filename=filename, # use to identify the format based on its extension
                                scopes=scopes,
                                variables=var,
                                include_headers=False,
                                return_content=True)

        if export_format == &#39;markdown&#39;:
            # Add variable header
            report_content += f&#34;## Variable: `{var}`\n\n&#34;
            report_content += var_content + &#34;\n\n&#34;
            report_content += &#34;---\n\n&#34;  # Horizontal line between variables
        elif export_format == &#39;html&#39;:
            # Add variable header
            report_content += f&#34;&lt;h2&gt;Variable: {var}&lt;/h2&gt;\n&#34;
            report_content += var_content + &#34;\n&lt;hr/&gt;\n&#34;  # Horizontal line between variables

    # Finalize HTML content
    if export_format == &#39;html&#39;:
        report_content += &#34;&lt;/body&gt;\n&lt;/html&gt;&#34;

    # Write report to file
    try:
        with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file:
            file.write(report_content)
        print(f&#34;Report successfully generated at &#39;{filename}&#39;.&#34;)
    except Exception as e:
        raise Exception(f&#34;Failed to write the report to &#39;{filename}&#39;: {e}&#34;)</code></pre>
</details>
</dd>
<dt id="group.pipescript.getUSER"><code class="name flex">
<span>def <span class="ident">getUSER</span></span>(<span>self, idx, key)</span>
</code></dt>
<dd>
<div class="desc"><p>getUSER get USER variable
getUSER(idx,varname)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUSER(self,idx,key):
    &#34;&#34;&#34;
        getUSER get USER variable
        getUSER(idx,varname)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].getattr(key)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="group.pipescript.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>self, verbose=True, verbosity=None, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a formatted header for the pipescript file.</p>
<h2 id="parameters">Parameters</h2>
<p>verbosity (bool, optional): If specified, overrides the instance's <code>verbose</code> setting.
Defaults to the instance's <code>verbose</code>.
style (int from 1 to 6, optional): ASCII style to frame the header (default=4)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A formatted string representing the pipescript object.
Returns an empty string if verbosity is False.</dd>
</dl>
<p>The header includes:
- Total number of scripts in the pipeline.
- The verbosity setting.
- The range of scripts from the first to the last script.
- All enclosed within an ASCII frame that adjusts to the content.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def header(self, verbose=True,verbosity=None, style=4):
    &#34;&#34;&#34;
    Generate a formatted header for the pipescript file.

    Parameters:
        verbosity (bool, optional): If specified, overrides the instance&#39;s `verbose` setting.
                                    Defaults to the instance&#39;s `verbose`.
        style (int from 1 to 6, optional): ASCII style to frame the header (default=4)

    Returns:
        str: A formatted string representing the pipescript object.
             Returns an empty string if verbosity is False.

    The header includes:
        - Total number of scripts in the pipeline.
        - The verbosity setting.
        - The range of scripts from the first to the last script.
        - All enclosed within an ASCII frame that adjusts to the content.
    &#34;&#34;&#34;
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity = 0 if not verbose else verbosity
    if not verbosity:
        return &#34;&#34;

    # Prepare the header content
    lines = [
        f&#34;PIPESCRIPT with {self.n} scripts | Verbosity: {verbosity}&#34;,
        &#34;&#34;,
        f&#34;From: &lt;{str(self.scripts[0])}&gt; To: &lt;{str(self.scripts[-1])}&gt;&#34;,
    ]

    # Use the shared method to format the header
    return frame_header(lines,style=style)</code></pre>
</details>
</dd>
<dt id="group.pipescript.list_multiple_values"><code class="name flex">
<span>def <span class="ident">list_multiple_values</span></span>(<span>self, varnames, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of multiple variables across the pipeline scripts.</p>
<p>Parameters:
- varnames (list): A list of variable names to search for.
- what (str or list/tuple): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- dict: A dictionary mapping each variable name to its VariableOccurrences object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_multiple_values(self, varnames, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of multiple variables across the pipeline scripts.

    Parameters:
    - varnames (list): A list of variable names to search for.
    - what (str or list/tuple): Specifies the scopes to search in.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.

    Returns:
    - dict: A dictionary mapping each variable name to its VariableOccurrences object.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    return self.list_values(varname=varnames, what=what)</code></pre>
</details>
</dd>
<dt id="group.pipescript.list_values"><code class="name flex">
<span>def <span class="ident">list_values</span></span>(<span>self, varname=None, what='all')</span>
</code></dt>
<dd>
<div class="desc"><p>Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.</p>
<p>Parameters:
- varname (str, optional): The name of the variable to search for. If None, all variables are listed.
- what (str or list/tuple, optional): Specifies the scopes to search in.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.</p>
<p>Returns:
- VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
- dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_values(self, varname=None, what=&#34;all&#34;):
    &#34;&#34;&#34;
    Lists all occurrences and values of a specified variable or all variables across the pipeline scripts.

    Parameters:
    - varname (str, optional): The name of the variable to search for. If None, all variables are listed.
    - what (str or list/tuple, optional): Specifies the scopes to search in.
                                         Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                         or a list/tuple of any combination of these.

    Returns:
    - VariableOccurrences: If varname is specified, returns a VariableOccurrences instance for that variable.
    - dict of VariableOccurrences: If varname is None, returns a dictionary mapping each variable name to its VariableOccurrences instance.
    &#34;&#34;&#34;
    # Normalize &#39;what&#39; to a list for uniform processing
    if isinstance(what, str):
        if what.lower() == &#34;all&#34;:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = [what.lower()]
    elif isinstance(what, (list, tuple)):
        scopes_lower = [s.lower() for s in what]
        if &#39;all&#39; in scopes_lower:
            scopes = [&#34;static&#34;, &#34;global&#34;, &#34;local&#34;]
        else:
            scopes = scopes_lower
    else:
        raise ValueError(&#34;Parameter &#39;what&#39; must be a string or a list/tuple of strings.&#34;)

    # Initialize data structures
    if varname:
        # Single variable case
        if len(scopes) == 1:
            data = []
        else:
            data = {}
            for scope in scopes:
                data[scope] = []

        # Iterate over each script in the pipeline
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            # Check each requested scope
            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                if varname in vars_dict.keys():
                    value = getattr(vars_dict,varname)
                    if len(scopes) == 1:
                        data.append((i, value))
                    else:
                        data[scope].append((i, value))

        # Return a VariableOccurrences instance for the specified variable
        return VariableOccurrences(data, variables=varname)

    else:
        # All variables case
        all_vars = set()

        # First, collect all variable names across specified scopes and scripts
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                all_vars.update(vars_dict.keys())

        # Initialize a dictionary to hold VariableOccurrences for each variable
        variables_data = {}
        for var in all_vars:
            var_data = {}
            for scope in scopes:
                var_data[scope] = []
            variables_data[var] = var_data

        # Iterate again to populate the data for each variable
        for i, script in enumerate(self.listscript):
            # Retrieve variables for each scope
            static_vars = self.listUSER[i] if i &lt; len(self.listUSER) else {}
            global_vars = getattr(script, &#39;DEFINITIONS&#39;, {})
            local_vars = getattr(script, &#39;USER&#39;, {})

            scope_vars = {
                &#34;static&#34;: static_vars,
                &#34;global&#34;: global_vars,
                &#34;local&#34;: local_vars
            }

            for scope in scopes:
                vars_dict = scope_vars.get(scope, {})
                for var, value in vars_dict.items():
                    variables_data[var][scope].append((i, value))

        # Convert each variable&#39;s data into a VariableOccurrences instance
        variables_occurrences = {}
        for var, data in variables_data.items():
            variables_occurrences[var] = VariableOccurrences(data, variables=var)

        return variables_occurrences</code></pre>
</details>
</dd>
<dt id="group.pipescript.plot_multiple_value_distributions"><code class="name flex">
<span>def <span class="ident">plot_multiple_value_distributions</span></span>(<span>self, varnames, what='all', separate_plots=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the distribution of elements for multiple variables across specified scopes.</p>
<p>Parameters:
- varnames (list): A list of variable names to plot.
- what (str or list/tuple): Specifies the scopes to include in the plot.
Can be "static", "global", "local", "all",
or a list/tuple of any combination of these.
- separate_plots (bool): If True, plots each variable in a separate subplot.
If False, combines all variables in a single plot for comparison.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_multiple_value_distributions(self, varnames, what=&#34;all&#34;, separate_plots=True):
    &#34;&#34;&#34;
    Plots the distribution of elements for multiple variables across specified scopes.

    Parameters:
    - varnames (list): A list of variable names to plot.
    - what (str or list/tuple): Specifies the scopes to include in the plot.
                                 Can be &#34;static&#34;, &#34;global&#34;, &#34;local&#34;, &#34;all&#34;,
                                 or a list/tuple of any combination of these.
    - separate_plots (bool): If True, plots each variable in a separate subplot.
                             If False, combines all variables in a single plot for comparison.
    &#34;&#34;&#34;
    if not isinstance(varnames, (list, tuple)):
        raise ValueError(&#34;Parameter &#39;varnames&#39; must be a list or tuple of strings.&#34;)

    # Retrieve VariableOccurrences instances
    multiple_vars = self.list_multiple_values(varnames, what=what)

    if separate_plots:
        num_vars = len(multiple_vars)
        fig, axes = plt.subplots(num_vars, 1, figsize=(10, 5 * num_vars))
        if num_vars == 1:
            axes = [axes]  # Make it iterable

        for ax, (var, vo) in zip(axes, multiple_vars.items()):
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                ax.bar(elements, counts, label=scope)
            ax.set_xlabel(&#39;Element&#39;)
            ax.set_ylabel(&#39;Count&#39;)
            ax.set_title(f&#34;Distribution of elements in &#39;{var}&#39;&#34;)
            ax.legend()

        plt.tight_layout()
        plt.show()

    else:
        plt.figure(figsize=(12, 8))
        for var, vo in multiple_vars.items():
            summary = vo.summarize()[var]
            for scope, details in summary.items():
                elements = list(details.get(&#39;unique_elements_in_lists&#39;, []))
                counts = [details[&#39;element_counts_in_lists&#39;][elem] for elem in elements]
                plt.bar([f&#34;{var}_{elem}&#34; for elem in elements], counts, label=f&#34;{var} - {scope}&#34;)

        plt.xlabel(&#39;Element&#39;)
        plt.ylabel(&#39;Count&#39;)
        plt.title(&#34;Distribution of elements in multiple variables&#34;)
        plt.legend()
        plt.xticks(rotation=45, ha=&#39;right&#39;)
        plt.tight_layout()
        plt.show()</code></pre>
</details>
</dd>
<dt id="group.pipescript.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name='', idx=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rename scripts in the pipe
p.rename(idx=[0,2,3],name=["A","B","C"])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(self,name=&#34;&#34;,idx=None):
    &#34;&#34;&#34;
        rename scripts in the pipe
            p.rename(idx=[0,2,3],name=[&#34;A&#34;,&#34;B&#34;,&#34;C&#34;])
    &#34;&#34;&#34;
    if isinstance(name,list):
        if len(name)==len(self) and idx==None:
            self.name = name
        elif len(name) == len(idx):
            for i in range(len(idx)):
                self.rename(name[i],idx[i])
        else:
            IndexError(f&#34;the number of indices {len(idx)} does not match the number of names {len(name)}&#34;)
    elif idx !=None and idx&lt;len(self) and name!=&#34;&#34;:
        self.name[idx] = name
    else:
        raise ValueError(&#34;provide a non empty name and valid index&#34;)</code></pre>
</details>
</dd>
<dt id="group.pipescript.script"><code class="name flex">
<span>def <span class="ident">script</span></span>(<span>self, idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4)</span>
</code></dt>
<dd>
<div class="desc"><p>script the pipeline or parts of the pipeline
s = p.script()
s = p.script([0,2])</p>
<p>Parameters:
- idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
If None, all steps from the current position to
the end are executed. A list of indices can be
provided to execute specific steps, or a single
integer can be passed to execute a specific step.
Default is None.
- printflag (bool, optional): If True, the generated script for each step is printed
to the console. Default is True.
- verbosity (int, optional): Controls the level of detail in the generated script.
- 0: Minimal output, no comments.
- 1: Basic comments for run steps.
- 2: Detailed comments with additional information.
Default is 2.
- forced (bool, optional): If True, all scripts are regenerated
- style (int, optional):
Defines the ASCII frame style for the header.
Valid values are integers from 1 to 6, corresponding to predefined styles:
1. Basic box with <code>+</code>, <code>-</code>, and <code>|</code>
2. Double-line frame with <code></code>, <code></code>, and <code></code>
3. Rounded corners with <code>.</code>, <code>'</code>, <code>-</code>, and <code>|</code>
4. Thick outer frame with <code>#</code>, <code>=</code>, and <code>#</code>
5. Box drawing characters with <code></code>, <code></code>, and <code></code>
6. Minimalist dotted frame with <code>.</code>, <code>:</code>, and <code>.</code>
Default is <code>4</code> (thick outer frame).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def script(self,idx=None, printflag=True, verbosity=2, verbose=None, forced=False, style=4):
    &#34;&#34;&#34;
        script the pipeline or parts of the pipeline
            s = p.script()
            s = p.script([0,2])

    Parameters:
    - idx (list, range, or int, optional): Specifies which steps of the pipeline to execute.
                                           If None, all steps from the current position to
                                           the end are executed. A list of indices can be
                                           provided to execute specific steps, or a single
                                           integer can be passed to execute a specific step.
                                           Default is None.
    - printflag (bool, optional): If True, the generated script for each step is printed
                                  to the console. Default is True.
    - verbosity (int, optional): Controls the level of detail in the generated script.
                                 - 0: Minimal output, no comments.
                                 - 1: Basic comments for run steps.
                                 - 2: Detailed comments with additional information.
                                 Default is 2.
    - forced (bool, optional): If True, all scripts are regenerated
    - style (int, optional):
        Defines the ASCII frame style for the header.
        Valid values are integers from 1 to 6, corresponding to predefined styles:
            1. Basic box with `+`, `-`, and `|`
            2. Double-line frame with ``, ``, and ``
            3. Rounded corners with `.`, `&#39;`, `-`, and `|`
            4. Thick outer frame with `#`, `=`, and `#`
            5. Box drawing characters with ``, ``, and ``
            6. Minimalist dotted frame with `.`, `:`, and `.`
        Default is `4` (thick outer frame).

    &#34;&#34;&#34;
    printflag = self.printflag if printflag is None else printflag
    verbose = verbosity &gt; 0 if verbosity is not None else (self.verbose if verbose is None else verbose)
    verbosity=0 if verbose is False else verbosity
    s = script(printflag=printflag, verbose=verbosity&gt;0)
    s.name = &#34;pipescript&#34;
    s.description = &#34;pipeline with %d scripts&#34; % len(self)
    if len(self)&gt;1:
        s.userid = self.name[0]+&#34;-&gt;&#34;+self.name[-1]
    elif len(self)==1:
        s.userid = self.name[0]
    else:
        s.userid = &#34;empty pipeline&#34;
    s.TEMPLATE = self.header(verbosity=verbosity, style=style) + &#34;\n&#34; +\
        self.do(idx, printflag=printflag, verbosity=verbosity, verbose=verbose, forced=forced)
    s.DEFINITIONS = duplicate(self.globalscript.DEFINITIONS)
    s.USER = duplicate(self.globalscript.USER)
    return s</code></pre>
</details>
</dd>
<dt id="group.pipescript.setUSER"><code class="name flex">
<span>def <span class="ident">setUSER</span></span>(<span>self, idx, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>setUSER sets USER variables
setUSER(idx,varname,varvalue)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUSER(self,idx,key,value):
    &#34;&#34;&#34;
        setUSER sets USER variables
        setUSER(idx,varname,varvalue)
    &#34;&#34;&#34;
    if isinstance(idx,int) and (idx&gt;=0) and (idx&lt;self.n):
        self.listUSER[idx].setattr(key,value)
    else:
        raise IndexError(f&#34;the index in the pipe should be comprised between 0 and {len(self)-1}&#34;)</code></pre>
</details>
</dd>
<dt id="group.pipescript.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, file, printflag=False, verbosity=2, verbose=None, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the combined script to a file.</p>
<h2 id="parameters">Parameters</h2>
<p>file (str): The file path where the script will be saved.
printflag (bool): Flag to enable/disable printing of details.
verbosity (int): Level of verbosity for the script generation.
verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance's verbosity.
overwrite (bool): Whether to overwrite the file if it already exists. Default is False.</p>
<p>Returns:
str: The full absolute path of the file written.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>FileExistsError</code></dt>
<dd>If the file already exists and overwrite is False.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>This method combines the individual scripts within the <code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code> object
and saves the resulting script to the specified file.</li>
<li>If <code>overwrite</code> is False and the file exists, an error is raised.</li>
<li>If <code>verbose</code> is True and the file is overwritten, a warning is displayed.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, file, printflag=False, verbosity=2, verbose=None, overwrite=False):
   &#34;&#34;&#34;
   Write the combined script to a file.

   Parameters:
       file (str): The file path where the script will be saved.
       printflag (bool): Flag to enable/disable printing of details.
       verbosity (int): Level of verbosity for the script generation.
       verbose (bool or None): If True, enables verbose mode; if None, defaults to the instance&#39;s verbosity.
       overwrite (bool): Whether to overwrite the file if it already exists. Default is False.

    Returns:
        str: The full absolute path of the file written.

   Raises:
       FileExistsError: If the file already exists and overwrite is False.

   Notes:
       - This method combines the individual scripts within the `pipescript` object
         and saves the resulting script to the specified file.
       - If `overwrite` is False and the file exists, an error is raised.
       - If `verbose` is True and the file is overwritten, a warning is displayed.
   &#34;&#34;&#34;
   # Generate the combined script
   myscript = self.script(printflag=printflag, verbosity=verbosity, verbose=verbose, forced=True)
   # Call the script&#39;s write method with the overwrite parameter
   return myscript.write(file, printflag=printflag, verbose=verbose, overwrite=overwrite)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="group.format_table" href="#group.format_table">format_table</a></code></li>
<li><code><a title="group.generate_random_name" href="#group.generate_random_name">generate_random_name</a></code></li>
<li><code><a title="group.span" href="#group.span">span</a></code></li>
<li><code><a title="group.truncate_text" href="#group.truncate_text">truncate_text</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="group.Operation" href="#group.Operation">Operation</a></code></h4>
<ul class="two-column">
<li><code><a title="group.Operation.append" href="#group.Operation.append">append</a></code></li>
<li><code><a title="group.Operation.extend" href="#group.Operation.extend">extend</a></code></li>
<li><code><a title="group.Operation.generateID" href="#group.Operation.generateID">generateID</a></code></li>
<li><code><a title="group.Operation.generate_hashname" href="#group.Operation.generate_hashname">generate_hashname</a></code></li>
<li><code><a title="group.Operation.get_proper_operand" href="#group.Operation.get_proper_operand">get_proper_operand</a></code></li>
<li><code><a title="group.Operation.is_empty" href="#group.Operation.is_empty">is_empty</a></code></li>
<li><code><a title="group.Operation.is_unary" href="#group.Operation.is_unary">is_unary</a></code></li>
<li><code><a title="group.Operation.isfinalized" href="#group.Operation.isfinalized">isfinalized</a></code></li>
<li><code><a title="group.Operation.script" href="#group.Operation.script">script</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="group.dscript" href="#group.dscript">dscript</a></code></h4>
<ul class="">
<li><code><a title="group.dscript.add_dynamic_script" href="#group.dscript.add_dynamic_script">add_dynamic_script</a></code></li>
<li><code><a title="group.dscript.check_all_variables" href="#group.dscript.check_all_variables">check_all_variables</a></code></li>
<li><code><a title="group.dscript.clean" href="#group.dscript.clean">clean</a></code></li>
<li><code><a title="group.dscript.construction_attributes" href="#group.dscript.construction_attributes">construction_attributes</a></code></li>
<li><code><a title="group.dscript.createEmptyVariables" href="#group.dscript.createEmptyVariables">createEmptyVariables</a></code></li>
<li><code><a title="group.dscript.detect_all_variables" href="#group.dscript.detect_all_variables">detect_all_variables</a></code></li>
<li><code><a title="group.dscript.do" href="#group.dscript.do">do</a></code></li>
<li><code><a title="group.dscript.flattenvariables" href="#group.dscript.flattenvariables">flattenvariables</a></code></li>
<li><code><a title="group.dscript.generator" href="#group.dscript.generator">generator</a></code></li>
<li><code><a title="group.dscript.get_attributes_by_index" href="#group.dscript.get_attributes_by_index">get_attributes_by_index</a></code></li>
<li><code><a title="group.dscript.get_content_by_index" href="#group.dscript.get_content_by_index">get_content_by_index</a></code></li>
<li><code><a title="group.dscript.header" href="#group.dscript.header">header</a></code></li>
<li><code><a title="group.dscript.items" href="#group.dscript.items">items</a></code></li>
<li><code><a title="group.dscript.keys" href="#group.dscript.keys">keys</a></code></li>
<li><code><a title="group.dscript.list_values" href="#group.dscript.list_values">list_values</a></code></li>
<li><code><a title="group.dscript.load" href="#group.dscript.load">load</a></code></li>
<li><code><a title="group.dscript.parsesyntax" href="#group.dscript.parsesyntax">parsesyntax</a></code></li>
<li><code><a title="group.dscript.parsesyntax_legacy" href="#group.dscript.parsesyntax_legacy">parsesyntax_legacy</a></code></li>
<li><code><a title="group.dscript.pipescript" href="#group.dscript.pipescript">pipescript</a></code></li>
<li><code><a title="group.dscript.print_var_info" href="#group.dscript.print_var_info">print_var_info</a></code></li>
<li><code><a title="group.dscript.reorder" href="#group.dscript.reorder">reorder</a></code></li>
<li><code><a title="group.dscript.save" href="#group.dscript.save">save</a></code></li>
<li><code><a title="group.dscript.script" href="#group.dscript.script">script</a></code></li>
<li><code><a title="group.dscript.search" href="#group.dscript.search">search</a></code></li>
<li><code><a title="group.dscript.set_all_variables" href="#group.dscript.set_all_variables">set_all_variables</a></code></li>
<li><code><a title="group.dscript.values" href="#group.dscript.values">values</a></code></li>
<li><code><a title="group.dscript.var_info" href="#group.dscript.var_info">var_info</a></code></li>
<li><code><a title="group.dscript.write" href="#group.dscript.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="group.group" href="#group.group">group</a></code></h4>
<ul class="">
<li><code><a title="group.group.add_group_criteria" href="#group.group.add_group_criteria">add_group_criteria</a></code></li>
<li><code><a title="group.group.add_group_criteria_single" href="#group.group.add_group_criteria_single">add_group_criteria_single</a></code></li>
<li><code><a title="group.group.add_operation" href="#group.group.add_operation">add_operation</a></code></li>
<li><code><a title="group.group.byid" href="#group.group.byid">byid</a></code></li>
<li><code><a title="group.group.byregion" href="#group.group.byregion">byregion</a></code></li>
<li><code><a title="group.group.bytype" href="#group.group.bytype">bytype</a></code></li>
<li><code><a title="group.group.byvariable" href="#group.group.byvariable">byvariable</a></code></li>
<li><code><a title="group.group.clear" href="#group.group.clear">clear</a></code></li>
<li><code><a title="group.group.clearall" href="#group.group.clearall">clearall</a></code></li>
<li><code><a title="group.group.code" href="#group.group.code">code</a></code></li>
<li><code><a title="group.group.copy" href="#group.group.copy">copy</a></code></li>
<li><code><a title="group.group.count" href="#group.group.count">count</a></code></li>
<li><code><a title="group.group.create" href="#group.group.create">create</a></code></li>
<li><code><a title="group.group.create_groups" href="#group.group.create_groups">create_groups</a></code></li>
<li><code><a title="group.group.delete" href="#group.group.delete">delete</a></code></li>
<li><code><a title="group.group.disp" href="#group.group.disp">disp</a></code></li>
<li><code><a title="group.group.dscript" href="#group.group.dscript">dscript</a></code></li>
<li><code><a title="group.group.evaluate" href="#group.group.evaluate">evaluate</a></code></li>
<li><code><a title="group.group.find" href="#group.group.find">find</a></code></li>
<li><code><a title="group.group.format_cell_content" href="#group.group.format_cell_content">format_cell_content</a></code></li>
<li><code><a title="group.group.generate_group_definitions_from_collection" href="#group.group.generate_group_definitions_from_collection">generate_group_definitions_from_collection</a></code></li>
<li><code><a title="group.group.get_by_name" href="#group.group.get_by_name">get_by_name</a></code></li>
<li><code><a title="group.group.get_group_criteria" href="#group.group.get_group_criteria">get_group_criteria</a></code></li>
<li><code><a title="group.group.intersect" href="#group.group.intersect">intersect</a></code></li>
<li><code><a title="group.group.list" href="#group.group.list">list</a></code></li>
<li><code><a title="group.group.operation_exists" href="#group.group.operation_exists">operation_exists</a></code></li>
<li><code><a title="group.group.pipescript" href="#group.group.pipescript">pipescript</a></code></li>
<li><code><a title="group.group.reindex" href="#group.group.reindex">reindex</a></code></li>
<li><code><a title="group.group.rename" href="#group.group.rename">rename</a></code></li>
<li><code><a title="group.group.script" href="#group.group.script">script</a></code></li>
<li><code><a title="group.group.subtract" href="#group.group.subtract">subtract</a></code></li>
<li><code><a title="group.group.union" href="#group.group.union">union</a></code></li>
<li><code><a title="group.group.variable" href="#group.group.variable">variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="group.groupcollection" href="#group.groupcollection">groupcollection</a></code></h4>
<ul class="">
<li><code><a title="group.groupcollection.append" href="#group.groupcollection.append">append</a></code></li>
<li><code><a title="group.groupcollection.clear" href="#group.groupcollection.clear">clear</a></code></li>
<li><code><a title="group.groupcollection.extend" href="#group.groupcollection.extend">extend</a></code></li>
<li><code><a title="group.groupcollection.mass" href="#group.groupcollection.mass">mass</a></code></li>
<li><code><a title="group.groupcollection.remove" href="#group.groupcollection.remove">remove</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="group.groupobject" href="#group.groupobject">groupobject</a></code></h4>
</li>
<li>
<h4><code><a title="group.pipescript" href="#group.pipescript">pipescript</a></code></h4>
<ul class="">
<li><code><a title="group.pipescript.USER" href="#group.pipescript.USER">USER</a></code></li>
<li><code><a title="group.pipescript.clear" href="#group.pipescript.clear">clear</a></code></li>
<li><code><a title="group.pipescript.do" href="#group.pipescript.do">do</a></code></li>
<li><code><a title="group.pipescript.do_legacy" href="#group.pipescript.do_legacy">do_legacy</a></code></li>
<li><code><a title="group.pipescript.dscript" href="#group.pipescript.dscript">dscript</a></code></li>
<li><code><a title="group.pipescript.generate_report" href="#group.pipescript.generate_report">generate_report</a></code></li>
<li><code><a title="group.pipescript.getUSER" href="#group.pipescript.getUSER">getUSER</a></code></li>
<li><code><a title="group.pipescript.header" href="#group.pipescript.header">header</a></code></li>
<li><code><a title="group.pipescript.join" href="#group.pipescript.join">join</a></code></li>
<li><code><a title="group.pipescript.list_multiple_values" href="#group.pipescript.list_multiple_values">list_multiple_values</a></code></li>
<li><code><a title="group.pipescript.list_values" href="#group.pipescript.list_values">list_values</a></code></li>
<li><code><a title="group.pipescript.n" href="#group.pipescript.n">n</a></code></li>
<li><code><a title="group.pipescript.nrun" href="#group.pipescript.nrun">nrun</a></code></li>
<li><code><a title="group.pipescript.plot_multiple_value_distributions" href="#group.pipescript.plot_multiple_value_distributions">plot_multiple_value_distributions</a></code></li>
<li><code><a title="group.pipescript.rename" href="#group.pipescript.rename">rename</a></code></li>
<li><code><a title="group.pipescript.script" href="#group.pipescript.script">script</a></code></li>
<li><code><a title="group.pipescript.scripts" href="#group.pipescript.scripts">scripts</a></code></li>
<li><code><a title="group.pipescript.setUSER" href="#group.pipescript.setUSER">setUSER</a></code></li>
<li><code><a title="group.pipescript.write" href="#group.pipescript.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>