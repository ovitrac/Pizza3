<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>raster API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>raster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__project__ = &#34;Pizza3&#34;
__author__ = &#34;Olivier Vitrac&#34;
__copyright__ = &#34;Copyright 2022&#34;
__credits__ = [&#34;Olivier Vitrac&#34;]
__license__ = &#34;GPLv3&#34;
__maintainer__ = &#34;Olivier Vitrac&#34;
__email__ = &#34;olivier.vitrac@agroparistech.fr&#34;
__version__ = &#34;0.4&#34;

&#34;&#34;&#34;
    RASTER method to generate LAMMPS input files (in 2D for this version)
    
    Generate a raster area
        R = raster()
        R = raster(width=200, height=200, dpi=300)
        
    Set objects (rectangle, circle, triangle, diamond...)
        R.rectangle(1,24,2,20,name=&#39;rect1&#39;)
        R.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40)
        R.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1)
        R.circle(45,20,5,name=&#39;C1&#39;,beadtype=3)
        R.circle(35,10,5,name=&#39;C2&#39;,beadtype=3)
        
        R.circle(15,30,10,name=&#39;p1&#39;,beadtype=4,shaperatio=0.2,angle=-30)
        R.circle(12,40,8,name=&#39;p2&#39;,beadtype=4,shaperatio=0.2,angle=20)
        R.circle(12,80,22,name=&#39;p3&#39;,beadtype=4,shaperatio=1.3,angle=20)
        
        R.triangle(85,20,10,name=&#39;T1&#39;,beadtype=5,angle=20)
        R.diamond(85,35,5,name=&#39;D1&#39;,beadtype=5,angle=20)
        R.pentagon(50,35,5,name=&#39;P1&#39;,beadtype=5,angle=90)
        R.hexagon(47,85,12,name=&#39;H1&#39;,beadtype=5,angle=90)

    List simple objects
        R.list()
        R.get(&#34;p1&#34;)
        R.p1
        R.C1
        
    List objects in a collection
        R.C1.get(&#34;p1&#34;) 
        R.C1.p1 shows the object p1 in the collection C1

    Build objects and show them 
        R.plot()
        R.show()
        
    Show and manage labels
        R.show(extra=&#34;label&#34;,contour=True)
        R.label(&#34;rect003&#34;)
        R.unlabel(&#39;rect1&#39;)
        
    Manage objects, update and show
    
    Get the image and convert the image to text
        I = R.numeric()
        T = R.string()
        R.print()
        
    Create a pizza.dump3.dump object
        X = R.data()
        X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)
        
        
    Build an emulsion/suspension
        C = raster(width=400,height=400)
        e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
        e.insertion([60,50,40,30,20,15,15,10,8,20,12,8,6,4,11,13],beadtype=1)
        C.scatter(e,name=&#34;emulsion&#34;)
        C.plot()
        C.show()

        
    Build a core-shell dispersion
        D = raster(width=400,height=400)
        cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
        cs.insertion([60,50,40,30,20,15,15,10,8,20,12,8,11,13],beadtype=(1,2),thickness = 4)
        D.scatter(cs,name=&#34;core-shell&#34;)
        D.plot()
        D.show()
        
        
    More advanced features enable object copy, duplication along a path
    Contruction of scattered particles
    See: copyalongpath(), scatter(), emulsion(), coreshell()
    
    Examples follow in the __main__ section
        
&#34;&#34;&#34;

# INRAE\Olivier Vitrac - rev. 2022-04-24
# contact: olivier.vitrac@agroparistech.fr

# History
# 2022-02-05 first alpha version
# 2022-02-06 RC for 2D
# 2022-02-08 add count(), update the display method
# 2022-02-10 add figure(), newfigure(), count()
# 2022-02-11 improve display, add data()
# 2022-02-12 major release, fully compatible with pizza.data3.data
# 2022-02-13 the example (&lt;F5&gt;) has been modified R.plot() should precedes R.list()
# 2022-02-28 update write files for SMD, add scale and center to R.data()
# 2022-03-02 fix data(): xlo and ylow (beads should not overlap the boundary), scale radii, volumes
# 2022-03-20 major update, add collection, duplication, translation, scatter(), emulsion()
# 2022-03-22 update raster to insert customized beadtypes
# 2022-03-23 add coreshell()
# 2022-03-23 fix nattempt, add arc
# 2022-04-01 add maxtype to  raster.data(), e.g. raster.data(maxtype=4)
# 2022-04-08 add beadtype2(alternative beadtype, ratio) to salt objects
# 2022-04-13 descale volume in data() for stability reason
# 2022-04-23 very first overlay implementation (alpha version)
# 2022-04-24 full implementation of overlay (not fully tested yet, intended to behave has a regular object)

# %% Imports and private library
import os
from copy import copy as duplicate
from copy import deepcopy as deepduplicate
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.path as path
import matplotlib.patches as patches
from pizza.data3 import data as data3
from pizza.private.struct import struct
from pizza.private.PIL import Image

def _rotate(x0,y0,xc,yc,angle):
    angle = np.pi * angle / 180.0
    x1 = (x0 - xc)*np.cos(angle) - (y0 - yc)*np.sin(angle) + xc
    y1 = (x0 - xc)*np.sin(angle) + (y0 - yc)*np.cos(angle) + yc
    return x1, y1

def _extents(f):
    halftick = ( f[1] - f[0] ) / 2
    return [f[0] - halftick, f[-1] + halftick]

# wrapper of imagesc (note that the origin is bottom left)
# usage: data = np.random.randn(5,10)
#        imagesc(data)
def imagesc(im,x=None,y=None):
    if x==None: x=np.arange(1,np.shape(im)[1]+1)
    if y==None: y=np.arange(1,np.shape(im)[0]+1)
    plt.imshow(im, extent=_extents(x) + _extents(y), 
               aspect=&#34;auto&#34;, origin=&#34;lower&#34;, interpolation=&#34;none&#34;)

# helper for parametric functions
def linear(xmin=10,ymin=10,xmax=80,ymax=80,n=5,USER=struct()):
    &#34;&#34;&#34;  Equispaced points along a trajectory
            X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)
    &#34;&#34;&#34;
    return np.linspace(xmin,xmax,n), np.linspace(ymin,ymax,n)

def arc(xmin=10,ymin=50,xmax=80,ymax=50,n=5,USER=struct(radius=20,direction=1)):
    &#34;&#34;&#34;  Point distributed along an arc
            X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
                      USER=struct(radius=value,direction=1))
            Use direction to choose the upward +1 or downward -1 circle
        see: https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points
    &#34;&#34;&#34;
    R = 0 if &#34;radius&#34; not in USER else USER.radius
    direction = +1 if &#34;direction&#34; not in USER else USER.direction    
    dx,dy = xmax-xmin, ymax-ymin
    q = np.sqrt(dx**2+dy**2) # distance
    R = max(R,q/2) # radius constraint
    d = np.sqrt(R**2-(q/2)**2) # distance along the mirror line
    xc = (xmin+xmax)/2 - direction * d*dy/q
    yc = (ymin+ymax)/2 + direction * d*dx/q
    thmin,thmax = np.arctan((ymin-yc)/(xmin-xc)), np.arctan((ymax-yc)/(xmax-xc))
    if d==0: thmax = thmin + np.pi
    th = np.linspace(thmin,thmax,n)
    return xc+np.cos(th)*R,yc+np.sin(th)*R

# %% raster class
class raster:
    &#34;&#34;&#34; raster class for LAMMPS SMD 
    
    Constructor
    
        R = raster(width=100,height=100...)

        Extra properties
            dpi, fontsize
        
        additional properties for R.data()
            scale, center : full scaling
            mass, volume, radius, contactradius, velocities, forces: bead scaling
            filename
        
        List of available properties: default values
        
                   name: &#34;default raster&#34;
                  width: 100
                 height: 100
                    dpi: 200
               fontsize: 10
                   mass: 1
                 volume: 1
                 radius: 1.5
          contactradius: 0.5
             velocities: [0, 0, 0]
                 forces: [0, 0, 0]
               filename: [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
    
    Graphical objects
        
        R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
        R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        R.triangle(...)
        R.diamond(...)
        R.pentagon(...)
        R.hexagon(...)
        
        R.overlay(xleft,xright,filename==&#34;valid/image.ext&#34;,color=2,beadtype=1) 
        
        note: use fake=True to generate an object without inserting it
        
        R.collection(...) generates collection of existing or fake objects
        R.object.copy(...) enables to copy an object
        
    Display methods (precedence affects the result)
        R.plot()
        R.show(), R.show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34; or &#34;objindex&#34;)
        R.show(extra=&#34;labels&#34;)
        R.list()
        R.get(&#34;object&#34;)
        R.print()
        R.label(&#34;object&#34;)
        R.unlabel(&#34;object&#34;)
        R.figure()
        R.newfigure(dpi=300)
        
        R.numeric()
        R.string(), R.string(what=&#34;beadtype&#34; or &#34;objindex&#34;))
        R.names()
        R.print()
        
    Clear and delete
        R.clear()
        R.clear(&#34;all&#34;)
        R.delete(&#34;object&#34;)

    Copy objects
        R.copyalongpath(....)
        R.scatter()

    Generate an input data object
        X = R.data() or X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)
    
    &#34;&#34;&#34;
    
    # CONSTRUCTOR ---------------------------- 
    def __init__(self,
                 # raster properties
                 name=&#34;default raster&#34;,
                 width=100,
                 height=100,
                 # printing and display
                 dpi=200,
                 fontsize=10,
                 # for data conversion
                 mass=1,
                 volume=1,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0,0,0],
                 forces=[0,0,0],
                 filename=&#34;&#34;
                 ):
        
        &#34;&#34;&#34; initialize raster &#34;&#34;&#34;
        self.name = name
        self.width = width
        self.height = height
        self.xcenter= width/2
        self.ycenter = height/2
        self.objects = {}
        self.nobjects = 0    # total number of objects (alive)
        self.nbeads = 0
        self.counter = { &#34;triangle&#34;:0,
                          &#34;diamond&#34;:0,
                        &#34;rectangle&#34;:0,
                         &#34;pentagon&#34;:0,
                          &#34;hexagon&#34;:0,
                           &#34;circle&#34;:0,
                          &#34;overlay&#34;:0,
                       &#34;collection&#34;:0,
                              &#34;all&#34;:0
                    }
        self.fontsize = 10   # font size for labels
        self.imbead = np.zeros((height,width),dtype=np.int8)
        self.imobj = np.zeros((height,width),dtype=np.int8)
        self.hfig = [] # figure handle
        self.dpi = dpi
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces =forces
        
        if filename == &#34;&#34;:
            self.filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
        else:
            self.filename = filename
        

    # DATA ---------------------------- 
    def data(self,scale=(1,1),center=(0,0),maxtype=None):
        &#34;&#34;&#34;
        data()
        data(scale=(scalex,scaley),center=(centerx,centery),maxtype=number)
        return a pizza.data object  &#34;&#34;&#34;
        if not isinstance(scale,tuple) or len(scale)!=2:
            raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
        if not isinstance(center,tuple) or len(scale)!=2:
            raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
        scalez = np.sqrt(scale[0]*scale[1])
        scalevol = scale[0]*scale[1] #*scalez
        maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
        n = self.length()
        i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
        X = data3()  # empty pizza.data3.data object
        X.title = self.name + &#34;(raster)&#34;
        X.headers = {&#39;atoms&#39;: n,
                      &#39;atom types&#39;: maxtypeheader,
                      &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                      &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                      &#39;zlo zhi&#39;: (0, scalez)}
        # [ATOMS] section
        X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
        X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
        X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
        X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
        X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
        X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
        X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
        X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x&#34;)        # x
        X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y&#34;)        # y
        X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)                                 # z
        X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x0&#34;)       # x0
        X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y0&#34;)       # y0
        X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)                                # z0
        # [VELOCITIES] section
        X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
        X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
        X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
        X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
        # pseudo-filename        
        X.flist = self.filename
        return X
     
    # LENGTH ---------------------------- 
    def length(self,t=None,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = self.imbead
        elif what == &#34;objindex&#34;:
            num = self.imobj
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if t==None:
            return np.count_nonzero(num&gt;0)
        else:
            return np.count_nonzero(num==t)
        
    # NUMERIC ---------------------------- 
    def numeric(self):
        &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
        return self.imbead, self.imobj

    # STRING ---------------------------- 
    def string(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = np.flipud(duplicate(self.imbead))
        elif what == &#34;objindex&#34;:
            num = np.flipud(duplicate(self.imobj))
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        num[num&gt;0] = num[num&gt;0] + 65
        num[num==0] = 32
        num = list(num)
        return [&#34;&#34;.join(map(chr,x)) for x in num]
        
    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)
        
    # CLEAR ---------------------------- 
    def clear(self,what=&#34;nothing&#34;):
        &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
        self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
        self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
        for o in self.names():
            if what==&#34;all&#34;:
                self.delete(o)
            else:
                self.objects[o].isplotted = False
                self.objects[o].islabelled = False
                if not self.objects[o].ismask:
                    self.nbeads -= self.objects[o].nbeads
                self.objects[o].nbeads = 0  # number of beads (plotted)
        self.figure()
        plt.cla()
        self.show()

    # DISP method ---------------------------- 
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        ctyp = self.count() # count objects (not beads)
        print(&#34;-&#34;*40)
        print(&#39;RASTER area &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        print(&#34;-&#34;*40)
        print(&#34;&lt;- grid size -&gt;&#34;)
        print(&#34;\twidth: %d&#34; % self.width)
        print(&#34;\theight: %d&#34; % self.height)
        print(&#34;&lt;- bead types -&gt;&#34;)
        nbt = 0
        if len(ctyp):
            for i,c in enumerate(ctyp):
                nb = self.length(c[0])
                nbt += nb
                print(&#34;\t type=%d (%d objects, %d beads)&#34; % (c[0],c[1],nb))
        else:
            print(&#34;\tno bead assigned&#34;)
        print(&#34;-&#34;*40)
        return &#34;RASTER AREA %d x %d with %d objects (%d types, %d beads).&#34; % \
        (self.width,self.height,self.nobjects,len(ctyp),nbt)

    # count method ---------------------------- 
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # NAMES method ---------------------------- 
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        for iobj in range(nobj):
            namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
        return namessorted
        
    # LIST method ---------------------------- 
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
        print(&#34;RASTER with %d objects&#34; % self.nobjects)
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex,
                       self.objects[o].nbeads))
            
    # EXIST method ---------------------------- 
    def exist(self,name):
        &#34;&#34;&#34; exist object &#34;&#34;&#34;
        return name in self.objects
    
    # DELETE method ---------------------------- 
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects: 
            if not self.objects[name].ismask:
                self.nbeads -= self.objects[name].nbeads
            del self.objects[name]
            self.nobjects -= 1
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        self.clear()
        self.plot()
        self.show(extra=&#34;label&#34;)
        
    # VALID method
    def valid(self,x,y):
        &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
        return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))
    
    # frameobj method
    def frameobj(self,obj):
        &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
        if obj.hasclosefit:
            envelope = 0
        else:
            envelope = 1
        xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
        xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
        return xmin, ymin, xmax, ymax

    # RECTANGLE ----------------------------     
    def rectangle(self,a,b,c,d,
                  mode=&#34;lowerleft&#34;,name=None,angle=0,
                  beadtype=None,ismask=False,fake=False,beadtype2=None):
        &#34;&#34;&#34; 
        rectangle object
            rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
            rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
            
            use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
            from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;rectangle&#34;] += 1
        R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            R.name = name
        else:
            name = R.name
        if beadtype is not None: R.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        R.beadtype2 = beadtype2
        if ismask: R.beadtype = 0
        R.ismask = R.beadtype==0
        # build vertices
        if mode == &#34;lowerleft&#34;:
            R.xcenter0 = (a+b)/2
            R.ycenter0 = (c+d)/2
            R.vertices = [
                _rotate(a,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,c,R.xcenter0,R.ycenter0,angle)
                ] # anti-clockwise, closed (last point repeated)
        elif mode == &#34;center&#34;:
            R.xcenter0 = a
            R.ycenter0 = b
            R.vertices = [
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
                ]
        else:
            raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
        # build path object and range
        R.codes =    [ path.Path.MOVETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.CLOSEPOLY
                    ]
        R.nvertices = len(R.vertices)-1
        R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()        
        R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
        R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
        R.angle = angle
        # store the object (if not fake)
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;rectangle&#34;] -= 1
            return R
        else:
            self.objects[name] = R
            self.nobjects += 1
            return None

        
    # CIRCLE ----------------------------     
    def circle(self,xc,yc,radius,
                  name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
                  resolution=20,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34; 
        circle object (or any regular polygon)
            circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
            use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        if resolution==3:
            typ = &#34;triangle&#34;
            self.counter[&#34;triangle&#34;] += 1
            G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
        elif resolution==4:
            typ = &#34;diamond&#34;
            self.counter[&#34;diamond&#34;] += 1
            G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
        elif resolution==5:
            typ = &#34;pentagon&#34;
            self.counter[&#34;pentagon&#34;] += 1
            G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
        elif resolution==6:
            typ = &#34;hexagon&#34;
            self.counter[&#34;hexagon&#34;] += 1
            G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
        else:
            typ = &#34;circle&#34;
            self.counter[&#34;circle&#34;] += 1
            G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            G.name = name
        else:
            name = G.name
        if beadtype is not None: G.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        G.beadtype2 = beadtype2
        if ismask: G.beadtype = 0
        G.ismask = G.beadtype==0
        # build vertices
        th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
        xgen = xc + radius * np.cos(th)
        ygen = yc + radius * shaperatio * np.sin(th)
        G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
        G.vertices, G.codes = [], []
        for i in range(G.resolution+1):
            G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
            if i==0:
                G.codes.append(path.Path.MOVETO)
            elif i==G.resolution:
                G.codes.append(path.Path.CLOSEPOLY)        
            else:
                G.codes.append(path.Path.LINETO)
        G.nvertices = len(G.vertices)-1
        # build path object and range
        G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
        G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
        G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
        G.angle, G.shaperatio = angle, shaperatio
        # store the object
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[typ] -= 1
            return G
        else:
            self.objects[name] = G
            self.nobjects += 1
            return None
 
    # OVERLAY -------------------------------
    def overlay(self,x0,y0,
                name = None,
                filename = None,
                color = 1,
                colormax = None,
                ncolors = 4,
                beadtype = None,
                beadtype2 = None,
                ismask = False,
                fake = False
                ):
        &#34;&#34;&#34;
            overlay object: made from an image converted to nc colors
            the object is made from the level ranged between ic and jc (bounds included)
            note: if palette found, no conversion is applied
            
            O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
            O = overlay(....ismask=False,fake=False)
            
            Outputs:
                O.original original image (PIL)
                O.raw image converted to ncolors if needed
            
        &#34;&#34;&#34;
        if filename is None or filename==&#34;&#34;:
            raise ValueError(&#34;filename is required (valid image)&#34;)
        O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                    filename = filename,
                    xmin = x0,
                    ymin = y0,
                    ncolors = ncolors
                    )
        O.select(color=color, colormax=colormax)
        if (name is not None) and (name !=&#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            O.name = name
        else:
            name = O.name
        if beadtype is not None: O.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        O.beadtype2 = beadtype2
        if ismask: O.beadtype = 0
        O.ismask = O.beadtype==0
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;overlay&#34;] += 1
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;overlay&#34;] -= 1
            return O
        else:
            self.objects[name] = O
            self.nobjects += 1
            return None      
    
    
    # COLLECTION ----------------------------
    def collection(self,*obj,
                   name=None,
                   beadtype=None,
                   ismask=None,
                   translate = [0.0,0.0],
                   fake = False,
                   **kwobj):
        &#34;&#34;&#34;
            collection of objects:
                collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
                collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
        &#34;&#34;&#34; 
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;collection&#34;] += 1
        C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
        # name
        if name != None:
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            C.name = name
        else:
            name = C.name
        # build the collection
        C.collection = collection(*obj,**kwobj)
        xmin = ymin = +1e99
        xmax = ymax = -1e99
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            tmp.translate[0] += translate[0]
            tmp.translate[1] += translate[1]
            xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
            ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
            if beadtype != None: tmp.beadtype = beadtype
            if ismask != None: tmp.ismask = ismask
            C.collection.setattr(o,tmp)
        C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
        C.width, C.height = xmax-xmin, ymax-ymin
        if fake:
            return C
        else:
            self.objects[name] = C
            self.nobjects += 1
            return None
    
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # =========== pseudo methods connected to circle() ===========
    # TRIANGLE, DIAMOND, PENTAGON, HEXAGON, -----------------------     
    def triangle(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        triangle object 
            triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
           angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def diamond(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        diamond object 
            diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def pentagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        pentagon object 
            pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def hexagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        hexagon object 
            hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # label method ---------------------------- 
    def label(self,name,**fmt):
        &#34;&#34;&#34;
            label:
                label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        self.figure()
        if name in self.objects:
            if not self.objects[name].islabelled:
                if self.objects[name].alike == &#34;mixed&#34;:
                    for o in self.objects[name].collection:
                        self.labelobj(o,**fmt)
                else:
                    self.labelobj(self.objects[name],**fmt)
                plt.show()
                self.objects[name].islabelled = True
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
            
    # label object method -----------------------------
    def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
        &#34;&#34;&#34;
            labelobj:
                labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        if contour: contour = obj.hascontour # e.g. overlays do not have contour
        
        if contour:
            patch = patches.PathPatch(obj.polygon2plot,
                                      facecolor=facecolor,
                                      edgecolor=edgecolor,
                                      lw=linewidth)
            obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
        else:
            obj.hlabel[&#34;contour&#34;] = None
        obj.hlabel[&#34;text&#34;] = \
        plt.text(obj.xcenter,
                 obj.ycenter,
                 &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
                 horizontalalignment = &#34;center&#34;,
                 verticalalignment = &#34;center_baseline&#34;,
                 fontsize=self.fontsize
                 )
        
   
    def unlabel(self,name):
        &#34;&#34;&#34; unlabel &#34;&#34;&#34;
        if name in self.objects:
            if  self.objects[name].islabelled:
                self.objects[name].hlabel[&#34;contour&#34;].remove()
                self.objects[name].hlabel[&#34;text&#34;].remove()
                self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
                self.objects[name].islabelled = False
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        

    # PLOT method ---------------------------- 
    def plot(self):
        &#34;&#34;&#34; plot &#34;&#34;&#34;
        for o in self.objects:
            if not self.objects[o].isplotted:
                if self.objects[o].alike == &#34;mixed&#34;:
                    for o2 in self.objects[o].collection:
                        self.plotobj(o2)    
                else:
                    self.plotobj(self.objects[o])
                # store it as plotted
                self.objects[o].isplotted = True
                if not self.objects[o].ismask:
                    self.nbeads += self.objects[o].nbeads


    # PLOTobj method  -----------------------
    def plotobj(self,obj):
        &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
        if obj.alike == &#34;circle&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.polygon.contains_points(points)
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
                            
        elif obj.alike == &#34;overlay&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.select()
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        else:
            raise ValueError(&#34;This object type is notimplemented&#34;)        

    # SHOW method ---------------------------- 
    def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
        self.figure()
        if what==&#34;beadtype&#34;:
            imagesc(self.imbead)
        elif what == &#34;objindex&#34;:
            imagesc(self.imobj)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)        
        if extra == &#34;label&#34;:
            ax = plt.gca()
            for o in self.names():
                if not self.objects[o].ismask:
                    self.label(o,ax=ax,contour=contour)
            ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                      (self.name,self.length(),self.nbeads) )
            plt.show()
            
    # SHOW method ---------------------------- 
    def print(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; print method &#34;&#34;&#34;
        txt = self.string(what=what)
        for i in range(len(txt)):
            print(txt[i],end=&#34;\n&#34;)
         
            
    # FIGURE method ---------------------------- 
    def figure(self):
        &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
        if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
            self.newfigure()
        plt.figure(self.hfig.number)
    
    # NEWFIGURE method ---------------------------- 
    def newfigure(self):
        &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
        self.hfig = plt.figure(dpi=self.dpi)
        
    # COPY OBJECT ALONG a contour -----------------
    def copyalongpath(self,obj,
                      name=&#34;path&#34;,
                  beadtype=None,
                      path=linear,
                      xmin=10,
                      ymin=10,
                      xmax=70,
                      ymax=90,
                         n=7,
                      USER=struct()):
        &#34;&#34;&#34;
        
        The method enable to copy an existing object (from the current raster,
        from another raster or a fake object) amp,g 
        
        Parameters
        ----------
        obj : real or fake object
            the object to be copied.
        name : string, optional
            the name of the object collection. The default is &#34;path&#34;.
        beadtype : integet, optional
            type of bead (can override existing value). The default is None.
        path : function, optional
            parametric function returning x,y. The default is linear.
            x is between xmin and xmax, and y between ymin, ymax
        xmin : int64 or float, optional
            left x corner position. The default is 10.
        ymin : int64 or float, optional
            bottom y corner position. The default is 10.
        xmax : int64 or float, optional
            right x corner position. The default is 70.
        ymax : int64 or float, optional
            top y corner position. The default is 90.
        n : integet, optional
            number of copies. The default is 7.
     USER : structure to pass specific parameters

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not isinstance(USER,struct):
            raise TypeError(&#34;USER should be a structure&#34;)
        x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
        btyp = obj.beadtype if beadtype == None else beadtype
        collect = {}
        for i in range(n):
            nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
            x[i], y[i] = self.valid(x[i], y[i])
            translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
            collect[nameobj] = obj.copy(translate=translate,
                                        name=nameobj,
                                        beadtype=btyp)
        self.collection(**collect,name=name)
     

    # SCATTER -------------------------------
    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ismask = False
                 ):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.
        ismask : logical, optional
            Set it to true to force a mask. The default is False.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                            name=nameobj,beadtype=b,ismask=ismask,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)
            
            
# %% PRIVATE SUB-CLASSES
# Use the equivalent methods of raster() to call these constructors
#   raster.rectangle, raster.circle, raster.triangle... raster.collection
#
# Two counters are used for automatic naming
#   counter[0] is the overall index (total number of objects created)
#   counter[1] is the index of objects of this type (total number of objects created for this class)
#
#   Overview:
#       genericpolygon --&gt; Rectancle, Circle
#       Circle --&gt; Triangle, Diamond, Pentagon, Hexagon
#       Collection --&gt; graphical object for collections (many properties are dynamic)
#       struct --&gt; collection is the low-level class container of Collection

class coregeometry:
    &#34;&#34;&#34; core geometry object&#34;&#34;&#34;
        
    @property
    def xcenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.xcenter0 + self.translate[0]
    @property
    def ycenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.ycenter0 + self.translate[1]
    @property
    def xmin(self):
        &#34;&#34;&#34; xleft position &#34;&#34;&#34;
        return self.xmin0 + self.translate[0]
    @property
    def xmax(self):
        &#34;&#34;&#34; xright position &#34;&#34;&#34;
        return self.xmax0 + self.translate[0]
    @property
    def ymin(self):
        &#34;&#34;&#34; yleft position &#34;&#34;&#34;
        return self.ymin0 + self.translate[1]
    @property
    def ymax(self):
        &#34;&#34;&#34; yright position &#34;&#34;&#34;
        return self.ymax0 + self.translate[1]
    @property
    def width(self):
        &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
        return self.xmax - self.xmin
    @property
    def height(self):
        &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
        return self.ymax - self.ymin

    def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if translate != None: # applies translation
                dup.translate[0] += translate[0] 
                dup.translate[1] += translate[1]
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)
            

class overlay(coregeometry):
    &#34;&#34;&#34; generic overlay class &#34;&#34;&#34;
    
    hascontour = False
    hasclosefit = True
    
    def __init__(self,
                 counter = (0,0),
                 filename=&#34;./sandbox/image.jpg&#34;,
                 xmin = 0,
                 ymin = 0,
                 ncolors = 4
                 ):
        &#34;&#34;&#34; generate an overlay from file
                overlay(counter=(c1,c2),filename=&#34;this/is/myimage.jpg&#34;,xmin=x0,ymin=y0,colors=4)
        &#34;&#34;&#34;
        self.name = &#34;over%03d&#34; % counter[1]
        self.kind = &#34;overlay&#34;       # kind of object
        self.alike = &#34;overlay&#34;      # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        if not os.path.isfile(filename):
            raise IOError(f&#39;the file &#34;{filename}&#34; does not exist&#39;)
        self.filename = filename
        self.ncolors = ncolors
        self.color = None
        self.colormax = None
        self.original,self.raw,self.im,self.map = self.load()
        self.xmin0 = xmin
        self.ymin0 = ymin
        self.xmax0 = xmin + self.im.shape[1]
        self.ymax0 = ymin + self.im.shape[0]
        self.xcenter0 = (self.xmin+self.xmax)/2
        self.ycenter0 = (self.ymin+self.ymax)/2
        self.angle = 0
        
        
    def select(self,color=None,colormax=None):
        &#34;&#34;&#34; select the color index:
                select(color = c) peeks pixels = c
                select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
        &#34;&#34;&#34;
        if color is None:
            color = self.color
        else:
            self.color = color
        if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
                colormax = self.colormax
        else:
            colormax = self.colormax = color
        if isinstance(color,int) and color&lt;len(self.map):
            S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
            self.nbeads = np.count_nonzero(S)
            return S
        raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))
        
    def load(self):
        &#34;&#34;&#34; load image and process it 
                returns the image, the indexed image and its color map ( la Matlab, such as imread)
                
                note: if the image contains a palette it is used, if not the
                image is converted to an indexed image without dihtering
        &#34;&#34;&#34;
        I = Image.open(self.filename)
        palette = I.getpalette()
        if palette is None:
            J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
            palette = J.getpalette()
        else:
            J = I
        p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
        ncolors = len(p.sum(axis=1).nonzero()[0]);
        if ncolors&lt;self.ncolors:
            print(f&#34;only {ncolors} are available&#34;)
        return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]
    
    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        print(f&#34;\tncolors = {self.ncolors} (selected={self.color})&#34;)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(&#34;note: use the attribute origina,raw to see the raw image&#34;)
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)

        

class genericpolygon(coregeometry):
    &#34;&#34;&#34; generic polygon methods &#34;&#34;&#34;
    
    hascontour = True
    hasclosefit = False

    @property
    def polygon(self):
        &#34;&#34;&#34; 
        R.polygon = path.Path(R.vertices,R.codes,closed=True)
        &#34;&#34;&#34;
        v = self.vertices
        if self.translate != None:
            vtmp = list(map(list,zip(*v)))
            for i in range(len(vtmp[0])):
                vtmp[0][i] += self.translate[0]
                vtmp[1][i] += self.translate[1]
            v = list(zip(*vtmp))
        return path.Path(v,self.codes,closed=True)

    @property
    def polygon2plot(self):
        &#34;&#34;&#34;
        R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
        &#34;&#34;&#34;
        return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)

    def corners(self):
        &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
        return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
               max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]


class Rectangle(genericpolygon):
    &#34;&#34;&#34; Rectangle class &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;rect%03d&#34; % counter[1]
        self.kind = &#34;rectangle&#34;     # kind of object
        self.alike = &#34;circle&#34;       # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        
    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))        
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)
    

class Circle(genericpolygon):
    &#34;&#34;&#34; Circle class &#34;&#34;&#34;
    def __init__(self,counter,resolution=20):
        self.name = &#34;circ%03d&#34; % counter[1]
        self.kind = &#34;circle&#34;         # kind of object
        self.alike = &#34;circle&#34;        # similar object for plotting
        self.resolution = resolution # default resolution
        self.beadtype = 1            # bead type
        self.beadtype2 = None        # bead type 2 (alternative beadtype, ratio)        
        self.nbeads = 0              # number of beads
        self.ismask = False          # True if beadtype == 0
        self.isplotted = False       # True if plotted
        self.islabelled = False      # True if labelled
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]   # modification used when an object is duplicated

        
    def __repr__(self):
        &#34;&#34;&#34; display circle &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name,self.kind) )
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tradius = %0.4g&#34; % self.radius)
        print(&#34;\tshaperatio = %0.4g&#34; % self.shaperatio)
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))        
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind, self.name,self.beadtype)

class Triangle(Circle):
    &#34;&#34;&#34; Triangle class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=3)
        self.name = &#34;tri%03d&#34; % counter[1]
        self.kind = &#34;triangle&#34;     # kind of object


class Diamond(Circle):
    &#34;&#34;&#34; Diamond class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=4)
        self.name = &#34;diam%03d&#34; % counter[1]
        self.kind = &#34;diamond&#34;     # kind of object


class Pentagon(Circle):
    &#34;&#34;&#34; Pentagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=5)
        self.name = &#34;penta%03d&#34; % counter[1]
        self.kind = &#34;pentagon&#34;     # kind of object


class Hexagon(Circle):
    &#34;&#34;&#34; Hexagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=6)
        self.name = &#34;hex%03d&#34; % counter[1]
        self.kind = &#34;Hexagon&#34;     # kind of object
        
class collection(struct):
    &#34;&#34;&#34; collection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,raster):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())

class Collection:
    &#34;&#34;&#34; Collection object &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;collect%03d&#34; % counter[1]
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.collection = collection()
        self.translate = [0.0,0.0]
        
    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(line)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % self.xycenter)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(line,&#39;  name: type &#34;original name&#34; [centerx centery] [translatex translatey]&#39;,line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,
                  &#34;[%0.4g %0.4g]&#34; % (value.xcenter,value.ycenter),
                  &#34;[%0.4g %0.4g]&#34; % (value.translate[0],value.translate[1]))
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)
    
    @property
    def xycenter(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
        sx = sy = 0
        n = len(self.collection)
        for o in self.collection:
            sx += o.xcenter
            sy += o.ycenter
        return sx/n, sy/n
    
    @property
    def xcenter(self):
        &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
        xc,_ = self.xycenter
        
    @property
    def ycenter(self):
        &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
        _,yc = self.xycenter
        
    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b
        

# %% scatter class and emulsion class
#    Simplified scatter and emulsion generator

class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y, size r (radius) and beadtype.
        
        The class is used to derive emulsions.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.x = np.array([],dtype=int) 
        self.y = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []
        
    @property
    def n(self):
        return len(self.x)
    
    def pairdist(self,x,y):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)


class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;
    
    def __init__(self, xmin=10, ymin=10, xmax=90, ymax=90, 
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax = xmin, xmax, ymin, ymax
        self.lastinsertion = (None,None,None,None) # x,y,r, beadtype
        self.width = xmax-xmin
        self.height = ymax-ymin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}&#34;)        
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;

        
    def walldist(self,x,y):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))

    def dist(self,x,y):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))
    
    def accepted(self,x,y,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y)&gt;r
    
    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
                np.round(np.random.uniform(low=self.ymin,high=self.ymax))
                
    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype
     
    def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None)
        if r==None:
            r = 0.02*np.sqrt(self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess

    
class coreshell(emulsion):
    &#34;&#34;&#34;
        coreshell generator
            inherited from emulsion
            the method insertion has been modified to integrate
                thickess = shell thickness value
                beadtype = (shell beadtype, core beadtype)
    &#34;&#34;&#34;       

    def insertion(self,rlist,thickness=None, beadtype=(1,2)):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(...)
                
                List of properties
                    rlist = [r1, r2,...]
                    thickness = shell thcikness value
                    beadtype = (shell beadtype, core beadtype)
        &#34;&#34;&#34;
        # check arguments
        if thickness==None:
            raise AttributeError(&#34;set a value for the shell thickness&#34;)
        if not isinstance(beadtype,tuple):
            raise TypeError(&#34;beadtype must be a turple&#34;)
        # prepare the work
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            # next insertion and check rcore
            n += 1
            rshell = rlist[n-1]
            rcore = rshell - thickness
            if rcore&lt;=0:
                raise ValueError( 
 f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
            # do the insertion of the shell (largest radius)
            success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
            if success: 
                success = self.insertone(
                    x = self.lastinsertion[0],
                    y = self.lastinsertion[1],
                    r=rcore,
                    beadtype=beadtype[1],
                    overlap=True)
                nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess

# %% debug section - generic code to test methods (press F5)
# ===================================================   
# main()
# ===================================================   
# for debugging purposes (code called as a script)
# the code is called from here
# ===================================================
if __name__ == &#39;__main__&#39;:   

# %% basic example

    plt.close(&#34;all&#34;)
    R = raster()
    R.rectangle(1,24,2,20,name=&#39;rect1&#39;)
    R.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40,beadtype2=(9,0.2))
    R.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1)
    R.circle(45,20,5,name=&#39;C1&#39;,beadtype=3,beadtype2=(8,0.25))
    R.circle(35,10,5,name=&#39;C2&#39;,beadtype=3)
    
    R.circle(15,30,10,name=&#39;p1&#39;,beadtype=4,shaperatio=0.2,angle=-30)
    R.circle(12,40,8,name=&#39;p2&#39;,beadtype=4,shaperatio=0.2,angle=20)
    R.circle(12,80,22,name=&#39;p3&#39;,beadtype=4,shaperatio=1.3,angle=20,beadtype2=(9,0.1))
    
    R.triangle(85,20,10,name=&#39;T1&#39;,beadtype=5,angle=20)
    R.diamond(85,35,5,name=&#39;D1&#39;,beadtype=5,angle=20,beadtype2=(9,0.5))
    R.pentagon(50,35,5,name=&#39;P1&#39;,beadtype=5,angle=90)
    R.hexagon(47,85,12,name=&#39;H1&#39;,beadtype=5,angle=90)
    
    R.label(&#34;rect003&#34;)
    R.plot()
    R.list()
    R.show()
    
    R.clear()
    R.show()
    R.plot()
    R.show(extra=&#34;label&#34;)
    R.label(&#34;rect003&#34;)
    R.unlabel(&#39;rect1&#39;)
    
    X=R.data()
    
# %% another example    
    S = raster(width=1000,height=1000)
    S.rectangle(150,850,850,1000,name=&#34;top&#34;,beadtype=1)
    S.rectangle(150,850,0,150,name=&#34;bottom&#34;,beadtype=2)
    S.circle(500,500,480,name=&#34;mask&#34;,ismask=True,resolution=500)
    S.triangle(250,880,80,name=&#39;tooth1&#39;,angle=60,beadtype=1)
    S.triangle(750,880,80,name=&#39;tooth2&#39;,angle=-0,beadtype=1)
    S.circle(500,200,300,name=&#34;tongue&#34;,beadtype=5,shaperatio=0.3,resolution=300)
    S.rectangle(500,450,320,320,name=&#34;food&#34;,mode=&#34;center&#34;,beadtype=3)
    S.plot()
    S.show(extra=&#34;label&#34;,contour=False)
    

    
# %% advanced example
    #plt.close(&#34;all&#34;)
    draft = raster()
    draft.rectangle(1,24,2,20,name=&#39;rect1&#39;),
    draft.rectangle(60,80,50,81,name=&#39;rect2&#39;,beadtype=2,angle=40),
    draft.rectangle(50,50,10,10,mode=&#34;center&#34;,angle=45,beadtype=1),
    draft.circle(45,20,5,name=&#39;C1&#39;,beadtype=3),
    draft.circle(35,10,5,name=&#39;C2&#39;,beadtype=3),
    draft.circle(10,10,2,name=&#34;X&#34;,beadtype=4)

    A = raster()
    A.collection(draft,name=&#34;C1&#34;,beadtype=1,translate=[10,30])
    A.__repr__()
    A.objects
    A.plot()
    A.show(extra=&#34;label&#34;)
    A.objects
    
    B = raster()
    #B.collection(X=draft.X,beadtype=1,translate=[50,50])
    B.copyalongpath(draft.X,name=&#34;PX&#34;,beadtype=2,
                    path=arc,
                     xmin=10,
                     ymin=10,
                     xmax=90,
                     ymax=50,
                        n=12)
    B.plot()
    B.show(extra=&#34;label&#34;)
    
    
# %% emulsion example
    C = raster(width=400,height=400)
    e = emulsion(xmin=10, ymin=10, xmax=390, ymax=390)
    e.insertion([60,50,40,30,20,15,15,10,8,20,12,8,6,4,11,13],beadtype=1)
    e.insertion([30,10,20,2,4,5,5,10,12,20,25,12,14,16,17],beadtype=2)
    e.insertion([40,2,8,6,6,5,5,2,3,4,4,4,4,4,10,16,12,14,13],beadtype=3)
    C.scatter(e,name=&#34;emulsion&#34;)
    C.plot()
    C.show()

    
# %% core-shell example
    D = raster(width=400,height=400)
    cs = coreshell(xmin=10, ymin=10, xmax=390, ymax=390)
    cs.insertion([60,50,40,30,20,15,15,10,8,20,12,8,11,13],beadtype=(1,2),thickness = 4)
    D.scatter(cs,name=&#34;core-shell&#34;)
    D.plot()
    D.show()
    
# %% overlay example
    I = raster(width=600,height=600)
    I.overlay(100,100,name=&#34;pix0&#34;,filename=&#34;../sandbox/image.jpg&#34;,ncolors=4,color=0,beadtype=1)
    I.overlay(100,100,name=&#34;pix2&#34;,filename=&#34;../sandbox/image.jpg&#34;,ncolors=4,color=2,beadtype=2)
    I.label(&#34;pix0&#34;)
    I.plot()
    I.show(extra=&#34;label&#34;)
    I.pix0.original
    I.pix0.raw</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="raster.arc"><code class="name flex">
<span>def <span class="ident">arc</span></span>(<span>xmin=10, ymin=50, xmax=80, ymax=50, n=5, USER=structure (struct object) with 2 fields)</span>
</code></dt>
<dd>
<div class="desc"><p>Point distributed along an arc
X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
USER=struct(radius=value,direction=1))
Use direction to choose the upward +1 or downward -1 circle
see: <a href="https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points">https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arc(xmin=10,ymin=50,xmax=80,ymax=50,n=5,USER=struct(radius=20,direction=1)):
    &#34;&#34;&#34;  Point distributed along an arc
            X,Y = arc(xmin=value,ymin=value,xmax=value,ymax=value,n=int,
                      USER=struct(radius=value,direction=1))
            Use direction to choose the upward +1 or downward -1 circle
        see: https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points
    &#34;&#34;&#34;
    R = 0 if &#34;radius&#34; not in USER else USER.radius
    direction = +1 if &#34;direction&#34; not in USER else USER.direction    
    dx,dy = xmax-xmin, ymax-ymin
    q = np.sqrt(dx**2+dy**2) # distance
    R = max(R,q/2) # radius constraint
    d = np.sqrt(R**2-(q/2)**2) # distance along the mirror line
    xc = (xmin+xmax)/2 - direction * d*dy/q
    yc = (ymin+ymax)/2 + direction * d*dx/q
    thmin,thmax = np.arctan((ymin-yc)/(xmin-xc)), np.arctan((ymax-yc)/(xmax-xc))
    if d==0: thmax = thmin + np.pi
    th = np.linspace(thmin,thmax,n)
    return xc+np.cos(th)*R,yc+np.sin(th)*R</code></pre>
</details>
</dd>
<dt id="raster.imagesc"><code class="name flex">
<span>def <span class="ident">imagesc</span></span>(<span>im, x=None, y=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imagesc(im,x=None,y=None):
    if x==None: x=np.arange(1,np.shape(im)[1]+1)
    if y==None: y=np.arange(1,np.shape(im)[0]+1)
    plt.imshow(im, extent=_extents(x) + _extents(y), 
               aspect=&#34;auto&#34;, origin=&#34;lower&#34;, interpolation=&#34;none&#34;)</code></pre>
</details>
</dd>
<dt id="raster.linear"><code class="name flex">
<span>def <span class="ident">linear</span></span>(<span>xmin=10, ymin=10, xmax=80, ymax=80, n=5, USER=empty structure)</span>
</code></dt>
<dd>
<div class="desc"><p>Equispaced points along a trajectory
X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear(xmin=10,ymin=10,xmax=80,ymax=80,n=5,USER=struct()):
    &#34;&#34;&#34;  Equispaced points along a trajectory
            X,Y = linear(xmin=value,ymin=value,xmax=value,ymax=value,n=int)
    &#34;&#34;&#34;
    return np.linspace(xmin,xmax,n), np.linspace(ymin,ymax,n)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="raster.Circle"><code class="flex name class">
<span>class <span class="ident">Circle</span></span>
<span>(</span><span>counter, resolution=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Circle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Circle(genericpolygon):
    &#34;&#34;&#34; Circle class &#34;&#34;&#34;
    def __init__(self,counter,resolution=20):
        self.name = &#34;circ%03d&#34; % counter[1]
        self.kind = &#34;circle&#34;         # kind of object
        self.alike = &#34;circle&#34;        # similar object for plotting
        self.resolution = resolution # default resolution
        self.beadtype = 1            # bead type
        self.beadtype2 = None        # bead type 2 (alternative beadtype, ratio)        
        self.nbeads = 0              # number of beads
        self.ismask = False          # True if beadtype == 0
        self.isplotted = False       # True if plotted
        self.islabelled = False      # True if labelled
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]   # modification used when an object is duplicated

        
    def __repr__(self):
        &#34;&#34;&#34; display circle &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name,self.kind) )
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tradius = %0.4g&#34; % self.radius)
        print(&#34;\tshaperatio = %0.4g&#34; % self.shaperatio)
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))        
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind, self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.Diamond" href="#raster.Diamond">Diamond</a></li>
<li><a title="raster.Hexagon" href="#raster.Hexagon">Hexagon</a></li>
<li><a title="raster.Pentagon" href="#raster.Pentagon">Pentagon</a></li>
<li><a title="raster.Triangle" href="#raster.Triangle">Triangle</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.genericpolygon.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.genericpolygon.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.genericpolygon.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.genericpolygon.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.genericpolygon.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.genericpolygon.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.genericpolygon.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.genericpolygon.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Collection"><code class="flex name class">
<span>class <span class="ident">Collection</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Collection:
    &#34;&#34;&#34; Collection object &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;collect%03d&#34; % counter[1]
        self.kind = &#34;collection&#34;    # kind of object
        self.alike = &#34;mixed&#34;        # similar object for plotting
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.collection = collection()
        self.translate = [0.0,0.0]
        
    def __repr__(self):
        keylengths = [len(key) for key in self.collection.keys()]
        width = max(10,max(keylengths)+2)
        fmt = &#34;%%%ss:&#34; % width
        line = ( fmt % (&#39;-&#39;*(width-2)) ) + ( &#39;-&#39;*(min(40,width*5)) )
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(line)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % self.xycenter)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(line,&#39;  name: type &#34;original name&#34; [centerx centery] [translatex translatey]&#39;,line,sep=&#34;\n&#34;)
        for key,value in self.collection.items():
            print(fmt % key,value.kind,
                  &#39;&#34;%s&#34;&#39; % value.name,
                  &#34;[%0.4g %0.4g]&#34; % (value.xcenter,value.ycenter),
                  &#34;[%0.4g %0.4g]&#34; % (value.translate[0],value.translate[1]))
        print(line)
        return &#34;%s object: %s (beadtype=[%s])&#34; % (self.kind,self.name,&#34;, &#34;.join(map(str,self.beadtype)))

    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.collection:
            return self.collection.getattr(name)
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)
    
    @property
    def xycenter(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
        sx = sy = 0
        n = len(self.collection)
        for o in self.collection:
            sx += o.xcenter
            sy += o.ycenter
        return sx/n, sy/n
    
    @property
    def xcenter(self):
        &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
        xc,_ = self.xycenter
        
    @property
    def ycenter(self):
        &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
        _,yc = self.xycenter
        
    @property
    def beadtype(self):
        &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
        b = []
        for o in self.collection:
            if o.beadtype not in b:
                b.append(o.beadtype)
        if len(b)==0:
            return 1
        else:
            return b</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="raster.Collection.beadtype"><code class="name">var <span class="ident">beadtype</span></code></dt>
<dd>
<div class="desc"><p>returns the xcenter and ycenter of the collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def beadtype(self):
    &#34;&#34;&#34; returns the xcenter and ycenter of the collection &#34;&#34;&#34;
    b = []
    for o in self.collection:
        if o.beadtype not in b:
            b.append(o.beadtype)
    if len(b)==0:
        return 1
    else:
        return b</code></pre>
</details>
</dd>
<dt id="raster.Collection.xcenter"><code class="name">var <span class="ident">xcenter</span></code></dt>
<dd>
<div class="desc"><p>returns xcenter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xcenter(self):
    &#34;&#34;&#34; returns xcenter &#34;&#34;&#34;
    xc,_ = self.xycenter</code></pre>
</details>
</dd>
<dt id="raster.Collection.xycenter"><code class="name">var <span class="ident">xycenter</span></code></dt>
<dd>
<div class="desc"><p>returns the xcenter and ycenter of
the collection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xycenter(self):
    &#34;&#34;&#34; returns the xcenter and ycenter of  the collection &#34;&#34;&#34;
    sx = sy = 0
    n = len(self.collection)
    for o in self.collection:
        sx += o.xcenter
        sy += o.ycenter
    return sx/n, sy/n</code></pre>
</details>
</dd>
<dt id="raster.Collection.ycenter"><code class="name">var <span class="ident">ycenter</span></code></dt>
<dd>
<div class="desc"><p>returns ycenter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ycenter(self):
    &#34;&#34;&#34; returns ycenter &#34;&#34;&#34;
    _,yc = self.xycenter</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.Collection.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.collection:
        return self.collection.getattr(name)
    else:
        raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.Diamond"><code class="flex name class">
<span>class <span class="ident">Diamond</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Diamond class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Diamond(Circle):
    &#34;&#34;&#34; Diamond class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=4)
        self.name = &#34;diam%03d&#34; % counter[1]
        self.kind = &#34;diamond&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Hexagon"><code class="flex name class">
<span>class <span class="ident">Hexagon</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Hexagon class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Hexagon(Circle):
    &#34;&#34;&#34; Hexagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=6)
        self.name = &#34;hex%03d&#34; % counter[1]
        self.kind = &#34;Hexagon&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Pentagon"><code class="flex name class">
<span>class <span class="ident">Pentagon</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Pentagon class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Pentagon(Circle):
    &#34;&#34;&#34; Pentagon class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=5)
        self.name = &#34;penta%03d&#34; % counter[1]
        self.kind = &#34;pentagon&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Rectangle"><code class="flex name class">
<span>class <span class="ident">Rectangle</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Rectangle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rectangle(genericpolygon):
    &#34;&#34;&#34; Rectangle class &#34;&#34;&#34;
    def __init__(self,counter):
        self.name = &#34;rect%03d&#34; % counter[1]
        self.kind = &#34;rectangle&#34;     # kind of object
        self.alike = &#34;circle&#34;       # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        
    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))        
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.genericpolygon.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.genericpolygon.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.genericpolygon.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.genericpolygon.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.genericpolygon.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.genericpolygon.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.genericpolygon.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.genericpolygon.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.Triangle"><code class="flex name class">
<span>class <span class="ident">Triangle</span></span>
<span>(</span><span>counter)</span>
</code></dt>
<dd>
<div class="desc"><p>Triangle class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Triangle(Circle):
    &#34;&#34;&#34; Triangle class &#34;&#34;&#34;
    def __init__(self,counter):
        super().__init__(counter,resolution=3)
        self.name = &#34;tri%03d&#34; % counter[1]
        self.kind = &#34;triangle&#34;     # kind of object</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.Circle" href="#raster.Circle">Circle</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.Circle.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.Circle.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.Circle.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.Circle.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.Circle.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
<li><code><a title="raster.Circle.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.Circle.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Circle.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.Circle.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.Circle.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.Circle.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.Circle.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.collection"><code class="flex name class">
<span>class <span class="ident">collection</span></span>
<span>(</span><span>*obj, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"><p>collection class container (not to be called directly) </p>
<p>constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class collection(struct):
    &#34;&#34;&#34; collection class container (not to be called directly) &#34;&#34;&#34;
    _type = &#34;collect&#34;               # object type
    _fulltype = &#34;Collections&#34;    # full name
    _ftype = &#34;collection&#34;        # field name
    def __init__(self,*obj,**kwobj):
        # store the objects with their alias
        super().__init__(**kwobj)
        # store objects with their real names
        for o in obj:
            if isinstance(o,raster):
                s = struct.dict2struct(o.objects)
                list_s = s.keys()
                for i in range(len(list_s)): self.setattr(list_s[i], s[i].copy())
            elif o!=None:
                self.setattr(o.name, o.copy())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pizza.private.struct.struct</li>
</ul>
</dd>
<dt id="raster.coregeometry"><code class="flex name class">
<span>class <span class="ident">coregeometry</span></span>
</code></dt>
<dd>
<div class="desc"><p>core geometry object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class coregeometry:
    &#34;&#34;&#34; core geometry object&#34;&#34;&#34;
        
    @property
    def xcenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.xcenter0 + self.translate[0]
    @property
    def ycenter(self):
        &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
        return self.ycenter0 + self.translate[1]
    @property
    def xmin(self):
        &#34;&#34;&#34; xleft position &#34;&#34;&#34;
        return self.xmin0 + self.translate[0]
    @property
    def xmax(self):
        &#34;&#34;&#34; xright position &#34;&#34;&#34;
        return self.xmax0 + self.translate[0]
    @property
    def ymin(self):
        &#34;&#34;&#34; yleft position &#34;&#34;&#34;
        return self.ymin0 + self.translate[1]
    @property
    def ymax(self):
        &#34;&#34;&#34; yright position &#34;&#34;&#34;
        return self.ymax0 + self.translate[1]
    @property
    def width(self):
        &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
        return self.xmax - self.xmin
    @property
    def height(self):
        &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
        return self.ymax - self.ymin

    def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
        &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
        if self.alike != &#34;mixed&#34;:
            dup = deepduplicate(self)
            if translate != None: # applies translation
                dup.translate[0] += translate[0] 
                dup.translate[1] += translate[1]
            if beadtype != None: # update beadtype
                dup.beadtype = beadtype
            if name != &#34;&#34;: # update name
                dup.name = name
            return dup
        else:
            raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></li>
<li><a title="raster.overlay" href="#raster.overlay">overlay</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="raster.coregeometry.height"><code class="name">var <span class="ident">height</span></code></dt>
<dd>
<div class="desc"><p>oibject height range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def height(self):
    &#34;&#34;&#34; oibject height range &#34;&#34;&#34;
    return self.ymax - self.ymin</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.width"><code class="name">var <span class="ident">width</span></code></dt>
<dd>
<div class="desc"><p>oibject width range</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def width(self):
    &#34;&#34;&#34; oibject width range &#34;&#34;&#34;
    return self.xmax - self.xmin</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xcenter"><code class="name">var <span class="ident">xcenter</span></code></dt>
<dd>
<div class="desc"><p>xcenter with translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xcenter(self):
    &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
    return self.xcenter0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xmax"><code class="name">var <span class="ident">xmax</span></code></dt>
<dd>
<div class="desc"><p>xright position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xmax(self):
    &#34;&#34;&#34; xright position &#34;&#34;&#34;
    return self.xmax0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.xmin"><code class="name">var <span class="ident">xmin</span></code></dt>
<dd>
<div class="desc"><p>xleft position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xmin(self):
    &#34;&#34;&#34; xleft position &#34;&#34;&#34;
    return self.xmin0 + self.translate[0]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ycenter"><code class="name">var <span class="ident">ycenter</span></code></dt>
<dd>
<div class="desc"><p>xcenter with translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ycenter(self):
    &#34;&#34;&#34; xcenter with translate &#34;&#34;&#34;
    return self.ycenter0 + self.translate[1]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ymax"><code class="name">var <span class="ident">ymax</span></code></dt>
<dd>
<div class="desc"><p>yright position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ymax(self):
    &#34;&#34;&#34; yright position &#34;&#34;&#34;
    return self.ymax0 + self.translate[1]</code></pre>
</details>
</dd>
<dt id="raster.coregeometry.ymin"><code class="name">var <span class="ident">ymin</span></code></dt>
<dd>
<div class="desc"><p>yleft position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ymin(self):
    &#34;&#34;&#34; yleft position &#34;&#34;&#34;
    return self.ymin0 + self.translate[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.coregeometry.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, translate=None, beadtype=None, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the graphical object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self,translate=None,beadtype=None,name=&#34;&#34;):
    &#34;&#34;&#34; returns a copy of the graphical object &#34;&#34;&#34;
    if self.alike != &#34;mixed&#34;:
        dup = deepduplicate(self)
        if translate != None: # applies translation
            dup.translate[0] += translate[0] 
            dup.translate[1] += translate[1]
        if beadtype != None: # update beadtype
            dup.beadtype = beadtype
        if name != &#34;&#34;: # update name
            dup.name = name
        return dup
    else:
        raise ValueError(&#34;collections cannot be copied, regenerate the collection instead&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.coreshell"><code class="flex name class">
<span>class <span class="ident">coreshell</span></span>
<span>(</span><span>xmin=10, ymin=10, xmax=90, ymax=90, maxtrials=1000, beadtype=1, forcedinsertion=True)</span>
</code></dt>
<dd>
<div class="desc"><p>coreshell generator
inherited from emulsion
the method insertion has been modified to integrate
thickess = shell thickness value
beadtype = (shell beadtype, core beadtype)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>The insertions are performed between xmin,ymin and xmax,ymax</dt>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x left corner. The default is 10.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y bottom corner. The default is 10.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x right corner. The default is 90.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y top corner. The default is 90.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>default beadtype to apply if not precised at insertion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>maxtrials</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Maximum of attempts for an object. The default is 1000.</dd>
<dt><strong><code>forcedinsertion</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force the next insertion. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class coreshell(emulsion):
    &#34;&#34;&#34;
        coreshell generator
            inherited from emulsion
            the method insertion has been modified to integrate
                thickess = shell thickness value
                beadtype = (shell beadtype, core beadtype)
    &#34;&#34;&#34;       

    def insertion(self,rlist,thickness=None, beadtype=(1,2)):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(...)
                
                List of properties
                    rlist = [r1, r2,...]
                    thickness = shell thcikness value
                    beadtype = (shell beadtype, core beadtype)
        &#34;&#34;&#34;
        # check arguments
        if thickness==None:
            raise AttributeError(&#34;set a value for the shell thickness&#34;)
        if not isinstance(beadtype,tuple):
            raise TypeError(&#34;beadtype must be a turple&#34;)
        # prepare the work
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            # next insertion and check rcore
            n += 1
            rshell = rlist[n-1]
            rcore = rshell - thickness
            if rcore&lt;=0:
                raise ValueError( 
 f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
            # do the insertion of the shell (largest radius)
            success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
            if success: 
                success = self.insertone(
                    x = self.lastinsertion[0],
                    y = self.lastinsertion[1],
                    r=rcore,
                    beadtype=beadtype[1],
                    overlap=True)
                nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></li>
<li><a title="raster.scatter" href="#raster.scatter">scatter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raster.coreshell.insertion"><code class="name flex">
<span>def <span class="ident">insertion</span></span>(<span>self, rlist, thickness=None, beadtype=(1, 2))</span>
</code></dt>
<dd>
<div class="desc"><p>insert a list of objects
nsuccess=insertion(&hellip;)</p>
<pre><code>List of properties
    rlist = [r1, r2,...]
    thickness = shell thcikness value
    beadtype = (shell beadtype, core beadtype)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">   def insertion(self,rlist,thickness=None, beadtype=(1,2)):
       &#34;&#34;&#34;
           insert a list of objects
               nsuccess=insertion(...)
               
               List of properties
                   rlist = [r1, r2,...]
                   thickness = shell thcikness value
                   beadtype = (shell beadtype, core beadtype)
       &#34;&#34;&#34;
       # check arguments
       if thickness==None:
           raise AttributeError(&#34;set a value for the shell thickness&#34;)
       if not isinstance(beadtype,tuple):
           raise TypeError(&#34;beadtype must be a turple&#34;)
       # prepare the work
       rlist.sort(reverse=True)
       ntodo = len(rlist)
       n = nsuccess = 0
       stop = False
       while not stop:
           # next insertion and check rcore
           n += 1
           rshell = rlist[n-1]
           rcore = rshell - thickness
           if rcore&lt;=0:
               raise ValueError( 
f&#34;The external radius={rshell} cannot be smaller than the shell thickness={thickness}&#34;)
           # do the insertion of the shell (largest radius)
           success = self.insertone(r=rshell,beadtype=beadtype[0],overlap=False)
           if success: 
               success = self.insertone(
                   x = self.lastinsertion[0],
                   y = self.lastinsertion[1],
                   r=rcore,
                   beadtype=beadtype[1],
                   overlap=True)
               nsuccess += 1
           stop = (n==ntodo) or (not success and not self.forcedinsertion)
       if nsuccess==ntodo:
           print(f&#34;{nsuccess} objects inserted successfully&#34;)
       else:
           print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
       return nsuccess</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.emulsion.accepted" href="#raster.emulsion.accepted">accepted</a></code></li>
<li><code><a title="raster.emulsion.dist" href="#raster.emulsion.dist">dist</a></code></li>
<li><code><a title="raster.emulsion.insertone" href="#raster.emulsion.insertone">insertone</a></code></li>
<li><code><a title="raster.emulsion.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
<li><code><a title="raster.emulsion.rand" href="#raster.emulsion.rand">rand</a></code></li>
<li><code><a title="raster.emulsion.setbeadtype" href="#raster.emulsion.setbeadtype">setbeadtype</a></code></li>
<li><code><a title="raster.emulsion.walldist" href="#raster.emulsion.walldist">walldist</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.emulsion"><code class="flex name class">
<span>class <span class="ident">emulsion</span></span>
<span>(</span><span>xmin=10, ymin=10, xmax=90, ymax=90, maxtrials=1000, beadtype=1, forcedinsertion=True)</span>
</code></dt>
<dd>
<div class="desc"><p>emulsion generator </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt>The insertions are performed between xmin,ymin and xmax,ymax</dt>
<dt><strong><code>xmin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x left corner. The default is 10.</dd>
<dt><strong><code>ymin</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y bottom corner. The default is 10.</dd>
<dt><strong><code>xmax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>x right corner. The default is 90.</dd>
<dt><strong><code>ymax</code></strong> :&ensp;<code>int64</code> or <code>real</code>, optional</dt>
<dd>y top corner. The default is 90.</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>default beadtype to apply if not precised at insertion</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>maxtrials</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>Maximum of attempts for an object. The default is 1000.</dd>
<dt><strong><code>forcedinsertion</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force the next insertion. The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class emulsion(scatter):
    &#34;&#34;&#34; emulsion generator &#34;&#34;&#34;
    
    def __init__(self, xmin=10, ymin=10, xmax=90, ymax=90, 
                 maxtrials=1000, beadtype=1, forcedinsertion=True):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        The insertions are performed between xmin,ymin and xmax,ymax
        xmin : int64 or real, optional
            x left corner. The default is 10.
        ymin : int64 or real, optional
            y bottom corner. The default is 10.
        xmax : int64 or real, optional
            x right corner. The default is 90.
        ymax : int64 or real, optional
            y top corner. The default is 90.
        beadtype : default beadtype to apply if not precised at insertion
        maxtrials : integer, optional
            Maximum of attempts for an object. The default is 1000.
        forcedinsertion : logical, optional
            Set it to true to force the next insertion. The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        super().__init__()
        self.xmin, self.xmax, self.ymin, self.ymax = xmin, xmax, ymin, ymax
        self.lastinsertion = (None,None,None,None) # x,y,r, beadtype
        self.width = xmax-xmin
        self.height = ymax-ymin
        self.defautbeadtype = beadtype
        self.maxtrials = maxtrials
        self.forcedinsertion = forcedinsertion

    def __repr__(self):
        print(f&#34; Emulsion object\n\t{self.width}x{self.height} starting at x={self.xmin}, y={self.ymin}&#34;)        
        print(f&#34;\tcontains {self.n} insertions&#34;)
        print(&#34;\tmaximum insertion trials:&#34;, self.maxtrials)
        print(&#34;\tforce next insertion if previous fails:&#34;, self.forcedinsertion)
        return f&#34;emulsion with {self.n} insertions&#34;

        
    def walldist(self,x,y):
        &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
        return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))

    def dist(self,x,y):
        &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
        return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))
    
    def accepted(self,x,y,r):
        &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
        return self.dist(x,y)&gt;r
    
    def rand(self):
        &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
        return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
                np.round(np.random.uniform(low=self.ymin,high=self.ymax))
                
    def setbeadtype(self,beadtype):
        &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
        if beadtype == None:
            self.beadtype.append(self.defautbeadtype)
            return self.defautbeadtype
        else:
            self.beadtype.append(beadtype)
            return beadtype
     
    def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
        &#34;&#34;&#34;
            insert one object of radius r
            properties:
                x,y coordinates (if missing, picked randomly from uniform distribution)
                r radius (default = 2% of diagonal)
                beadtype (default = defautbeadtype)
                overlap = False (accept only if no overlap)
        &#34;&#34;&#34;
        attempt, success = 0, False
        random = (x==None) or (y==None)
        if r==None:
            r = 0.02*np.sqrt(self.width**2+self.height**2)
        while not success and attempt&lt;self.maxtrials:
            attempt += 1
            if random: x,y = self.rand()
            if overlap:
                success = True
            else:
                success = self.accepted(x,y,r)
        if success:
            self.x = np.append(self.x,x)
            self.y = np.append(self.y,y)
            self.r = np.append(self.r,r)
            b=self.setbeadtype(beadtype)
            self.lastinsertion = (x,y,r,b)
        return success

    def insertion(self,rlist,beadtype=None):
        &#34;&#34;&#34;
            insert a list of objects
                nsuccess=insertion(rlist,beadtype=None)
                beadtype=b forces the value b
                if None, defaultbeadtype is used instead
        &#34;&#34;&#34;
        rlist.sort(reverse=True)
        ntodo = len(rlist)
        n = nsuccess = 0
        stop = False
        while not stop:
            n += 1
            success = self.insertone(r=rlist[n-1],beadtype=beadtype)
            if success: nsuccess += 1
            stop = (n==ntodo) or (not success and not self.forcedinsertion)
        if nsuccess==ntodo:
            print(f&#34;{nsuccess} objects inserted successfully&#34;)
        else:
            print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
        return nsuccess</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.scatter" href="#raster.scatter">scatter</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.coreshell" href="#raster.coreshell">coreshell</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="raster.emulsion.accepted"><code class="name flex">
<span>def <span class="ident">accepted</span></span>(<span>self, x, y, r)</span>
</code></dt>
<dd>
<div class="desc"><p>acceptation criterion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accepted(self,x,y,r):
    &#34;&#34;&#34; acceptation criterion &#34;&#34;&#34;
    return self.dist(x,y)&gt;r</code></pre>
</details>
</dd>
<dt id="raster.emulsion.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance of the center (x,y) to the wall or any object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(self,x,y):
    &#34;&#34;&#34; shortest distance of the center (x,y) to the wall or any object&#34;&#34;&#34;
    return np.minimum(np.min(self.pairdist(x,y)),self.walldist(x,y))</code></pre>
</details>
</dd>
<dt id="raster.emulsion.insertion"><code class="name flex">
<span>def <span class="ident">insertion</span></span>(<span>self, rlist, beadtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>insert a list of objects
nsuccess=insertion(rlist,beadtype=None)
beadtype=b forces the value b
if None, defaultbeadtype is used instead</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertion(self,rlist,beadtype=None):
    &#34;&#34;&#34;
        insert a list of objects
            nsuccess=insertion(rlist,beadtype=None)
            beadtype=b forces the value b
            if None, defaultbeadtype is used instead
    &#34;&#34;&#34;
    rlist.sort(reverse=True)
    ntodo = len(rlist)
    n = nsuccess = 0
    stop = False
    while not stop:
        n += 1
        success = self.insertone(r=rlist[n-1],beadtype=beadtype)
        if success: nsuccess += 1
        stop = (n==ntodo) or (not success and not self.forcedinsertion)
    if nsuccess==ntodo:
        print(f&#34;{nsuccess} objects inserted successfully&#34;)
    else:
        print(f&#34;partial success: {nsuccess} of {ntodo} objects inserted&#34;)
    return nsuccess</code></pre>
</details>
</dd>
<dt id="raster.emulsion.insertone"><code class="name flex">
<span>def <span class="ident">insertone</span></span>(<span>self, x=None, y=None, r=None, beadtype=None, overlap=False)</span>
</code></dt>
<dd>
<div class="desc"><p>insert one object of radius r
properties:
x,y coordinates (if missing, picked randomly from uniform distribution)
r radius (default = 2% of diagonal)
beadtype (default = defautbeadtype)
overlap = False (accept only if no overlap)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertone(self,x=None,y=None,r=None,beadtype=None,overlap=False):
    &#34;&#34;&#34;
        insert one object of radius r
        properties:
            x,y coordinates (if missing, picked randomly from uniform distribution)
            r radius (default = 2% of diagonal)
            beadtype (default = defautbeadtype)
            overlap = False (accept only if no overlap)
    &#34;&#34;&#34;
    attempt, success = 0, False
    random = (x==None) or (y==None)
    if r==None:
        r = 0.02*np.sqrt(self.width**2+self.height**2)
    while not success and attempt&lt;self.maxtrials:
        attempt += 1
        if random: x,y = self.rand()
        if overlap:
            success = True
        else:
            success = self.accepted(x,y,r)
    if success:
        self.x = np.append(self.x,x)
        self.y = np.append(self.y,y)
        self.r = np.append(self.r,r)
        b=self.setbeadtype(beadtype)
        self.lastinsertion = (x,y,r,b)
    return success</code></pre>
</details>
</dd>
<dt id="raster.emulsion.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>random position x,y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand(self):
    &#34;&#34;&#34; random position x,y  &#34;&#34;&#34;
    return  np.round(np.random.uniform(low=self.xmin,high=self.xmax)), \
            np.round(np.random.uniform(low=self.ymin,high=self.ymax))</code></pre>
</details>
</dd>
<dt id="raster.emulsion.setbeadtype"><code class="name flex">
<span>def <span class="ident">setbeadtype</span></span>(<span>self, beadtype)</span>
</code></dt>
<dd>
<div class="desc"><p>set the default or the supplied beadtype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setbeadtype(self,beadtype):
    &#34;&#34;&#34; set the default or the supplied beadtype  &#34;&#34;&#34;
    if beadtype == None:
        self.beadtype.append(self.defautbeadtype)
        return self.defautbeadtype
    else:
        self.beadtype.append(beadtype)
        return beadtype</code></pre>
</details>
</dd>
<dt id="raster.emulsion.walldist"><code class="name flex">
<span>def <span class="ident">walldist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>shortest distance to the wall</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walldist(self,x,y):
    &#34;&#34;&#34; shortest distance to the wall &#34;&#34;&#34;
    return min(abs(x-self.xmin),abs(y-self.ymin),abs(x-self.xmax),abs(y-self.ymax))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.scatter" href="#raster.scatter">scatter</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.scatter.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.genericpolygon"><code class="flex name class">
<span>class <span class="ident">genericpolygon</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic polygon methods</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class genericpolygon(coregeometry):
    &#34;&#34;&#34; generic polygon methods &#34;&#34;&#34;
    
    hascontour = True
    hasclosefit = False

    @property
    def polygon(self):
        &#34;&#34;&#34; 
        R.polygon = path.Path(R.vertices,R.codes,closed=True)
        &#34;&#34;&#34;
        v = self.vertices
        if self.translate != None:
            vtmp = list(map(list,zip(*v)))
            for i in range(len(vtmp[0])):
                vtmp[0][i] += self.translate[0]
                vtmp[1][i] += self.translate[1]
            v = list(zip(*vtmp))
        return path.Path(v,self.codes,closed=True)

    @property
    def polygon2plot(self):
        &#34;&#34;&#34;
        R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
        &#34;&#34;&#34;
        return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)

    def corners(self):
        &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
        return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
               max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
               max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.Circle" href="#raster.Circle">Circle</a></li>
<li><a title="raster.Rectangle" href="#raster.Rectangle">Rectangle</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="raster.genericpolygon.hasclosefit"><code class="name">var <span class="ident">hasclosefit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="raster.genericpolygon.hascontour"><code class="name">var <span class="ident">hascontour</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="raster.genericpolygon.polygon"><code class="name">var <span class="ident">polygon</span></code></dt>
<dd>
<div class="desc"><p>R.polygon = path.Path(R.vertices,R.codes,closed=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polygon(self):
    &#34;&#34;&#34; 
    R.polygon = path.Path(R.vertices,R.codes,closed=True)
    &#34;&#34;&#34;
    v = self.vertices
    if self.translate != None:
        vtmp = list(map(list,zip(*v)))
        for i in range(len(vtmp[0])):
            vtmp[0][i] += self.translate[0]
            vtmp[1][i] += self.translate[1]
        v = list(zip(*vtmp))
    return path.Path(v,self.codes,closed=True)</code></pre>
</details>
</dd>
<dt id="raster.genericpolygon.polygon2plot"><code class="name">var <span class="ident">polygon2plot</span></code></dt>
<dd>
<div class="desc"><p>R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def polygon2plot(self):
    &#34;&#34;&#34;
    R.polygon2plot = path.Path(R.polygon.vertices+ np.array([1,1]),R.codes,closed=True)
    &#34;&#34;&#34;
    return path.Path(self.polygon.vertices+ np.array([1,1]),self.codes,closed=True)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.genericpolygon.corners"><code class="name flex">
<span>def <span class="ident">corners</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns xmin, ymin, xmax, ymax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corners(self):
    &#34;&#34;&#34; returns xmin, ymin, xmax, ymax &#34;&#34;&#34;
    return min([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
           min([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1], \
           max([self.vertices[k][0] for k in range(self.nvertices)])+self.translate[0], \
           max([self.vertices[k][1] for k in range(self.nvertices)])+self.translate[1]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.overlay"><code class="flex name class">
<span>class <span class="ident">overlay</span></span>
<span>(</span><span>counter=(0, 0), filename='./sandbox/image.jpg', xmin=0, ymin=0, ncolors=4)</span>
</code></dt>
<dd>
<div class="desc"><p>generic overlay class </p>
<p>generate an overlay from file
overlay(counter=(c1,c2),filename="this/is/myimage.jpg",xmin=x0,ymin=y0,colors=4)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class overlay(coregeometry):
    &#34;&#34;&#34; generic overlay class &#34;&#34;&#34;
    
    hascontour = False
    hasclosefit = True
    
    def __init__(self,
                 counter = (0,0),
                 filename=&#34;./sandbox/image.jpg&#34;,
                 xmin = 0,
                 ymin = 0,
                 ncolors = 4
                 ):
        &#34;&#34;&#34; generate an overlay from file
                overlay(counter=(c1,c2),filename=&#34;this/is/myimage.jpg&#34;,xmin=x0,ymin=y0,colors=4)
        &#34;&#34;&#34;
        self.name = &#34;over%03d&#34; % counter[1]
        self.kind = &#34;overlay&#34;       # kind of object
        self.alike = &#34;overlay&#34;      # similar object for plotting
        self.beadtype = 1           # bead type
        self.beadtype2 = None       # bead type 2 (alternative beadtype, ratio)
        self.nbeads = 0             # number of beads
        self.ismask = False         # True if beadtype == 0
        self.isplotted = False      # True if plotted
        self.islabelled = False     # True if labelled
        self.resolution = None      # resolution is undefined
        self.hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
        self.index = counter[0]
        self.subindex = counter[1]
        self.translate = [0.0,0.0]  # modification used when an object is duplicated
        if not os.path.isfile(filename):
            raise IOError(f&#39;the file &#34;{filename}&#34; does not exist&#39;)
        self.filename = filename
        self.ncolors = ncolors
        self.color = None
        self.colormax = None
        self.original,self.raw,self.im,self.map = self.load()
        self.xmin0 = xmin
        self.ymin0 = ymin
        self.xmax0 = xmin + self.im.shape[1]
        self.ymax0 = ymin + self.im.shape[0]
        self.xcenter0 = (self.xmin+self.xmax)/2
        self.ycenter0 = (self.ymin+self.ymax)/2
        self.angle = 0
        
        
    def select(self,color=None,colormax=None):
        &#34;&#34;&#34; select the color index:
                select(color = c) peeks pixels = c
                select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
        &#34;&#34;&#34;
        if color is None:
            color = self.color
        else:
            self.color = color
        if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
                colormax = self.colormax
        else:
            colormax = self.colormax = color
        if isinstance(color,int) and color&lt;len(self.map):
            S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
            self.nbeads = np.count_nonzero(S)
            return S
        raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))
        
    def load(self):
        &#34;&#34;&#34; load image and process it 
                returns the image, the indexed image and its color map ( la Matlab, such as imread)
                
                note: if the image contains a palette it is used, if not the
                image is converted to an indexed image without dihtering
        &#34;&#34;&#34;
        I = Image.open(self.filename)
        palette = I.getpalette()
        if palette is None:
            J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
            palette = J.getpalette()
        else:
            J = I
        p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
        ncolors = len(p.sum(axis=1).nonzero()[0]);
        if ncolors&lt;self.ncolors:
            print(f&#34;only {ncolors} are available&#34;)
        return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]
    
    def __repr__(self):
        &#34;&#34;&#34; display for rectangle class &#34;&#34;&#34;
        print(&#34;%s - %s object&#34; % (self.name, self.kind))
        print(f&#39;\tfilename: &#34;{self.filename}&#34;&#39;)
        print(f&#34;\tncolors = {self.ncolors} (selected={self.color})&#34;)
        print(&#34;\trange x = [%0.4g %0.4g]&#34; % (self.xmin,self.xmax))
        print(&#34;\trange y = [%0.4g %0.4g]&#34; % (self.ymin,self.ymax))
        print(&#34;\tcenter = [%0.4g %0.4g]&#34; % (self.xcenter,self.ycenter))
        print(&#34;\tangle = %0.4g&#34; % self.angle)
        print(&#34;\ttranslate = [%0.4g %0.4g]&#34; % (self.translate[0],self.translate[1]))
        print(&#34;note: use the attribute origina,raw to see the raw image&#34;)
        return &#34;%s object: %s (beadtype=%d)&#34; % (self.kind,self.name,self.beadtype)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="raster.overlay.hasclosefit"><code class="name">var <span class="ident">hasclosefit</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="raster.overlay.hascontour"><code class="name">var <span class="ident">hascontour</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.overlay.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>load image and process it
returns the image, the indexed image and its color map ( la Matlab, such as imread)</p>
<p>note: if the image contains a palette it is used, if not the
image is converted to an indexed image without dihtering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self):
    &#34;&#34;&#34; load image and process it 
            returns the image, the indexed image and its color map ( la Matlab, such as imread)
            
            note: if the image contains a palette it is used, if not the
            image is converted to an indexed image without dihtering
    &#34;&#34;&#34;
    I = Image.open(self.filename)
    palette = I.getpalette()
    if palette is None:
        J=I.convert(mode=&#34;P&#34;,colors=self.ncolors,palette=Image.Palette.ADAPTIVE)
        palette = J.getpalette()
    else:
        J = I
    p = np.array(palette,dtype=&#34;uint8&#34;).reshape((int(len(palette)/3),3))
    ncolors = len(p.sum(axis=1).nonzero()[0]);
    if ncolors&lt;self.ncolors:
        print(f&#34;only {ncolors} are available&#34;)
    return I,J, np.array(J,dtype=&#34;uint8&#34;), p[:ncolors,:]</code></pre>
</details>
</dd>
<dt id="raster.overlay.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, color=None, colormax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>select the color index:
select(color = c) peeks pixels = c
select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self,color=None,colormax=None):
    &#34;&#34;&#34; select the color index:
            select(color = c) peeks pixels = c
            select(color = c, colormax = cmax) peeks pixels&gt;=c and pixels&lt;=cmax
    &#34;&#34;&#34;
    if color is None:
        color = self.color
    else:
        self.color = color
    if (colormax is None) and (self.colormax is not None) and (self.colormax &gt; self.color):
            colormax = self.colormax
    else:
        colormax = self.colormax = color
    if isinstance(color,int) and color&lt;len(self.map):
        S = np.logical_and(self.im&gt;=color,self.im&lt;=colormax)
        self.nbeads = np.count_nonzero(S)
        return S
    raise ValueError(&#34;color must be an integer lower than %d&#34; % len(self.map))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></b></code>:
<ul class="hlist">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="raster.raster"><code class="flex name class">
<span>class <span class="ident">raster</span></span>
<span>(</span><span>name='default raster', width=100, height=100, dpi=200, fontsize=10, mass=1, volume=1, radius=1.5, contactradius=0.5, velocities=[0, 0, 0], forces=[0, 0, 0], filename='')</span>
</code></dt>
<dd>
<div class="desc"><p>raster class for LAMMPS SMD </p>
<p>Constructor</p>
<pre><code>R = raster(width=100,height=100...)

Extra properties
    dpi, fontsize

additional properties for R.data()
    scale, center : full scaling
    mass, volume, radius, contactradius, velocities, forces: bead scaling
    filename

List of available properties: default values

           name: "default raster"
          width: 100
         height: 100
            dpi: 200
       fontsize: 10
           mass: 1
         volume: 1
         radius: 1.5
  contactradius: 0.5
     velocities: [0, 0, 0]
         forces: [0, 0, 0]
       filename: ["%dx%d raster (%s)" % (self.width,self.height,self.name)]
</code></pre>
<p>Graphical objects</p>
<pre><code>R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode="lower", angle=0, ismask=False])
R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode="center", angle=0, ismask=False])
R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
R.triangle(...)
R.diamond(...)
R.pentagon(...)
R.hexagon(...)

R.overlay(xleft,xright,filename=="valid/image.ext",color=2,beadtype=1)

note: use fake=True to generate an object without inserting it

R.collection(...) generates collection of existing or fake objects
R.object.copy(...) enables to copy an object
</code></pre>
<p>Display methods (precedence affects the result)
R.plot()
R.show(), R.show(extra="label",contour=True,what="beadtype" or "objindex")
R.show(extra="labels")
R.list()
R.get("object")
R.print()
R.label("object")
R.unlabel("object")
R.figure()
R.newfigure(dpi=300)</p>
<pre><code>R.numeric()
R.string(), R.string(what="beadtype" or "objindex"))
R.names()
R.print()
</code></pre>
<p>Clear and delete
R.clear()
R.clear("all")
R.delete("object")</p>
<p>Copy objects
R.copyalongpath(....)
R.scatter()</p>
<p>Generate an input data object
X = R.data() or X=R.data(scale=(1,1),center=(0,0))
X.write("/tmp/myfile")</p>
<p>initialize raster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class raster:
    &#34;&#34;&#34; raster class for LAMMPS SMD 
    
    Constructor
    
        R = raster(width=100,height=100...)

        Extra properties
            dpi, fontsize
        
        additional properties for R.data()
            scale, center : full scaling
            mass, volume, radius, contactradius, velocities, forces: bead scaling
            filename
        
        List of available properties: default values
        
                   name: &#34;default raster&#34;
                  width: 100
                 height: 100
                    dpi: 200
               fontsize: 10
                   mass: 1
                 volume: 1
                 radius: 1.5
          contactradius: 0.5
             velocities: [0, 0, 0]
                 forces: [0, 0, 0]
               filename: [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
    
    Graphical objects
        
        R.rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        R.rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
        R.circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        R.triangle(...)
        R.diamond(...)
        R.pentagon(...)
        R.hexagon(...)
        
        R.overlay(xleft,xright,filename==&#34;valid/image.ext&#34;,color=2,beadtype=1) 
        
        note: use fake=True to generate an object without inserting it
        
        R.collection(...) generates collection of existing or fake objects
        R.object.copy(...) enables to copy an object
        
    Display methods (precedence affects the result)
        R.plot()
        R.show(), R.show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34; or &#34;objindex&#34;)
        R.show(extra=&#34;labels&#34;)
        R.list()
        R.get(&#34;object&#34;)
        R.print()
        R.label(&#34;object&#34;)
        R.unlabel(&#34;object&#34;)
        R.figure()
        R.newfigure(dpi=300)
        
        R.numeric()
        R.string(), R.string(what=&#34;beadtype&#34; or &#34;objindex&#34;))
        R.names()
        R.print()
        
    Clear and delete
        R.clear()
        R.clear(&#34;all&#34;)
        R.delete(&#34;object&#34;)

    Copy objects
        R.copyalongpath(....)
        R.scatter()

    Generate an input data object
        X = R.data() or X=R.data(scale=(1,1),center=(0,0))
        X.write(&#34;/tmp/myfile&#34;)
    
    &#34;&#34;&#34;
    
    # CONSTRUCTOR ---------------------------- 
    def __init__(self,
                 # raster properties
                 name=&#34;default raster&#34;,
                 width=100,
                 height=100,
                 # printing and display
                 dpi=200,
                 fontsize=10,
                 # for data conversion
                 mass=1,
                 volume=1,
                 radius=1.5,
                 contactradius=0.5,
                 velocities=[0,0,0],
                 forces=[0,0,0],
                 filename=&#34;&#34;
                 ):
        
        &#34;&#34;&#34; initialize raster &#34;&#34;&#34;
        self.name = name
        self.width = width
        self.height = height
        self.xcenter= width/2
        self.ycenter = height/2
        self.objects = {}
        self.nobjects = 0    # total number of objects (alive)
        self.nbeads = 0
        self.counter = { &#34;triangle&#34;:0,
                          &#34;diamond&#34;:0,
                        &#34;rectangle&#34;:0,
                         &#34;pentagon&#34;:0,
                          &#34;hexagon&#34;:0,
                           &#34;circle&#34;:0,
                          &#34;overlay&#34;:0,
                       &#34;collection&#34;:0,
                              &#34;all&#34;:0
                    }
        self.fontsize = 10   # font size for labels
        self.imbead = np.zeros((height,width),dtype=np.int8)
        self.imobj = np.zeros((height,width),dtype=np.int8)
        self.hfig = [] # figure handle
        self.dpi = dpi
        # generic SMD properties (to be rescaled)
        self.volume = volume
        self.mass = mass
        self.radius = radius
        self.contactradius = contactradius
        self.velocities = velocities
        self.forces =forces
        
        if filename == &#34;&#34;:
            self.filename = [&#34;%dx%d raster (%s)&#34; % (self.width,self.height,self.name)]
        else:
            self.filename = filename
        

    # DATA ---------------------------- 
    def data(self,scale=(1,1),center=(0,0),maxtype=None):
        &#34;&#34;&#34;
        data()
        data(scale=(scalex,scaley),center=(centerx,centery),maxtype=number)
        return a pizza.data object  &#34;&#34;&#34;
        if not isinstance(scale,tuple) or len(scale)!=2:
            raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
        if not isinstance(center,tuple) or len(scale)!=2:
            raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
        scalez = np.sqrt(scale[0]*scale[1])
        scalevol = scale[0]*scale[1] #*scalez
        maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
        n = self.length()
        i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
        X = data3()  # empty pizza.data3.data object
        X.title = self.name + &#34;(raster)&#34;
        X.headers = {&#39;atoms&#39;: n,
                      &#39;atom types&#39;: maxtypeheader,
                      &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                      &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                      &#39;zlo zhi&#39;: (0, scalez)}
        # [ATOMS] section
        X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
        X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
        X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
        X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
        X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
        X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
        X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
        X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x&#34;)        # x
        X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y&#34;)        # y
        X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)                                 # z
        X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x0&#34;)       # x0
        X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y0&#34;)       # y0
        X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)                                # z0
        # [VELOCITIES] section
        X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
        X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
        X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
        X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
        # pseudo-filename        
        X.flist = self.filename
        return X
     
    # LENGTH ---------------------------- 
    def length(self,t=None,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = self.imbead
        elif what == &#34;objindex&#34;:
            num = self.imobj
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        if t==None:
            return np.count_nonzero(num&gt;0)
        else:
            return np.count_nonzero(num==t)
        
    # NUMERIC ---------------------------- 
    def numeric(self):
        &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
        return self.imbead, self.imobj

    # STRING ---------------------------- 
    def string(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
        if what == &#34;beadtype&#34;:
            num = np.flipud(duplicate(self.imbead))
        elif what == &#34;objindex&#34;:
            num = np.flipud(duplicate(self.imobj))
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
        num[num&gt;0] = num[num&gt;0] + 65
        num[num==0] = 32
        num = list(num)
        return [&#34;&#34;.join(map(chr,x)) for x in num]
        
    # GET -----------------------------
    def get(self,name):
        &#34;&#34;&#34; returns the object &#34;&#34;&#34;
        if name in self.objects:
            return self.objects[name]
        else:
            raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)

    # GETATTR --------------------------
    def __getattr__(self,key):
        &#34;&#34;&#34; get attribute override &#34;&#34;&#34;
        return self.get(key)
        
    # CLEAR ---------------------------- 
    def clear(self,what=&#34;nothing&#34;):
        &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
        self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
        self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
        for o in self.names():
            if what==&#34;all&#34;:
                self.delete(o)
            else:
                self.objects[o].isplotted = False
                self.objects[o].islabelled = False
                if not self.objects[o].ismask:
                    self.nbeads -= self.objects[o].nbeads
                self.objects[o].nbeads = 0  # number of beads (plotted)
        self.figure()
        plt.cla()
        self.show()

    # DISP method ---------------------------- 
    def __repr__(self):
        &#34;&#34;&#34; display method &#34;&#34;&#34;
        ctyp = self.count() # count objects (not beads)
        print(&#34;-&#34;*40)
        print(&#39;RASTER area &#34;%s&#34; with %d objects&#39; % (self.name,self.nobjects))
        print(&#34;-&#34;*40)
        print(&#34;&lt;- grid size -&gt;&#34;)
        print(&#34;\twidth: %d&#34; % self.width)
        print(&#34;\theight: %d&#34; % self.height)
        print(&#34;&lt;- bead types -&gt;&#34;)
        nbt = 0
        if len(ctyp):
            for i,c in enumerate(ctyp):
                nb = self.length(c[0])
                nbt += nb
                print(&#34;\t type=%d (%d objects, %d beads)&#34; % (c[0],c[1],nb))
        else:
            print(&#34;\tno bead assigned&#34;)
        print(&#34;-&#34;*40)
        return &#34;RASTER AREA %d x %d with %d objects (%d types, %d beads).&#34; % \
        (self.width,self.height,self.nobjects,len(ctyp),nbt)

    # count method ---------------------------- 
    def count(self):
        &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
        typlist = []
        for  o in self.names():
            if isinstance(self.objects[o].beadtype,list):
                typlist += self.objects[o].beadtype
            else:
                typlist.append(self.objects[o].beadtype)
        utypes = list(set(typlist))
        c = []
        for t in utypes:
            c.append((t,typlist.count(t)))
        return c

    # NAMES method ---------------------------- 
    def names(self):
        &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
        namesunsorted=namessorted=list(self.objects.keys())
        nobj = len(namesunsorted)
        for iobj in range(nobj):
            namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
        return namessorted
        
    # LIST method ---------------------------- 
    def list(self):
        &#34;&#34;&#34; list objects &#34;&#34;&#34;
        fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
        print(&#34;RASTER with %d objects&#34; % self.nobjects)
        for o in self.objects.keys():
            print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
                  &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                      (self.objects[o].beadtype,
                       self.objects[o].index,
                       self.objects[o].subindex,
                       self.objects[o].nbeads))
            
    # EXIST method ---------------------------- 
    def exist(self,name):
        &#34;&#34;&#34; exist object &#34;&#34;&#34;
        return name in self.objects
    
    # DELETE method ---------------------------- 
    def delete(self,name):
        &#34;&#34;&#34; delete object &#34;&#34;&#34;
        if name in self.objects: 
            if not self.objects[name].ismask:
                self.nbeads -= self.objects[name].nbeads
            del self.objects[name]
            self.nobjects -= 1
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        self.clear()
        self.plot()
        self.show(extra=&#34;label&#34;)
        
    # VALID method
    def valid(self,x,y):
        &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
        return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))
    
    # frameobj method
    def frameobj(self,obj):
        &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
        if obj.hasclosefit:
            envelope = 0
        else:
            envelope = 1
        xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
        xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
        return xmin, ymin, xmax, ymax

    # RECTANGLE ----------------------------     
    def rectangle(self,a,b,c,d,
                  mode=&#34;lowerleft&#34;,name=None,angle=0,
                  beadtype=None,ismask=False,fake=False,beadtype2=None):
        &#34;&#34;&#34; 
        rectangle object
            rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
            rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
            
            use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
            from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;rectangle&#34;] += 1
        R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            R.name = name
        else:
            name = R.name
        if beadtype is not None: R.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        R.beadtype2 = beadtype2
        if ismask: R.beadtype = 0
        R.ismask = R.beadtype==0
        # build vertices
        if mode == &#34;lowerleft&#34;:
            R.xcenter0 = (a+b)/2
            R.ycenter0 = (c+d)/2
            R.vertices = [
                _rotate(a,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,c,R.xcenter0,R.ycenter0,angle),
                _rotate(b,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,d,R.xcenter0,R.ycenter0,angle),
                _rotate(a,c,R.xcenter0,R.ycenter0,angle)
                ] # anti-clockwise, closed (last point repeated)
        elif mode == &#34;center&#34;:
            R.xcenter0 = a
            R.ycenter0 = b
            R.vertices = [
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
                _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
                ]
        else:
            raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
        # build path object and range
        R.codes =    [ path.Path.MOVETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.LINETO,
                     path.Path.CLOSEPOLY
                    ]
        R.nvertices = len(R.vertices)-1
        R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()        
        R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
        R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
        R.angle = angle
        # store the object (if not fake)
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;rectangle&#34;] -= 1
            return R
        else:
            self.objects[name] = R
            self.nobjects += 1
            return None

        
    # CIRCLE ----------------------------     
    def circle(self,xc,yc,radius,
                  name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
                  resolution=20,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34; 
        circle object (or any regular polygon)
            circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
            use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        # object creation
        self.counter[&#34;all&#34;] += 1
        if resolution==3:
            typ = &#34;triangle&#34;
            self.counter[&#34;triangle&#34;] += 1
            G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
        elif resolution==4:
            typ = &#34;diamond&#34;
            self.counter[&#34;diamond&#34;] += 1
            G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
        elif resolution==5:
            typ = &#34;pentagon&#34;
            self.counter[&#34;pentagon&#34;] += 1
            G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
        elif resolution==6:
            typ = &#34;hexagon&#34;
            self.counter[&#34;hexagon&#34;] += 1
            G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
        else:
            typ = &#34;circle&#34;
            self.counter[&#34;circle&#34;] += 1
            G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
        if (name != None) and (name != &#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            G.name = name
        else:
            name = G.name
        if beadtype is not None: G.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        G.beadtype2 = beadtype2
        if ismask: G.beadtype = 0
        G.ismask = G.beadtype==0
        # build vertices
        th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
        xgen = xc + radius * np.cos(th)
        ygen = yc + radius * shaperatio * np.sin(th)
        G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
        G.vertices, G.codes = [], []
        for i in range(G.resolution+1):
            G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
            if i==0:
                G.codes.append(path.Path.MOVETO)
            elif i==G.resolution:
                G.codes.append(path.Path.CLOSEPOLY)        
            else:
                G.codes.append(path.Path.LINETO)
        G.nvertices = len(G.vertices)-1
        # build path object and range
        G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
        G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
        G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
        G.angle, G.shaperatio = angle, shaperatio
        # store the object
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[typ] -= 1
            return G
        else:
            self.objects[name] = G
            self.nobjects += 1
            return None
 
    # OVERLAY -------------------------------
    def overlay(self,x0,y0,
                name = None,
                filename = None,
                color = 1,
                colormax = None,
                ncolors = 4,
                beadtype = None,
                beadtype2 = None,
                ismask = False,
                fake = False
                ):
        &#34;&#34;&#34;
            overlay object: made from an image converted to nc colors
            the object is made from the level ranged between ic and jc (bounds included)
            note: if palette found, no conversion is applied
            
            O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
            O = overlay(....ismask=False,fake=False)
            
            Outputs:
                O.original original image (PIL)
                O.raw image converted to ncolors if needed
            
        &#34;&#34;&#34;
        if filename is None or filename==&#34;&#34;:
            raise ValueError(&#34;filename is required (valid image)&#34;)
        O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                    filename = filename,
                    xmin = x0,
                    ymin = y0,
                    ncolors = ncolors
                    )
        O.select(color=color, colormax=colormax)
        if (name is not None) and (name !=&#34;&#34;):
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            O.name = name
        else:
            name = O.name
        if beadtype is not None: O.beadtype = int(np.floor(beadtype))
        if beadtype2 is not None:
            if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
                raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
        O.beadtype2 = beadtype2
        if ismask: O.beadtype = 0
        O.ismask = O.beadtype==0
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;overlay&#34;] += 1
        if fake:
            self.counter[&#34;all&#34;] -= 1
            self.counter[&#34;overlay&#34;] -= 1
            return O
        else:
            self.objects[name] = O
            self.nobjects += 1
            return None      
    
    
    # COLLECTION ----------------------------
    def collection(self,*obj,
                   name=None,
                   beadtype=None,
                   ismask=None,
                   translate = [0.0,0.0],
                   fake = False,
                   **kwobj):
        &#34;&#34;&#34;
            collection of objects:
                collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
                collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
        &#34;&#34;&#34; 
        self.counter[&#34;all&#34;] += 1
        self.counter[&#34;collection&#34;] += 1
        C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
        # name
        if name != None:
            if self.exist(name):
                print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
                self.delete(name)
            C.name = name
        else:
            name = C.name
        # build the collection
        C.collection = collection(*obj,**kwobj)
        xmin = ymin = +1e99
        xmax = ymax = -1e99
        # apply modifications (beadtype, ismask)
        for o in C.collection.keys():
            tmp = C.collection.getattr(o)
            tmp.translate[0] += translate[0]
            tmp.translate[1] += translate[1]
            xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
            ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
            if beadtype != None: tmp.beadtype = beadtype
            if ismask != None: tmp.ismask = ismask
            C.collection.setattr(o,tmp)
        C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
        C.width, C.height = xmax-xmin, ymax-ymin
        if fake:
            return C
        else:
            self.objects[name] = C
            self.nobjects += 1
            return None
    
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # =========== pseudo methods connected to circle() ===========
    # TRIANGLE, DIAMOND, PENTAGON, HEXAGON, -----------------------     
    def triangle(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        triangle object 
            triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
           angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def diamond(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        diamond object 
            diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def pentagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        pentagon object 
            pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    def hexagon(self,xc,yc,radius,name=None,
                 shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
        &#34;&#34;&#34;
        hexagon object 
            hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
            use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
        &#34;&#34;&#34;
        self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
            angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)
        
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # label method ---------------------------- 
    def label(self,name,**fmt):
        &#34;&#34;&#34;
            label:
                label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        self.figure()
        if name in self.objects:
            if not self.objects[name].islabelled:
                if self.objects[name].alike == &#34;mixed&#34;:
                    for o in self.objects[name].collection:
                        self.labelobj(o,**fmt)
                else:
                    self.labelobj(self.objects[name],**fmt)
                plt.show()
                self.objects[name].islabelled = True
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
            
    # label object method -----------------------------
    def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
        &#34;&#34;&#34;
            labelobj:
                labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
        &#34;&#34;&#34;
        if contour: contour = obj.hascontour # e.g. overlays do not have contour
        
        if contour:
            patch = patches.PathPatch(obj.polygon2plot,
                                      facecolor=facecolor,
                                      edgecolor=edgecolor,
                                      lw=linewidth)
            obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
        else:
            obj.hlabel[&#34;contour&#34;] = None
        obj.hlabel[&#34;text&#34;] = \
        plt.text(obj.xcenter,
                 obj.ycenter,
                 &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
                 horizontalalignment = &#34;center&#34;,
                 verticalalignment = &#34;center_baseline&#34;,
                 fontsize=self.fontsize
                 )
        
   
    def unlabel(self,name):
        &#34;&#34;&#34; unlabel &#34;&#34;&#34;
        if name in self.objects:
            if  self.objects[name].islabelled:
                self.objects[name].hlabel[&#34;contour&#34;].remove()
                self.objects[name].hlabel[&#34;text&#34;].remove()
                self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
                self.objects[name].islabelled = False
        else:
            raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
        

    # PLOT method ---------------------------- 
    def plot(self):
        &#34;&#34;&#34; plot &#34;&#34;&#34;
        for o in self.objects:
            if not self.objects[o].isplotted:
                if self.objects[o].alike == &#34;mixed&#34;:
                    for o2 in self.objects[o].collection:
                        self.plotobj(o2)    
                else:
                    self.plotobj(self.objects[o])
                # store it as plotted
                self.objects[o].isplotted = True
                if not self.objects[o].ismask:
                    self.nbeads += self.objects[o].nbeads


    # PLOTobj method  -----------------------
    def plotobj(self,obj):
        &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
        if obj.alike == &#34;circle&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.polygon.contains_points(points)
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[k] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
                            
        elif obj.alike == &#34;overlay&#34;:
            xmin, ymin, xmax, ymax = self.frameobj(obj)
            j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
            points = np.vstack((j.flatten(),i.flatten())).T
            npoints = points.shape[0]
            inside = obj.select()
            if obj.beadtype2 is None:          # -- no salting --
                for k in range(npoints):
                    if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1
            else:
                for k in range(npoints):       # -- salting --
                    if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                        points[k,0]&gt;=0 and \
                        points[k,0]&lt;self.width and \
                        points[k,1]&gt;=0 and \
                        points[k,1]&lt;self.height:
                            if np.random.rand()&lt;obj.beadtype2[1]:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                            else:
                                self.imbead[points[k,1],points[k,0]] = obj.beadtype
                            self.imobj[points[k,1],points[k,0]] = obj.index
                            obj.nbeads += 1

        else:
            raise ValueError(&#34;This object type is notimplemented&#34;)        

    # SHOW method ---------------------------- 
    def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
        self.figure()
        if what==&#34;beadtype&#34;:
            imagesc(self.imbead)
        elif what == &#34;objindex&#34;:
            imagesc(self.imobj)
        else:
            raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)        
        if extra == &#34;label&#34;:
            ax = plt.gca()
            for o in self.names():
                if not self.objects[o].ismask:
                    self.label(o,ax=ax,contour=contour)
            ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                      (self.name,self.length(),self.nbeads) )
            plt.show()
            
    # SHOW method ---------------------------- 
    def print(self,what=&#34;beadtype&#34;):
        &#34;&#34;&#34; print method &#34;&#34;&#34;
        txt = self.string(what=what)
        for i in range(len(txt)):
            print(txt[i],end=&#34;\n&#34;)
         
            
    # FIGURE method ---------------------------- 
    def figure(self):
        &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
        if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
            self.newfigure()
        plt.figure(self.hfig.number)
    
    # NEWFIGURE method ---------------------------- 
    def newfigure(self):
        &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
        self.hfig = plt.figure(dpi=self.dpi)
        
    # COPY OBJECT ALONG a contour -----------------
    def copyalongpath(self,obj,
                      name=&#34;path&#34;,
                  beadtype=None,
                      path=linear,
                      xmin=10,
                      ymin=10,
                      xmax=70,
                      ymax=90,
                         n=7,
                      USER=struct()):
        &#34;&#34;&#34;
        
        The method enable to copy an existing object (from the current raster,
        from another raster or a fake object) amp,g 
        
        Parameters
        ----------
        obj : real or fake object
            the object to be copied.
        name : string, optional
            the name of the object collection. The default is &#34;path&#34;.
        beadtype : integet, optional
            type of bead (can override existing value). The default is None.
        path : function, optional
            parametric function returning x,y. The default is linear.
            x is between xmin and xmax, and y between ymin, ymax
        xmin : int64 or float, optional
            left x corner position. The default is 10.
        ymin : int64 or float, optional
            bottom y corner position. The default is 10.
        xmax : int64 or float, optional
            right x corner position. The default is 70.
        ymax : int64 or float, optional
            top y corner position. The default is 90.
        n : integet, optional
            number of copies. The default is 7.
     USER : structure to pass specific parameters

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if not isinstance(USER,struct):
            raise TypeError(&#34;USER should be a structure&#34;)
        x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
        btyp = obj.beadtype if beadtype == None else beadtype
        collect = {}
        for i in range(n):
            nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
            x[i], y[i] = self.valid(x[i], y[i])
            translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
            collect[nameobj] = obj.copy(translate=translate,
                                        name=nameobj,
                                        beadtype=btyp)
        self.collection(**collect,name=name)
     

    # SCATTER -------------------------------
    def scatter(self,
                 E,
                 name=&#34;emulsion&#34;,
                 beadtype=None,
                 ismask = False
                 ):
        &#34;&#34;&#34;
        

        Parameters
        ----------
        E : scatter or emulsion object
            codes for x,y and r.
        name : string, optional
            name of the collection. The default is &#34;emulsion&#34;.
        beadtype : integer, optional
            for all objects. The default is 1.
        ismask : logical, optional
            Set it to true to force a mask. The default is False.

        Raises
        ------
        TypeError
            Return an error of the object is not a scatter type.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        if isinstance(E,scatter):
            collect = {}
            for i in range(E.n):
                b = E.beadtype[i] if beadtype==None else beadtype
                nameobj = &#34;glob%02d&#34; % i
                collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                            name=nameobj,beadtype=b,ismask=ismask,fake=True)
            self.collection(**collect,name=name)
        else:
            raise TypeError(&#34;the first argument must be an emulsion object&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="raster.raster.circle"><code class="name flex">
<span>def <span class="ident">circle</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, resolution=20, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>circle object (or any regular polygon)
circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
use circle(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def circle(self,xc,yc,radius,
              name=None,shaperatio=1,angle=0,beadtype=None,ismask=False,
              resolution=20,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34; 
    circle object (or any regular polygon)
        circle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False], resolution=20, shiftangle=0)
        use circle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    # object creation
    self.counter[&#34;all&#34;] += 1
    if resolution==3:
        typ = &#34;triangle&#34;
        self.counter[&#34;triangle&#34;] += 1
        G = Triangle((self.counter[&#34;all&#34;],self.counter[&#34;triangle&#34;]))
    elif resolution==4:
        typ = &#34;diamond&#34;
        self.counter[&#34;diamond&#34;] += 1
        G = Diamond((self.counter[&#34;all&#34;],self.counter[&#34;diamond&#34;]))
    elif resolution==5:
        typ = &#34;pentagon&#34;
        self.counter[&#34;pentagon&#34;] += 1
        G = Pentagon((self.counter[&#34;all&#34;],self.counter[&#34;pentagon&#34;]))
    elif resolution==6:
        typ = &#34;hexagon&#34;
        self.counter[&#34;hexagon&#34;] += 1
        G = Hexagon((self.counter[&#34;all&#34;],self.counter[&#34;hexagon&#34;]))
    else:
        typ = &#34;circle&#34;
        self.counter[&#34;circle&#34;] += 1
        G = Circle((self.counter[&#34;all&#34;],self.counter[&#34;circle&#34;]),resolution=resolution)
    if (name != None) and (name != &#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        G.name = name
    else:
        name = G.name
    if beadtype is not None: G.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    G.beadtype2 = beadtype2
    if ismask: G.beadtype = 0
    G.ismask = G.beadtype==0
    # build vertices
    th = np.linspace(0,2*np.pi,G.resolution+1) +shiftangle*np.pi/180
    xgen = xc + radius * np.cos(th)
    ygen = yc + radius * shaperatio * np.sin(th)
    G.xcenter0, G.ycenter0, G.radius = xc, yc, radius
    G.vertices, G.codes = [], []
    for i in range(G.resolution+1):
        G.vertices.append(_rotate(xgen[i],ygen[i],xc,yc,angle))
        if i==0:
            G.codes.append(path.Path.MOVETO)
        elif i==G.resolution:
            G.codes.append(path.Path.CLOSEPOLY)        
        else:
            G.codes.append(path.Path.LINETO)
    G.nvertices = len(G.vertices)-1
    # build path object and range
    G.xmin0, G.ymin0, G.xmax0, G.ymax0 = G.corners()
    G.xmin0, G.ymin0 = self.valid(G.xmin0,G.ymin0)
    G.xmax0, G.ymax0 = self.valid(G.xmax0,G.ymax0)
    G.angle, G.shaperatio = angle, shaperatio
    # store the object
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[typ] -= 1
        return G
    else:
        self.objects[name] = G
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, what='nothing')</span>
</code></dt>
<dd>
<div class="desc"><p>clear the plotting area, use clear("all")) to remove all objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self,what=&#34;nothing&#34;):
    &#34;&#34;&#34; clear the plotting area, use clear(&#34;all&#34;)) to remove all objects &#34;&#34;&#34;
    self.imbead = np.zeros((self.height,self.width),dtype=np.int8)
    self.imobj = np.zeros((self.height,self.width),dtype=np.int8)
    for o in self.names():
        if what==&#34;all&#34;:
            self.delete(o)
        else:
            self.objects[o].isplotted = False
            self.objects[o].islabelled = False
            if not self.objects[o].ismask:
                self.nbeads -= self.objects[o].nbeads
            self.objects[o].nbeads = 0  # number of beads (plotted)
    self.figure()
    plt.cla()
    self.show()</code></pre>
</details>
</dd>
<dt id="raster.raster.collection"><code class="name flex">
<span>def <span class="ident">collection</span></span>(<span>self, *obj, name=None, beadtype=None, ismask=None, translate=[0.0, 0.0], fake=False, **kwobj)</span>
</code></dt>
<dd>
<div class="desc"><p>collection of objects:
collection(draftraster,name="mycollect" [,beadtype=1,ismask=True]
collection(name="mycollect",newobjname1 = obj1, newobjname2 = obj2&hellip;)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collection(self,*obj,
               name=None,
               beadtype=None,
               ismask=None,
               translate = [0.0,0.0],
               fake = False,
               **kwobj):
    &#34;&#34;&#34;
        collection of objects:
            collection(draftraster,name=&#34;mycollect&#34; [,beadtype=1,ismask=True]
            collection(name=&#34;mycollect&#34;,newobjname1 = obj1, newobjname2 = obj2...)
    &#34;&#34;&#34; 
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;collection&#34;] += 1
    C = Collection((self.counter[&#34;all&#34;],self.counter[&#34;collection&#34;]))
    # name
    if name != None:
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        C.name = name
    else:
        name = C.name
    # build the collection
    C.collection = collection(*obj,**kwobj)
    xmin = ymin = +1e99
    xmax = ymax = -1e99
    # apply modifications (beadtype, ismask)
    for o in C.collection.keys():
        tmp = C.collection.getattr(o)
        tmp.translate[0] += translate[0]
        tmp.translate[1] += translate[1]
        xmin, xmax = min(xmin,tmp.xmin), max(xmax,tmp.xmax)
        ymin, ymax = min(ymin,tmp.ymin), max(ymax,tmp.ymax)
        if beadtype != None: tmp.beadtype = beadtype
        if ismask != None: tmp.ismask = ismask
        C.collection.setattr(o,tmp)
    C.xmin, C.xmax, C.ymin, C.ymax = xmin, xmax, ymin, ymax
    C.width, C.height = xmax-xmin, ymax-ymin
    if fake:
        return C
    else:
        self.objects[name] = C
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.copyalongpath"><code class="name flex">
<span>def <span class="ident">copyalongpath</span></span>(<span>self, obj, name='path', beadtype=None, path=&lt;function linear&gt;, xmin=10, ymin=10, xmax=70, ymax=90, n=7, USER=empty structure)</span>
</code></dt>
<dd>
<div class="desc"><p>The method enable to copy an existing object (from the current raster,
from another raster or a fake object) amp,g </p>
<p>Parameters</p>
<hr>
<p>obj : real or fake object
the object to be copied.
name : string, optional
the name of the object collection. The default is "path".
beadtype : integet, optional
type of bead (can override existing value). The default is None.
path : function, optional
parametric function returning x,y. The default is linear.
x is between xmin and xmax, and y between ymin, ymax
xmin : int64 or float, optional
left x corner position. The default is 10.
ymin : int64 or float, optional
bottom y corner position. The default is 10.
xmax : int64 or float, optional
right x corner position. The default is 70.
ymax : int64 or float, optional
top y corner position. The default is 90.
n : integet, optional
number of copies. The default is 7.
USER : structure to pass specific parameters</p>
<p>Returns</p>
<hr>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyalongpath(self,obj,
                  name=&#34;path&#34;,
              beadtype=None,
                  path=linear,
                  xmin=10,
                  ymin=10,
                  xmax=70,
                  ymax=90,
                     n=7,
                  USER=struct()):
    &#34;&#34;&#34;
    
    The method enable to copy an existing object (from the current raster,
    from another raster or a fake object) amp,g 
    
    Parameters
    ----------
    obj : real or fake object
        the object to be copied.
    name : string, optional
        the name of the object collection. The default is &#34;path&#34;.
    beadtype : integet, optional
        type of bead (can override existing value). The default is None.
    path : function, optional
        parametric function returning x,y. The default is linear.
        x is between xmin and xmax, and y between ymin, ymax
    xmin : int64 or float, optional
        left x corner position. The default is 10.
    ymin : int64 or float, optional
        bottom y corner position. The default is 10.
    xmax : int64 or float, optional
        right x corner position. The default is 70.
    ymax : int64 or float, optional
        top y corner position. The default is 90.
    n : integet, optional
        number of copies. The default is 7.
 USER : structure to pass specific parameters

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if not isinstance(USER,struct):
        raise TypeError(&#34;USER should be a structure&#34;)
    x,y = path(xmin=xmin,ymin=ymin,xmax=xmax,ymax=ymax,n=n,USER=USER)
    btyp = obj.beadtype if beadtype == None else beadtype
    collect = {}
    for i in range(n):
        nameobj = &#34;%s_%s_%02d&#34; % (name,obj.name,i)
        x[i], y[i] = self.valid(x[i], y[i])
        translate = [ x[i]-obj.xcenter, y[i]-obj.ycenter ]
        collect[nameobj] = obj.copy(translate=translate,
                                    name=nameobj,
                                    beadtype=btyp)
    self.collection(**collect,name=name)</code></pre>
</details>
</dd>
<dt id="raster.raster.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>count objects by type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count(self):
    &#34;&#34;&#34; count objects by type &#34;&#34;&#34;
    typlist = []
    for  o in self.names():
        if isinstance(self.objects[o].beadtype,list):
            typlist += self.objects[o].beadtype
        else:
            typlist.append(self.objects[o].beadtype)
    utypes = list(set(typlist))
    c = []
    for t in utypes:
        c.append((t,typlist.count(t)))
    return c</code></pre>
</details>
</dd>
<dt id="raster.raster.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self, scale=(1, 1), center=(0, 0), maxtype=None)</span>
</code></dt>
<dd>
<div class="desc"><p>data()
data(scale=(scalex,scaley),center=(centerx,centery),maxtype=number)
return a pizza.data object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self,scale=(1,1),center=(0,0),maxtype=None):
    &#34;&#34;&#34;
    data()
    data(scale=(scalex,scaley),center=(centerx,centery),maxtype=number)
    return a pizza.data object  &#34;&#34;&#34;
    if not isinstance(scale,tuple) or len(scale)!=2:
        raise ValueError(&#34;scale must be tuple (scalex,scaley)&#34;)
    if not isinstance(center,tuple) or len(scale)!=2:
        raise ValueError(&#34;center must be tuple (centerx,centery)&#34;)
    scalez = np.sqrt(scale[0]*scale[1])
    scalevol = scale[0]*scale[1] #*scalez
    maxtypeheader = self.count()[-1][0] if maxtype is None else maxtype
    n = self.length()
    i,j = self.imbead.nonzero() # x=j+0.5 y=i+0.5
    X = data3()  # empty pizza.data3.data object
    X.title = self.name + &#34;(raster)&#34;
    X.headers = {&#39;atoms&#39;: n,
                  &#39;atom types&#39;: maxtypeheader,
                  &#39;xlo xhi&#39;: ((0.0-center[0])*scale[0], (self.width-0.0-center[0])*scale[0]),
                  &#39;ylo yhi&#39;: ((0.0-center[1])*scale[1], (self.height-0.0-center[1])*scale[1]),
                  &#39;zlo zhi&#39;: (0, scalez)}
    # [ATOMS] section
    X.append(&#39;Atoms&#39;,list(range(1,n+1)),True,&#34;id&#34;)       # id
    X.append(&#39;Atoms&#39;,self.imbead[i,j],True,&#34;type&#34;)       # Type
    X.append(&#39;Atoms&#39;,1,True,&#34;mol&#34;)                       # mol
    X.append(&#39;Atoms&#39;,self.volume*scalevol,False,&#34;c_vol&#34;) # c_vol
    X.append(&#39;Atoms&#39;,self.mass*scalevol,False,&#34;mass&#34;)    # mass
    X.append(&#39;Atoms&#39;,self.radius*scalez,False,&#34;radius&#34;)         # radius
    X.append(&#39;Atoms&#39;,self.contactradius*scalez,False,&#34;c_contact_radius&#34;) # c_contact_radius
    X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x&#34;)        # x
    X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y&#34;)        # y
    X.append(&#39;Atoms&#39;,0,False,&#34;z&#34;)                                 # z
    X.append(&#39;Atoms&#39;,(j+0.5-center[0])*scale[0],False,&#34;x0&#34;)       # x0
    X.append(&#39;Atoms&#39;,(i+0.5-center[1])*scale[1],False,&#34;y0&#34;)       # y0
    X.append(&#39;Atoms&#39;,0,False,&#34;z0&#34;)                                # z0
    # [VELOCITIES] section
    X.append(&#39;Velocities&#39;,list(range(1,n+1)),True,&#34;id&#34;) # id
    X.append(&#39;Velocities&#39;,self.velocities[0],False,&#34;vx&#34;) # vx
    X.append(&#39;Velocities&#39;,self.velocities[1],False,&#34;vy&#34;) # vy
    X.append(&#39;Velocities&#39;,self.velocities[2],False,&#34;vz&#34;) # vz
    # pseudo-filename        
    X.flist = self.filename
    return X</code></pre>
</details>
</dd>
<dt id="raster.raster.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>delete object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self,name):
    &#34;&#34;&#34; delete object &#34;&#34;&#34;
    if name in self.objects: 
        if not self.objects[name].ismask:
            self.nbeads -= self.objects[name].nbeads
        del self.objects[name]
        self.nobjects -= 1
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)
    self.clear()
    self.plot()
    self.show(extra=&#34;label&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.diamond"><code class="name flex">
<span>def <span class="ident">diamond</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>diamond object
diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use diamond(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diamond(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    diamond object 
        diamond(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use diamond(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=4,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.exist"><code class="name flex">
<span>def <span class="ident">exist</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>exist object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exist(self,name):
    &#34;&#34;&#34; exist object &#34;&#34;&#34;
    return name in self.objects</code></pre>
</details>
</dd>
<dt id="raster.raster.figure"><code class="name flex">
<span>def <span class="ident">figure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set the current figure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def figure(self):
    &#34;&#34;&#34; set the current figure &#34;&#34;&#34;
    if self.hfig==[] or not plt.fignum_exists(self.hfig.number):
        self.newfigure()
    plt.figure(self.hfig.number)</code></pre>
</details>
</dd>
<dt id="raster.raster.frameobj"><code class="name flex">
<span>def <span class="ident">frameobj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>frame coordinates by taking into account translation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frameobj(self,obj):
    &#34;&#34;&#34; frame coordinates by taking into account translation &#34;&#34;&#34;
    if obj.hasclosefit:
        envelope = 0
    else:
        envelope = 1
    xmin, ymin = self.valid(obj.xmin-envelope, obj.ymin-envelope)
    xmax, ymax = self.valid(obj.xmax+envelope, obj.ymax+envelope)
    return xmin, ymin, xmax, ymax</code></pre>
</details>
</dd>
<dt id="raster.raster.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self,name):
    &#34;&#34;&#34; returns the object &#34;&#34;&#34;
    if name in self.objects:
        return self.objects[name]
    else:
        raise ValueError(&#39;the object &#34;%s&#34; does not exist, use list()&#39; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.hexagon"><code class="name flex">
<span>def <span class="ident">hexagon</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>hexagon object
hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use hexagon(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hexagon(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    hexagon object 
        hexagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use hexagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=6,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, name, **fmt)</span>
</code></dt>
<dd>
<div class="desc"><p>label:
label(name [, contour=True,edgecolor="orange",facecolor="none",linewidth=2, ax=plt.gca()])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self,name,**fmt):
    &#34;&#34;&#34;
        label:
            label(name [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
    &#34;&#34;&#34;
    self.figure()
    if name in self.objects:
        if not self.objects[name].islabelled:
            if self.objects[name].alike == &#34;mixed&#34;:
                for o in self.objects[name].collection:
                    self.labelobj(o,**fmt)
            else:
                self.labelobj(self.objects[name],**fmt)
            plt.show()
            self.objects[name].islabelled = True
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.labelobj"><code class="name flex">
<span>def <span class="ident">labelobj</span></span>(<span>self, obj, contour=True, edgecolor='orange', facecolor='none', linewidth=2, ax=&lt;AxesSubplot:&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>labelobj:
labelobj(obj [, contour=True,edgecolor="orange",facecolor="none",linewidth=2, ax=plt.gca()])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def labelobj(self,obj,contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2,ax=plt.gca()):
    &#34;&#34;&#34;
        labelobj:
            labelobj(obj [, contour=True,edgecolor=&#34;orange&#34;,facecolor=&#34;none&#34;,linewidth=2, ax=plt.gca()])
    &#34;&#34;&#34;
    if contour: contour = obj.hascontour # e.g. overlays do not have contour
    
    if contour:
        patch = patches.PathPatch(obj.polygon2plot,
                                  facecolor=facecolor,
                                  edgecolor=edgecolor,
                                  lw=linewidth)
        obj.hlabel[&#34;contour&#34;] = ax.add_patch(patch)
    else:
        obj.hlabel[&#34;contour&#34;] = None
    obj.hlabel[&#34;text&#34;] = \
    plt.text(obj.xcenter,
             obj.ycenter,
             &#34;%s\n(t=$%d$,$n_p$=%d)&#34; % (obj.name, obj.beadtype,obj.nbeads),
             horizontalalignment = &#34;center&#34;,
             verticalalignment = &#34;center_baseline&#34;,
             fontsize=self.fontsize
             )</code></pre>
</details>
</dd>
<dt id="raster.raster.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self, t=None, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>returns the total number of beads length(type,"beadtype")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self,t=None,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; returns the total number of beads length(type,&#34;beadtype&#34;) &#34;&#34;&#34;
    if what == &#34;beadtype&#34;:
        num = self.imbead
    elif what == &#34;objindex&#34;:
        num = self.imobj
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    if t==None:
        return np.count_nonzero(num&gt;0)
    else:
        return np.count_nonzero(num==t)</code></pre>
</details>
</dd>
<dt id="raster.raster.list"><code class="name flex">
<span>def <span class="ident">list</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>list objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list(self):
    &#34;&#34;&#34; list objects &#34;&#34;&#34;
    fmt = &#34;%%%ss:&#34; % max(10,max([len(n) for n in self.names()])+2)
    print(&#34;RASTER with %d objects&#34; % self.nobjects)
    for o in self.objects.keys():
        print(fmt % self.objects[o].name,&#34;%-10s&#34; % self.objects[o].kind,
              &#34;(beadtype=%d,object index=[%d,%d], n=%d)&#34; % \
                  (self.objects[o].beadtype,
                   self.objects[o].index,
                   self.objects[o].subindex,
                   self.objects[o].nbeads))</code></pre>
</details>
</dd>
<dt id="raster.raster.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return the names of objects sorted as index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self):
    &#34;&#34;&#34; return the names of objects sorted as index &#34;&#34;&#34;
    namesunsorted=namessorted=list(self.objects.keys())
    nobj = len(namesunsorted)
    for iobj in range(nobj):
        namessorted[self.objects[namesunsorted[iobj]].index-1] = namesunsorted[iobj]
    return namessorted</code></pre>
</details>
</dd>
<dt id="raster.raster.newfigure"><code class="name flex">
<span>def <span class="ident">newfigure</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>create a new figure (dpi=200)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newfigure(self):
    &#34;&#34;&#34; create a new figure (dpi=200) &#34;&#34;&#34;
    self.hfig = plt.figure(dpi=self.dpi)</code></pre>
</details>
</dd>
<dt id="raster.raster.numeric"><code class="name flex">
<span>def <span class="ident">numeric</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>retrieve the image as a numpy.array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def numeric(self):
    &#34;&#34;&#34; retrieve the image as a numpy.array &#34;&#34;&#34;
    return self.imbead, self.imobj</code></pre>
</details>
</dd>
<dt id="raster.raster.overlay"><code class="name flex">
<span>def <span class="ident">overlay</span></span>(<span>self, x0, y0, name=None, filename=None, color=1, colormax=None, ncolors=4, beadtype=None, beadtype2=None, ismask=False, fake=False)</span>
</code></dt>
<dd>
<div class="desc"><p>overlay object: made from an image converted to nc colors
the object is made from the level ranged between ic and jc (bounds included)
note: if palette found, no conversion is applied</p>
<p>O = overlay(x0,y0,filename="/this/is/my/image.png",ncolors=nc,color=ic,colormax=jc,beadtype=b)
O = overlay(....ismask=False,fake=False)</p>
<h2 id="outputs">Outputs</h2>
<p>O.original original image (PIL)
O.raw image converted to ncolors if needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overlay(self,x0,y0,
            name = None,
            filename = None,
            color = 1,
            colormax = None,
            ncolors = 4,
            beadtype = None,
            beadtype2 = None,
            ismask = False,
            fake = False
            ):
    &#34;&#34;&#34;
        overlay object: made from an image converted to nc colors
        the object is made from the level ranged between ic and jc (bounds included)
        note: if palette found, no conversion is applied
        
        O = overlay(x0,y0,filename=&#34;/this/is/my/image.png&#34;,ncolors=nc,color=ic,colormax=jc,beadtype=b)
        O = overlay(....ismask=False,fake=False)
        
        Outputs:
            O.original original image (PIL)
            O.raw image converted to ncolors if needed
        
    &#34;&#34;&#34;
    if filename is None or filename==&#34;&#34;:
        raise ValueError(&#34;filename is required (valid image)&#34;)
    O = overlay(counter=(self.counter[&#34;all&#34;]+1,self.counter[&#34;overlay&#34;]+1),
                filename = filename,
                xmin = x0,
                ymin = y0,
                ncolors = ncolors
                )
    O.select(color=color, colormax=colormax)
    if (name is not None) and (name !=&#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        O.name = name
    else:
        name = O.name
    if beadtype is not None: O.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    O.beadtype2 = beadtype2
    if ismask: O.beadtype = 0
    O.ismask = O.beadtype==0
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;overlay&#34;] += 1
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[&#34;overlay&#34;] -= 1
        return O
    else:
        self.objects[name] = O
        self.nobjects += 1
        return None      </code></pre>
</details>
</dd>
<dt id="raster.raster.pentagon"><code class="name flex">
<span>def <span class="ident">pentagon</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>pentagon object
pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use pentagon(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pentagon(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    pentagon object 
        pentagon(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use pentagon(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=5,
        angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self):
    &#34;&#34;&#34; plot &#34;&#34;&#34;
    for o in self.objects:
        if not self.objects[o].isplotted:
            if self.objects[o].alike == &#34;mixed&#34;:
                for o2 in self.objects[o].collection:
                    self.plotobj(o2)    
            else:
                self.plotobj(self.objects[o])
            # store it as plotted
            self.objects[o].isplotted = True
            if not self.objects[o].ismask:
                self.nbeads += self.objects[o].nbeads</code></pre>
</details>
</dd>
<dt id="raster.raster.plotobj"><code class="name flex">
<span>def <span class="ident">plotobj</span></span>(<span>self, obj)</span>
</code></dt>
<dd>
<div class="desc"><p>plotobj(obj)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotobj(self,obj):
    &#34;&#34;&#34; plotobj(obj) &#34;&#34;&#34;
    if obj.alike == &#34;circle&#34;:
        xmin, ymin, xmax, ymax = self.frameobj(obj)
        j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
        points = np.vstack((j.flatten(),i.flatten())).T
        npoints = points.shape[0]
        inside = obj.polygon.contains_points(points)
        if obj.beadtype2 is None:          # -- no salting --
            for k in range(npoints):
                if inside[k] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1
        else:
            for k in range(npoints):       # -- salting --
                if inside[k] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        if np.random.rand()&lt;obj.beadtype2[1]:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                        else:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1
                        
    elif obj.alike == &#34;overlay&#34;:
        xmin, ymin, xmax, ymax = self.frameobj(obj)
        j,i = np.meshgrid(range(xmin,xmax), range(ymin,ymax))
        points = np.vstack((j.flatten(),i.flatten())).T
        npoints = points.shape[0]
        inside = obj.select()
        if obj.beadtype2 is None:          # -- no salting --
            for k in range(npoints):
                if inside[ points[k,1]-ymin, points[k,0]-xmin ] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1
        else:
            for k in range(npoints):       # -- salting --
                if inside[ points[k,0]-ymin, points[k,0]-xmin ] and \
                    points[k,0]&gt;=0 and \
                    points[k,0]&lt;self.width and \
                    points[k,1]&gt;=0 and \
                    points[k,1]&lt;self.height:
                        if np.random.rand()&lt;obj.beadtype2[1]:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype2[0]
                        else:
                            self.imbead[points[k,1],points[k,0]] = obj.beadtype
                        self.imobj[points[k,1],points[k,0]] = obj.index
                        obj.nbeads += 1

    else:
        raise ValueError(&#34;This object type is notimplemented&#34;)        </code></pre>
</details>
</dd>
<dt id="raster.raster.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>print method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; print method &#34;&#34;&#34;
    txt = self.string(what=what)
    for i in range(len(txt)):
        print(txt[i],end=&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.rectangle"><code class="name flex">
<span>def <span class="ident">rectangle</span></span>(<span>self, a, b, c, d, mode='lowerleft', name=None, angle=0, beadtype=None, ismask=False, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>rectangle object
rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode="lower", angle=0, ismask=False])
rectangle(xcenter,ycenter,width,height [, beadtype=1,mode="center", angle=0, ismask=False])</p>
<pre><code>use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
from another type and with a given ratio
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rectangle(self,a,b,c,d,
              mode=&#34;lowerleft&#34;,name=None,angle=0,
              beadtype=None,ismask=False,fake=False,beadtype2=None):
    &#34;&#34;&#34; 
    rectangle object
        rectangle(xleft,xright,ybottom,ytop [, beadtype=1,mode=&#34;lower&#34;, angle=0, ismask=False])
        rectangle(xcenter,ycenter,width,height [, beadtype=1,mode=&#34;center&#34;, angle=0, ismask=False])
        
        use rectangle(...,beadtype2=(type,ratio)) to salt an object with beads
        from another type and with a given ratio
    &#34;&#34;&#34;
    # object creation
    self.counter[&#34;all&#34;] += 1
    self.counter[&#34;rectangle&#34;] += 1
    R = Rectangle((self.counter[&#34;all&#34;],self.counter[&#34;rectangle&#34;]))
    if (name != None) and (name != &#34;&#34;):
        if self.exist(name):
            print(&#39;RASTER:: the object &#34;%s&#34; is overwritten&#39;,name)
            self.delete(name)
        R.name = name
    else:
        name = R.name
    if beadtype is not None: R.beadtype = int(np.floor(beadtype))
    if beadtype2 is not None:
        if not isinstance(beadtype2,tuple) or len(beadtype2)!=2:
            raise AttributeError(&#34;beadtype2 must be a tuple (beadtype,ratio)&#34;)
    R.beadtype2 = beadtype2
    if ismask: R.beadtype = 0
    R.ismask = R.beadtype==0
    # build vertices
    if mode == &#34;lowerleft&#34;:
        R.xcenter0 = (a+b)/2
        R.ycenter0 = (c+d)/2
        R.vertices = [
            _rotate(a,c,R.xcenter0,R.ycenter0,angle),
            _rotate(b,c,R.xcenter0,R.ycenter0,angle),
            _rotate(b,d,R.xcenter0,R.ycenter0,angle),
            _rotate(a,d,R.xcenter0,R.ycenter0,angle),
            _rotate(a,c,R.xcenter0,R.ycenter0,angle)
            ] # anti-clockwise, closed (last point repeated)
    elif mode == &#34;center&#34;:
        R.xcenter0 = a
        R.ycenter0 = b
        R.vertices = [
            _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a+c/2,b-d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a+c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a-c/2,b+d/2,R.xcenter0,R.ycenter0,angle),
            _rotate(a-c/2,b-d/2,R.xcenter0,R.ycenter0,angle)
            ]
    else:
        raise ValueError(&#39;&#34;%s&#34; is not a recognized mode, use &#34;lowerleft&#34; (default) and &#34;center&#34; instead&#39;)
    # build path object and range
    R.codes =    [ path.Path.MOVETO,
                 path.Path.LINETO,
                 path.Path.LINETO,
                 path.Path.LINETO,
                 path.Path.CLOSEPOLY
                ]
    R.nvertices = len(R.vertices)-1
    R.xmin0, R.ymin0, R.xmax0, R.ymax0 = R.corners()        
    R.xmin0, R.ymin0 = self.valid(R.xmin0,R.ymin0)
    R.xmax0, R.ymax0 = self.valid(R.xmax0,R.ymax0)
    R.angle = angle
    # store the object (if not fake)
    if fake:
        self.counter[&#34;all&#34;] -= 1
        self.counter[&#34;rectangle&#34;] -= 1
        return R
    else:
        self.objects[name] = R
        self.nobjects += 1
        return None</code></pre>
</details>
</dd>
<dt id="raster.raster.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>self, E, name='emulsion', beadtype=None, ismask=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>E</code></strong> :&ensp;<code><a title="raster.scatter" href="#raster.scatter">scatter</a></code> or <code><a title="raster.emulsion" href="#raster.emulsion">emulsion</a> object</code></dt>
<dd>codes for x,y and r.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>name of the collection. The default is "emulsion".</dd>
<dt><strong><code>beadtype</code></strong> :&ensp;<code>integer</code>, optional</dt>
<dd>for all objects. The default is 1.</dd>
<dt><strong><code>ismask</code></strong> :&ensp;<code>logical</code>, optional</dt>
<dd>Set it to true to force a mask. The default is False.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Return an error of the object is not a scatter type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scatter(self,
             E,
             name=&#34;emulsion&#34;,
             beadtype=None,
             ismask = False
             ):
    &#34;&#34;&#34;
    

    Parameters
    ----------
    E : scatter or emulsion object
        codes for x,y and r.
    name : string, optional
        name of the collection. The default is &#34;emulsion&#34;.
    beadtype : integer, optional
        for all objects. The default is 1.
    ismask : logical, optional
        Set it to true to force a mask. The default is False.

    Raises
    ------
    TypeError
        Return an error of the object is not a scatter type.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    if isinstance(E,scatter):
        collect = {}
        for i in range(E.n):
            b = E.beadtype[i] if beadtype==None else beadtype
            nameobj = &#34;glob%02d&#34; % i
            collect[nameobj] = self.circle(E.x[i],E.y[i],E.r[i],
                        name=nameobj,beadtype=b,ismask=ismask,fake=True)
        self.collection(**collect,name=name)
    else:
        raise TypeError(&#34;the first argument must be an emulsion object&#34;)</code></pre>
</details>
</dd>
<dt id="raster.raster.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, extra='none', contour=True, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>show method: show(extra="label",contour=True,what="beadtype")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self,extra=&#34;none&#34;,contour=True,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; show method: show(extra=&#34;label&#34;,contour=True,what=&#34;beadtype&#34;) &#34;&#34;&#34;
    self.figure()
    if what==&#34;beadtype&#34;:
        imagesc(self.imbead)
    elif what == &#34;objindex&#34;:
        imagesc(self.imobj)
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)        
    if extra == &#34;label&#34;:
        ax = plt.gca()
        for o in self.names():
            if not self.objects[o].ismask:
                self.label(o,ax=ax,contour=contour)
        ax.set_title(&#34;raster area: %s \n (n=%d, $n_p$=%d)&#34; %\
                  (self.name,self.length(),self.nbeads) )
        plt.show()</code></pre>
</details>
</dd>
<dt id="raster.raster.string"><code class="name flex">
<span>def <span class="ident">string</span></span>(<span>self, what='beadtype')</span>
</code></dt>
<dd>
<div class="desc"><p>convert the image as ASCII strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string(self,what=&#34;beadtype&#34;):
    &#34;&#34;&#34; convert the image as ASCII strings &#34;&#34;&#34;
    if what == &#34;beadtype&#34;:
        num = np.flipud(duplicate(self.imbead))
    elif what == &#34;objindex&#34;:
        num = np.flipud(duplicate(self.imobj))
    else:
        raise ValueError(&#39;&#34;beadtype&#34; and &#34;objindex&#34; are the only acceptable values&#39;)
    num[num&gt;0] = num[num&gt;0] + 65
    num[num==0] = 32
    num = list(num)
    return [&#34;&#34;.join(map(chr,x)) for x in num]</code></pre>
</details>
</dd>
<dt id="raster.raster.triangle"><code class="name flex">
<span>def <span class="ident">triangle</span></span>(<span>self, xc, yc, radius, name=None, shaperatio=1, angle=0, beadtype=None, ismask=False, shiftangle=0, fake=False, beadtype2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>triangle object
triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
use triangle(&hellip;,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle(self,xc,yc,radius,name=None,
             shaperatio=1,angle=0,beadtype=None,ismask=False,shiftangle=0,fake=False,beadtype2=None):
    &#34;&#34;&#34;
    triangle object 
        triangle(xcenter,ycenter,radius [, beadtype=1,shaperatio=1, angle=0, ismask=False]
        use triangle(...,beadtype2=(type,ratio)) to salt an object with beads from another type and with a given ratio
    &#34;&#34;&#34;
    self.circle(xc,yc,radius,name=name,shaperatio=shaperatio,resolution=3,
       angle=angle,beadtype=beadtype,ismask=ismask,shiftangle=0,fake=fake,beadtype2=beadtype2)</code></pre>
</details>
</dd>
<dt id="raster.raster.unlabel"><code class="name flex">
<span>def <span class="ident">unlabel</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>unlabel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlabel(self,name):
    &#34;&#34;&#34; unlabel &#34;&#34;&#34;
    if name in self.objects:
        if  self.objects[name].islabelled:
            self.objects[name].hlabel[&#34;contour&#34;].remove()
            self.objects[name].hlabel[&#34;text&#34;].remove()
            self.objects[name].hlabel = {&#39;contour&#39;:[], &#39;text&#39;:[]}
            self.objects[name].islabelled = False
    else:
        raise ValueError(&#34;%d is not a valid name (use list()) to list valid objects&#34; % name)</code></pre>
</details>
</dd>
<dt id="raster.raster.valid"><code class="name flex">
<span>def <span class="ident">valid</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>validation of coordinates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valid(self,x,y):
    &#34;&#34;&#34; validation of coordinates &#34;&#34;&#34;
    return min(self.width,max(0,round(x))),min(self.height,max(0,round(y)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="raster.scatter"><code class="flex name class">
<span>class <span class="ident">scatter</span></span>
</code></dt>
<dd>
<div class="desc"><p>generic top scatter class </p>
<p>The scatter class provides an easy constructor
to distribute in space objects according to their
positions x,y, size r (radius) and beadtype.</p>
<p>The class is used to derive emulsions.</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class scatter():
    &#34;&#34;&#34; generic top scatter class &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        The scatter class provides an easy constructor
        to distribute in space objects according to their
        positions x,y, size r (radius) and beadtype.
        
        The class is used to derive emulsions.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.x = np.array([],dtype=int) 
        self.y = np.array([],dtype=int)
        self.r = np.array([],dtype=int)
        self.beadtype = []
        
    @property
    def n(self):
        return len(self.x)
    
    def pairdist(self,x,y):
        &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
        if self.n==0:
            return np.Inf
        else:
            return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="raster.scatter.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n(self):
    return len(self.x)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="raster.scatter.pairdist"><code class="name flex">
<span>def <span class="ident">pairdist</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>pair distance to the surface of all disks/spheres</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pairdist(self,x,y):
    &#34;&#34;&#34; pair distance to the surface of all disks/spheres &#34;&#34;&#34;
    if self.n==0:
        return np.Inf
    else:
        return np.floor(np.sqrt((x-self.x)**2+(y-self.y)**2)-self.r)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="raster.arc" href="#raster.arc">arc</a></code></li>
<li><code><a title="raster.imagesc" href="#raster.imagesc">imagesc</a></code></li>
<li><code><a title="raster.linear" href="#raster.linear">linear</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="raster.Circle" href="#raster.Circle">Circle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Collection" href="#raster.Collection">Collection</a></code></h4>
<ul class="">
<li><code><a title="raster.Collection.beadtype" href="#raster.Collection.beadtype">beadtype</a></code></li>
<li><code><a title="raster.Collection.get" href="#raster.Collection.get">get</a></code></li>
<li><code><a title="raster.Collection.xcenter" href="#raster.Collection.xcenter">xcenter</a></code></li>
<li><code><a title="raster.Collection.xycenter" href="#raster.Collection.xycenter">xycenter</a></code></li>
<li><code><a title="raster.Collection.ycenter" href="#raster.Collection.ycenter">ycenter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.Diamond" href="#raster.Diamond">Diamond</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Hexagon" href="#raster.Hexagon">Hexagon</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Pentagon" href="#raster.Pentagon">Pentagon</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Rectangle" href="#raster.Rectangle">Rectangle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.Triangle" href="#raster.Triangle">Triangle</a></code></h4>
</li>
<li>
<h4><code><a title="raster.collection" href="#raster.collection">collection</a></code></h4>
</li>
<li>
<h4><code><a title="raster.coregeometry" href="#raster.coregeometry">coregeometry</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.coregeometry.copy" href="#raster.coregeometry.copy">copy</a></code></li>
<li><code><a title="raster.coregeometry.height" href="#raster.coregeometry.height">height</a></code></li>
<li><code><a title="raster.coregeometry.width" href="#raster.coregeometry.width">width</a></code></li>
<li><code><a title="raster.coregeometry.xcenter" href="#raster.coregeometry.xcenter">xcenter</a></code></li>
<li><code><a title="raster.coregeometry.xmax" href="#raster.coregeometry.xmax">xmax</a></code></li>
<li><code><a title="raster.coregeometry.xmin" href="#raster.coregeometry.xmin">xmin</a></code></li>
<li><code><a title="raster.coregeometry.ycenter" href="#raster.coregeometry.ycenter">ycenter</a></code></li>
<li><code><a title="raster.coregeometry.ymax" href="#raster.coregeometry.ymax">ymax</a></code></li>
<li><code><a title="raster.coregeometry.ymin" href="#raster.coregeometry.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.coreshell" href="#raster.coreshell">coreshell</a></code></h4>
<ul class="">
<li><code><a title="raster.coreshell.insertion" href="#raster.coreshell.insertion">insertion</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.emulsion" href="#raster.emulsion">emulsion</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.emulsion.accepted" href="#raster.emulsion.accepted">accepted</a></code></li>
<li><code><a title="raster.emulsion.dist" href="#raster.emulsion.dist">dist</a></code></li>
<li><code><a title="raster.emulsion.insertion" href="#raster.emulsion.insertion">insertion</a></code></li>
<li><code><a title="raster.emulsion.insertone" href="#raster.emulsion.insertone">insertone</a></code></li>
<li><code><a title="raster.emulsion.rand" href="#raster.emulsion.rand">rand</a></code></li>
<li><code><a title="raster.emulsion.setbeadtype" href="#raster.emulsion.setbeadtype">setbeadtype</a></code></li>
<li><code><a title="raster.emulsion.walldist" href="#raster.emulsion.walldist">walldist</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.genericpolygon" href="#raster.genericpolygon">genericpolygon</a></code></h4>
<ul class="">
<li><code><a title="raster.genericpolygon.corners" href="#raster.genericpolygon.corners">corners</a></code></li>
<li><code><a title="raster.genericpolygon.hasclosefit" href="#raster.genericpolygon.hasclosefit">hasclosefit</a></code></li>
<li><code><a title="raster.genericpolygon.hascontour" href="#raster.genericpolygon.hascontour">hascontour</a></code></li>
<li><code><a title="raster.genericpolygon.polygon" href="#raster.genericpolygon.polygon">polygon</a></code></li>
<li><code><a title="raster.genericpolygon.polygon2plot" href="#raster.genericpolygon.polygon2plot">polygon2plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.overlay" href="#raster.overlay">overlay</a></code></h4>
<ul class="">
<li><code><a title="raster.overlay.hasclosefit" href="#raster.overlay.hasclosefit">hasclosefit</a></code></li>
<li><code><a title="raster.overlay.hascontour" href="#raster.overlay.hascontour">hascontour</a></code></li>
<li><code><a title="raster.overlay.load" href="#raster.overlay.load">load</a></code></li>
<li><code><a title="raster.overlay.select" href="#raster.overlay.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.raster" href="#raster.raster">raster</a></code></h4>
<ul class="two-column">
<li><code><a title="raster.raster.circle" href="#raster.raster.circle">circle</a></code></li>
<li><code><a title="raster.raster.clear" href="#raster.raster.clear">clear</a></code></li>
<li><code><a title="raster.raster.collection" href="#raster.raster.collection">collection</a></code></li>
<li><code><a title="raster.raster.copyalongpath" href="#raster.raster.copyalongpath">copyalongpath</a></code></li>
<li><code><a title="raster.raster.count" href="#raster.raster.count">count</a></code></li>
<li><code><a title="raster.raster.data" href="#raster.raster.data">data</a></code></li>
<li><code><a title="raster.raster.delete" href="#raster.raster.delete">delete</a></code></li>
<li><code><a title="raster.raster.diamond" href="#raster.raster.diamond">diamond</a></code></li>
<li><code><a title="raster.raster.exist" href="#raster.raster.exist">exist</a></code></li>
<li><code><a title="raster.raster.figure" href="#raster.raster.figure">figure</a></code></li>
<li><code><a title="raster.raster.frameobj" href="#raster.raster.frameobj">frameobj</a></code></li>
<li><code><a title="raster.raster.get" href="#raster.raster.get">get</a></code></li>
<li><code><a title="raster.raster.hexagon" href="#raster.raster.hexagon">hexagon</a></code></li>
<li><code><a title="raster.raster.label" href="#raster.raster.label">label</a></code></li>
<li><code><a title="raster.raster.labelobj" href="#raster.raster.labelobj">labelobj</a></code></li>
<li><code><a title="raster.raster.length" href="#raster.raster.length">length</a></code></li>
<li><code><a title="raster.raster.list" href="#raster.raster.list">list</a></code></li>
<li><code><a title="raster.raster.names" href="#raster.raster.names">names</a></code></li>
<li><code><a title="raster.raster.newfigure" href="#raster.raster.newfigure">newfigure</a></code></li>
<li><code><a title="raster.raster.numeric" href="#raster.raster.numeric">numeric</a></code></li>
<li><code><a title="raster.raster.overlay" href="#raster.raster.overlay">overlay</a></code></li>
<li><code><a title="raster.raster.pentagon" href="#raster.raster.pentagon">pentagon</a></code></li>
<li><code><a title="raster.raster.plot" href="#raster.raster.plot">plot</a></code></li>
<li><code><a title="raster.raster.plotobj" href="#raster.raster.plotobj">plotobj</a></code></li>
<li><code><a title="raster.raster.print" href="#raster.raster.print">print</a></code></li>
<li><code><a title="raster.raster.rectangle" href="#raster.raster.rectangle">rectangle</a></code></li>
<li><code><a title="raster.raster.scatter" href="#raster.raster.scatter">scatter</a></code></li>
<li><code><a title="raster.raster.show" href="#raster.raster.show">show</a></code></li>
<li><code><a title="raster.raster.string" href="#raster.raster.string">string</a></code></li>
<li><code><a title="raster.raster.triangle" href="#raster.raster.triangle">triangle</a></code></li>
<li><code><a title="raster.raster.unlabel" href="#raster.raster.unlabel">unlabel</a></code></li>
<li><code><a title="raster.raster.valid" href="#raster.raster.valid">valid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="raster.scatter" href="#raster.scatter">scatter</a></code></h4>
<ul class="">
<li><code><a title="raster.scatter.n" href="#raster.scatter.n">n</a></code></li>
<li><code><a title="raster.scatter.pairdist" href="#raster.scatter.pairdist">pairdist</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>